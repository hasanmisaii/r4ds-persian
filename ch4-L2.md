# ۲۱ پایگاه‌های داده

## ۱.۲۱ مقدمه

مقدار عظیمی از داده‌ها در پایگاه‌های داده ذخیره می‌شوند، بنابراین ضروری است که بدانید چگونه به آن‌ها دسترسی پیدا کنید. گاهی اوقات می‌توانید از کسی بخواهید که یک نسخه از داده را به صورت فایل `.csv` برای شما دانلود کند، اما این کار به سرعت دردسرساز می‌شود: هر بار که نیاز به تغییری دارید باید با فرد دیگری ارتباط برقرار کنید. شما می‌خواهید بتوانید مستقیماً به پایگاه داده دسترسی پیدا کنید تا داده‌ای که نیاز دارید را در زمانی که نیاز دارید، بدست آورید.

در این فصل، ابتدا اصول اولیه بسته DBI را یاد خواهید گرفت: چگونه از آن برای اتصال به یک پایگاه داده و سپس بازیابی داده‌ها با یک پرس‌وجوی SQL استفاده کنید. **SQL**، مخفف **s**tructured **q**uery **l**anguage (زبان پرس‌وجوی ساختاریافته)، زبان مشترک پایگاه‌های داده است و یک زبان مهم برای یادگیری تمام دانشمندان داده است. با این حال، ما با SQL شروع نمی‌کنیم، بلکه به شما dbplyr را آموزش خواهیم داد که می‌تواند کد dplyr شما را به SQL ترجمه کند. ما از این روش برای آموزش برخی از مهم‌ترین ویژگی‌های SQL استفاده خواهیم کرد. در پایان این فصل به یک استاد SQL تبدیل نخواهید شد، اما قادر خواهید بود مهم‌ترین اجزا را شناسایی کنید و بفهمید که چه کاری انجام می‌دهند.

### ۱.۱.۲۱ پیش‌نیازها

در این فصل، DBI و dbplyr را معرفی خواهیم کرد. DBI یک رابط سطح پایین است که به پایگاه‌های داده متصل می‌شود و SQL را اجرا می‌کند؛ dbplyr یک رابط سطح بالا است که کد dplyr شما را به پرس‌وجوهای SQL ترجمه می‌کند و سپس آن‌ها را با DBI اجرا می‌کند.

```{r}
library(DBI)
library(dbplyr)
library(tidyverse)
```

## ۲.۲۱ مبانی پایگاه داده

در ساده‌ترین سطح، می‌توانید یک پایگاه داده را به عنوان مجموعه‌ای از data frame ها در نظر بگیرید که در اصطلاح پایگاه‌های داده **جداول** (tables) نامیده می‌شوند. مانند یک data frame، یک جدول پایگاه داده مجموعه‌ای از ستون‌های نام‌گذاری شده است که هر مقدار در ستون از نوع یکسانی است. سه تفاوت سطح بالا بین data frame ها و جداول پایگاه داده وجود دارد:

- جداول پایگاه داده روی دیسک ذخیره می‌شوند و می‌توانند به طور دلخواه بزرگ باشند. Data frame ها در حافظه ذخیره می‌شوند و اساساً محدود هستند (اگرچه این محدودیت برای بسیاری از مسائل هنوز به اندازه کافی بزرگ است).

- جداول پایگاه داده تقریباً همیشه دارای ایندکس (index) هستند. درست مانند فهرست یک کتاب، یک ایندکس پایگاه داده امکان یافتن سریع سطرهای مورد نظر را بدون نیاز به بررسی هر سطر فراهم می‌کند. Data frame ها و tibble ها ایندکس ندارند، اما data.table ها دارند، که یکی از دلایلی است که آن‌ها بسیار سریع هستند.

- بیشتر پایگاه‌های داده کلاسیک برای جمع‌آوری سریع داده بهینه شده‌اند، نه برای تجزیه و تحلیل داده‌های موجود. این پایگاه‌های داده **سطر-محور** (row-oriented) نامیده می‌شوند زیرا داده‌ها سطر به سطر ذخیره می‌شوند، نه ستون به ستون مانند R. اخیراً، توسعه زیادی در پایگاه‌های داده **ستون-محور** (column-oriented) صورت گرفته است که تجزیه و تحلیل داده‌های موجود را بسیار سریع‌تر می‌کنند.

پایگاه‌های داده توسط سیستم‌های مدیریت پایگاه داده (**DBMS** به اختصار) اجرا می‌شوند که در سه شکل اساسی ارائه می‌شوند:

- **سرویس-گیرنده** (Client-server) DBMS ها روی یک سرور مرکزی قدرتمند اجرا می‌شوند که شما از کامپیوتر خود (سرویس‌گیرنده) به آن متصل می‌شوید. آن‌ها برای اشتراک‌گذاری داده‌ها با چندین نفر در یک سازمان عالی هستند. DBMS های محبوب سرویس-گیرنده شامل PostgreSQL، MariaDB، SQL Server و Oracle هستند.

- **ابری** (Cloud) DBMS ها، مانند Snowflake، RedShift آمازون و BigQuery گوگل، شبیه به DBMS های سرویس-گیرنده هستند، اما در ابر اجرا می‌شوند. این بدان معنی است که می‌توانند به راحتی مجموعه داده‌های بسیار بزرگ را مدیریت کنند و می‌توانند به طور خودکار منابع محاسباتی بیشتری را در صورت نیاز فراهم کنند.

- **درون-فرآیندی** (In-process) DBMS ها، مانند SQLite یا duckdb، کاملاً روی کامپیوتر شما اجرا می‌شوند. آن‌ها برای کار با مجموعه داده‌های بزرگ که شما کاربر اصلی هستید عالی هستند.

## ۳.۲۱ اتصال به پایگاه داده

برای اتصال به پایگاه داده از R، از یک جفت بسته استفاده خواهید کرد:

- همیشه از DBI (**d**ata**b**ase **i**nterface - رابط پایگاه داده) استفاده خواهید کرد زیرا مجموعه‌ای از توابع عمومی را فراهم می‌کند که به پایگاه داده متصل می‌شوند، داده بارگذاری می‌کنند، پرس‌وجوهای SQL را اجرا می‌کنند و غیره.

- همچنین از یک بسته متناسب با DBMS که به آن متصل می‌شوید استفاده خواهید کرد. این بسته دستورات عمومی DBI را به موارد خاص مورد نیاز برای یک DBMS معین ترجمه می‌کند. معمولاً یک بسته برای هر DBMS وجود دارد، به عنوان مثال RPostgres برای PostgreSQL و RMariaDB برای MySQL.

اگر نمی‌توانید یک بسته خاص برای DBMS خود پیدا کنید، معمولاً می‌توانید از بسته odbc استفاده کنید. این بسته از پروتکل ODBC که توسط بسیاری از DBMS ها پشتیبانی می‌شود استفاده می‌کند. odbc به تنظیمات کمی بیشتری نیاز دارد زیرا باید یک درایور ODBC نصب کنید و به بسته odbc بگویید کجا آن را پیدا کند.

به طور مشخص، با استفاده از `DBI::dbConnect()` یک اتصال پایگاه داده ایجاد می‌کنید. اولین آرگومان DBMS را انتخاب می‌کند، سپس آرگومان‌های دوم و بعدی توضیح می‌دهند چگونه به آن متصل شوید (یعنی کجا قرار دارد و اعتبارنامه‌هایی که برای دسترسی به آن نیاز دارید). کد زیر چند نمونه معمولی را نشان می‌دهد:

```{r}
con <- DBI::dbConnect(
  RMariaDB::MariaDB(), 
  username = "foo"
)
con <- DBI::dbConnect(
  RPostgres::Postgres(), 
  hostname = "databases.mycompany.com", 
  port = 1234
)
```

جزئیات دقیق اتصال از DBMS به DBMS بسیار متفاوت است، بنابراین متأسفانه نمی‌توانیم تمام جزئیات را در اینجا پوشش دهیم. این بدان معناست که باید کمی تحقیق خودتان را انجام دهید. معمولاً می‌توانید از سایر دانشمندان داده در تیم خود بپرسید یا با DBA (**d**ata**b**ase **a**dministrator - مدیر پایگاه داده) خود صحبت کنید. تنظیمات اولیه اغلب نیاز به کمی دستکاری (و شاید کمی جستجو در گوگل) دارد تا درست کار کند، اما معمولاً فقط یک بار باید این کار را انجام دهید.

### ۱.۳.۲۱ در این کتاب

راه‌اندازی یک DBMS سرویس-گیرنده یا ابری برای این کتاب دردسرساز خواهد بود، بنابراین در عوض از یک DBMS درون-فرآیندی استفاده خواهیم کرد که کاملاً در یک بسته R زندگی می‌کند: duckdb. به لطف جادوی DBI، تنها تفاوت بین استفاده از duckdb و هر DBMS دیگری نحوه اتصال به پایگاه داده است. این امر آن را برای آموزش عالی می‌کند زیرا می‌توانید به راحتی این کد را اجرا کنید و همچنین به راحتی آنچه را که یاد می‌گیرید در جای دیگر به کار ببرید.

اتصال به duckdb به ویژه ساده است زیرا پیش‌فرض‌ها یک پایگاه داده موقت ایجاد می‌کنند که هنگام خروج از R حذف می‌شود. این برای یادگیری عالی است زیرا تضمین می‌کند که هر بار که R را مجدداً راه‌اندازی می‌کنید از یک صفحه پاک شروع می‌کنید:

```{r}
con <- DBI::dbConnect(duckdb::duckdb())
```

duckdb یک پایگاه داده با کارایی بالا است که بسیار برای نیازهای یک دانشمند داده طراحی شده است. ما در اینجا از آن استفاده می‌کنیم زیرا شروع کار با آن بسیار آسان است، اما همچنین قادر به مدیریت گیگابایت‌ها داده با سرعت بالا است. اگر می‌خواهید از duckdb برای یک پروژه واقعی تجزیه و تحلیل داده استفاده کنید، همچنین باید آرگومان `dbdir` را برای ایجاد یک پایگاه داده دائمی ارائه دهید و به duckdb بگویید کجا آن را ذخیره کند. با فرض اینکه از یک پروژه استفاده می‌کنید، منطقی است که آن را در دایرکتوری `duckdb` پروژه فعلی ذخیره کنید:

```{r}
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = "duckdb")
```

### ۲.۳.۲۱ بارگذاری برخی داده‌ها

از آنجا که این یک پایگاه داده جدید است، باید با افزودن برخی داده‌ها شروع کنیم. در اینجا مجموعه داده‌های `mpg` و `diamonds` را از ggplot2 با استفاده از `DBI::dbWriteTable()` اضافه خواهیم کرد. ساده‌ترین استفاده از `dbWriteTable()` به سه آرگومان نیاز دارد: یک اتصال پایگاه داده، نام جدولی که باید در پایگاه داده ایجاد شود، و یک data frame از داده‌ها.

```{r}
dbWriteTable(con, "mpg", ggplot2::mpg)
dbWriteTable(con, "diamonds", ggplot2::diamonds)
```

اگر از duckdb در یک پروژه واقعی استفاده می‌کنید، ما به شدت توصیه می‌کنیم در مورد `duckdb_read_csv()` و `duckdb_register_arrow()` بیاموزید. اینها روش‌های قدرتمند و کارآمدی را به شما می‌دهند تا به سرعت داده‌ها را مستقیماً در duckdb بارگذاری کنید، بدون اینکه ابتدا نیاز باشد آن را در R بارگذاری کنید.

### ۳.۳.۲۱ مبانی DBI

می‌توانید با استفاده از چند تابع دیگر DBI بررسی کنید که داده‌ها به درستی بارگذاری شده‌اند: `dbListTables()` تمام جداول موجود در پایگاه داده را فهرست می‌کند و `dbReadTable()` محتویات یک جدول را بازیابی می‌کند.

```{r}
dbListTables(con)

con |> 
  dbReadTable("diamonds") |> 
  as_tibble()
```

`dbReadTable()` یک `data.frame` را برمی‌گرداند، بنابراین از `as_tibble()` برای تبدیل آن به یک tibble استفاده می‌کنیم تا به خوبی چاپ شود.

اگر قبلاً SQL را می‌دانید، می‌توانید از `dbGetQuery()` برای دریافت نتایج اجرای یک پرس‌وجو در پایگاه داده استفاده کنید:

```{r}
sql <- "
  SELECT carat, cut, clarity, color, price 
  FROM diamonds 
  WHERE price > 15000
"
as_tibble(dbGetQuery(con, sql))
```

اگر تا به حال SQL ندیده‌اید، نگران نباشید! به زودی بیشتر در مورد آن یاد خواهید گرفت. اما اگر با دقت آن را بخوانید، ممکن است حدس بزنید که پنج ستون از مجموعه داده diamonds و تمام سطرهایی که `price` بزرگ‌تر از ۱۵۰۰۰ است را انتخاب می‌کند.

## ۴.۲۱ مبانی dbplyr

اکنون که به یک پایگاه داده متصل شده‌ایم و برخی داده‌ها را بارگذاری کرده‌ایم، می‌توانیم شروع به یادگیری dbplyr کنیم. dbplyr یک **backend** dplyr است، به این معنی که شما همچنان کد dplyr می‌نویسید اما backend آن را متفاوت اجرا می‌کند. در اینجا، dbplyr به SQL ترجمه می‌شود؛ سایر backend ها شامل [dtplyr](https://dtplyr.tidyverse.org) است که به [data.table](https://r-datatable.com) ترجمه می‌شود، و [multidplyr](https://multidplyr.tidyverse.org) که کد شما را روی چندین هسته اجرا می‌کند.

برای استفاده از dbplyr، ابتدا باید از `tbl()` برای ایجاد یک شی که نمایانگر یک جدول پایگاه داده است استفاده کنید:

```{r}
diamonds_db <- tbl(con, "diamonds")
diamonds_db
```

این شی **تنبل** (lazy) است؛ هنگامی که از افعال dplyr روی آن استفاده می‌کنید، dplyr هیچ کاری انجام نمی‌دهد: فقط دنباله‌ای از عملیاتی که می‌خواهید انجام دهید را ثبت می‌کند و فقط زمانی که نیاز باشد آن‌ها را اجرا می‌کند. به عنوان مثال، پایپلاین زیر را در نظر بگیرید:

```{r}
big_diamonds_db <- diamonds_db |> 
  filter(price > 15000) |> 
  select(carat:clarity, price)

big_diamonds_db
```

می‌توانید بگویید این شی نمایانگر یک پرس‌وجوی پایگاه داده است زیرا نام DBMS را در بالا چاپ می‌کند، و در حالی که تعداد ستون‌ها را به شما می‌گوید، معمولاً تعداد سطرها را نمی‌داند. این به این دلیل است که یافتن تعداد کل سطرها معمولاً نیاز به اجرای پرس‌وجوی کامل دارد، چیزی که ما سعی داریم از آن اجتناب کنیم.

می‌توانید کد SQL تولید شده توسط تابع dplyr `show_query()` را ببینید. اگر dplyr را می‌دانید، این یک راه عالی برای یادگیری SQL است! کمی کد dplyr بنویسید، از dbplyr بخواهید آن را به SQL ترجمه کند و سپس سعی کنید بفهمید چگونه این دو زبان با هم مطابقت دارند.

```{r}
big_diamonds_db |>
  show_query()
```

برای بازگرداندن تمام داده‌ها به R، `collect()` را فراخوانی می‌کنید. در پشت صحنه، این SQL را تولید می‌کند، `dbGetQuery()` را برای دریافت داده فراخوانی می‌کند، سپس نتیجه را به یک tibble تبدیل می‌کند:

```{r}
big_diamonds <- big_diamonds_db |> 
  collect()
big_diamonds
```

معمولاً، از dbplyr برای انتخاب داده‌هایی که از پایگاه داده می‌خواهید استفاده خواهید کرد، و فیلتر کردن و تجمیع پایه را با استفاده از ترجمه‌های توضیح داده شده در زیر انجام می‌دهید. سپس، وقتی آماده تجزیه و تحلیل داده‌ها با توابعی که منحصر به R هستند شدید، داده‌ها را با `collect()` دریافت می‌کنید تا یک tibble در حافظه بدست آورید، و کار خود را با کد خالص R ادامه می‌دهید.

## ۵.۲۱ SQL

بقیه این فصل کمی SQL را از طریق لنز dbplyr به شما آموزش خواهد داد. این یک مقدمه نسبتاً غیرسنتی به SQL است اما امیدواریم که شما را به سرعت با اصول آشنا کند. خوشبختانه، اگر dplyr را درک می‌کنید در موقعیت عالی برای یادگیری سریع SQL هستید زیرا بسیاری از مفاهیم یکسان هستند.

ما رابطه بین dplyr و SQL را با استفاده از چند دوست قدیمی از بسته nycflights13 بررسی خواهیم کرد: `flights` و `planes`. این مجموعه داده‌ها به راحتی می‌توانند وارد پایگاه داده یادگیری ما شوند زیرا dbplyr با تابعی همراه است که جداول را از nycflights13 به پایگاه داده ما کپی می‌کند:

```{r}
dbplyr::copy_nycflights13(con)
flights <- tbl(con, "flights")
planes <- tbl(con, "planes")
```

### ۱.۵.۲۱ مبانی SQL

اجزای سطح بالای SQL **عبارات** (statements) نامیده می‌شوند. عبارات رایج شامل `CREATE` برای تعریف جداول جدید، `INSERT` برای افزودن داده و `SELECT` برای بازیابی داده هستند. ما روی عبارات `SELECT` تمرکز خواهیم کرد که همچنین **پرس‌وجوها** (queries) نامیده می‌شوند، زیرا تقریباً به طور انحصاری آنچه شما به عنوان یک دانشمند داده استفاده خواهید کرد.

یک پرس‌وجو از **بندها** (clauses) تشکیل شده است. پنج بند مهم وجود دارد: `SELECT`، `FROM`، `WHERE`، `ORDER BY` و `GROUP BY`. هر پرس‌وجو باید بندهای `SELECT` و `FROM` را داشته باشد و ساده‌ترین پرس‌وجو `SELECT * FROM table` است که تمام ستون‌ها را از جدول مشخص شده انتخاب می‌کند. این همان چیزی است که dbplyr برای یک جدول دست‌نخورده تولید می‌کند:

```{r}
flights |> show_query()
planes |> show_query()
```

`WHERE` و `ORDER BY` کنترل می‌کنند که کدام سطرها شامل شوند و چگونه مرتب شوند:

```{r}
flights |> 
  filter(dest == "IAH") |> 
  arrange(dep_delay) |>
  show_query()
```

`GROUP BY` پرس‌وجو را به یک خلاصه تبدیل می‌کند و باعث می‌شود تجمیع رخ دهد:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) |> 
  show_query()
```

دو تفاوت مهم بین افعال dplyr و بندهای SELECT وجود دارد:

- در SQL، حروف بزرگ و کوچک مهم نیستند: می‌توانید `select`، `SELECT` یا حتی `SeLeCt` بنویسید. در این کتاب ما به قرارداد رایج نوشتن کلمات کلیدی SQL با حروف بزرگ پایبند خواهیم بود تا آن‌ها را از نام‌های جدول یا متغیر متمایز کنیم.

- در SQL، ترتیب مهم است: همیشه باید بندها را به ترتیب `SELECT`، `FROM`، `WHERE`، `GROUP BY`، `ORDER BY` بنویسید. به طور گیج‌کننده‌ای، این ترتیب با نحوه ارزیابی واقعی بندها که ابتدا `FROM`، سپس `WHERE`، `GROUP BY`، `SELECT` و `ORDER BY` است، مطابقت ندارد.

بخش‌های زیر هر بند را با جزئیات بیشتری بررسی می‌کنند.

### ۲.۵.۲۱ SELECT

بند `SELECT` موتور اصلی پرس‌وجوهاست و همان کاری را که `select()`، `mutate()`، `rename()`، `relocate()` و همانطور که در بخش بعدی خواهید آموخت، `summarize()` انجام می‌دهند.

`select()`، `rename()` و `relocate()` ترجمه‌های بسیار مستقیمی به `SELECT` دارند زیرا فقط بر روی اینکه یک ستون کجا ظاهر می‌شود (در صورت وجود) همراه با نام آن تأثیر می‌گذارند:

```{r}
planes |> 
  select(tailnum, type, manufacturer, model, year) |> 
  show_query()

planes |> 
  select(tailnum, type, manufacturer, model, year) |> 
  rename(year_built = year) |> 
  show_query()

planes |> 
  select(tailnum, type, manufacturer, model, year) |> 
  relocate(manufacturer, model, .before = type) |> 
  show_query()
```

این مثال همچنین به شما نشان می‌دهد که SQL چگونه تغییر نام می‌دهد. در اصطلاح SQL، تغییر نام **نام‌گذاری مستعار** (aliasing) نامیده می‌شود و با `AS` انجام می‌شود. توجه کنید که برخلاف `mutate()`، نام قدیمی در سمت چپ و نام جدید در سمت راست است.

ترجمه‌های `mutate()` به طور مشابهی ساده هستند: هر متغیر به یک عبارت جدید در `SELECT` تبدیل می‌شود:

```{r}
flights |> 
  mutate(
    speed = distance / (air_time / 60)
  ) |> 
  show_query()
```

### ۳.۵.۲۱ FROM

بند `FROM` منبع داده را مشخص می‌کند. برای مدتی نسبتاً کسل‌کننده خواهد بود، زیرا فقط از جداول منفرد استفاده می‌کنیم. هنگامی که به توابع اتصال برسیم، نمونه‌های پیچیده‌تری خواهید دید.

### ۴.۵.۲۱ GROUP BY

`group_by()` به بند `GROUP BY` ترجمه می‌شود و `summarize()` به بند `SELECT` ترجمه می‌شود:

```{r}
diamonds_db |> 
  group_by(cut) |> 
  summarize(
    n = n(),
    avg_price = mean(price, na.rm = TRUE)
  ) |> 
  show_query()
```

### ۵.۵.۲۱ WHERE

`filter()` به بند `WHERE` ترجمه می‌شود:

```{r}
flights |> 
  filter(dest == "IAH" | dest == "HOU") |> 
  show_query()

flights |> 
  filter(arr_delay > 0 & arr_delay < 20) |> 
  show_query()
```

چند جزئیات مهم برای توجه در اینجا وجود دارد:

- `|` به `OR` تبدیل می‌شود و `&` به `AND` تبدیل می‌شود.
- SQL از `=` برای مقایسه استفاده می‌کند، نه `==`. SQL انتساب ندارد، بنابراین احتمال سردرگمی وجود ندارد.
- SQL فقط از `''` برای رشته‌ها استفاده می‌کند، نه `""`. در SQL، `""` برای شناسایی متغیرها استفاده می‌شود، مانند ``` `` ``` در R.

یک عملگر SQL مفید دیگر `IN` است که بسیار نزدیک به `%in%` R است:

```{r}
flights |> 
  filter(dest %in% c("IAH", "HOU")) |> 
  show_query()
```

SQL از `NULL` به جای `NA` استفاده می‌کند. `NULL` ها مشابه `NA` ها رفتار می‌کنند. تفاوت اصلی این است که در حالی که آن‌ها در مقایسه‌ها و محاسبات "مسری" هستند، هنگام خلاصه‌سازی به صورت خاموش حذف می‌شوند. dbplyr اولین بار که با آن مواجه می‌شوید شما را در مورد این رفتار یادآوری خواهد کرد:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(delay = mean(arr_delay))
```

به طور کلی، می‌توانید با `NULL` ها با استفاده از توابعی که برای `NA` ها در R استفاده می‌کنید کار کنید:

```{r}
flights |> 
  filter(!is.na(dep_delay)) |> 
  show_query()
```

این پرس‌وجوی SQL یکی از معایب dbplyr را نشان می‌دهد: در حالی که SQL صحیح است، به اندازه‌ای که ممکن است با دست بنویسید ساده نیست. در این مورد، می‌توانید پرانتزها را حذف کنید و از یک عملگر خاص که خواندن آن آسان‌تر است استفاده کنید:

``` sql
WHERE "dep_delay" IS NOT NULL
```

توجه کنید که اگر متغیری را که با استفاده از summarize ایجاد کرده‌اید `filter()` کنید، dbplyr یک بند `HAVING` تولید خواهد کرد، نه یک بند `WHERE`. این یکی از ویژگی‌های خاص SQL است: `WHERE` قبل از `SELECT` و `GROUP BY` ارزیابی می‌شود، بنابراین SQL به یک بند دیگر نیاز دارد که بعداً ارزیابی شود.

```{r}
diamonds_db |> 
  group_by(cut) |> 
  summarize(n = n()) |> 
  filter(n > 100) |> 
  show_query()
```

### ۶.۵.۲۱ ORDER BY

مرتب‌سازی سطرها شامل یک ترجمه ساده از `arrange()` به بند `ORDER BY` است:

```{r}
flights |> 
  arrange(year, month, day, desc(dep_delay)) |> 
  show_query()
```

توجه کنید که چگونه `desc()` به `DESC` ترجمه می‌شود: این یکی از بسیاری از توابع dplyr است که نام آن مستقیماً از SQL الهام گرفته شده است.

### ۷.۵.۲۱ پرس‌وجوهای فرعی

گاهی اوقات امکان ترجمه یک پایپلاین dplyr به یک عبارت `SELECT` واحد وجود ندارد و باید از یک پرس‌وجوی فرعی (subquery) استفاده کنید. یک **پرس‌وجوی فرعی** فقط یک پرس‌وجو است که به عنوان یک منبع داده در بند `FROM` استفاده می‌شود، به جای جدول معمولی.

dbplyr معمولاً از پرس‌وجوهای فرعی برای دور زدن محدودیت‌های SQL استفاده می‌کند. به عنوان مثال، عبارات در بند `SELECT` نمی‌توانند به ستون‌هایی که تازه ایجاد شده‌اند اشاره کنند. این بدان معناست که پایپلاین (احمقانه) زیر dplyr باید در دو مرحله انجام شود: اولین (داخلی) پرس‌وجو `year1` را محاسبه می‌کند و سپس دومین (خارجی) پرس‌وجو می‌تواند `year2` را محاسبه کند.

```{r}
flights |> 
  mutate(
    year1 = year + 1,
    year2 = year1 + 1
  ) |> 
  show_query()
```

همچنین اگر سعی کردید متغیری را که تازه ایجاد کرده‌اید `filter()` کنید، این را خواهید دید. به یاد داشته باشید، حتی اگر `WHERE` بعد از `SELECT` نوشته شده است، قبل از آن ارزیابی می‌شود، بنابراین در این مثال (احمقانه) به یک پرس‌وجوی فرعی نیاز داریم:

```{r}
flights |> 
  mutate(year1 = year + 1) |> 
  filter(year1 == 2014) |> 
  show_query()
```

گاهی اوقات dbplyr یک پرس‌وجوی فرعی ایجاد می‌کند که در آن ضرورتی ندارد زیرا هنوز نمی‌داند چگونه آن ترجمه را بهینه کند. همانطور که dbplyr در طول زمان بهبود می‌یابد، این موارد نادرتر خواهند شد اما احتمالاً هرگز از بین نخواهند رفت.

### ۸.۵.۲۱ اتصالات

اگر با اتصالات dplyr آشنا هستید، اتصالات SQL بسیار شبیه هستند. در اینجا یک مثال ساده است:

```{r}
flights |> 
  left_join(planes |> rename(year_built = year), join_by(tailnum)) |> 
  show_query()
```

نکته اصلی که باید در اینجا توجه کنید نحو است: اتصالات SQL از بندهای فرعی بند `FROM` برای آوردن جداول اضافی استفاده می‌کنند، با استفاده از `ON` برای تعریف اینکه جداول چگونه مرتبط هستند.

نام‌های dplyr برای این توابع به شدت به SQL متصل هستند که می‌توانید به راحتی SQL معادل برای `inner_join()`، `right_join()` و `full_join()` را حدس بزنید:

``` sql
SELECT flights.*, "type", manufacturer, model, engines, seats, speed
FROM flights
INNER JOIN planes ON (flights.tailnum = planes.tailnum)

SELECT flights.*, "type", manufacturer, model, engines, seats, speed
FROM flights
RIGHT JOIN planes ON (flights.tailnum = planes.tailnum)

SELECT flights.*, "type", manufacturer, model, engines, seats, speed
FROM flights
FULL JOIN planes ON (flights.tailnum = planes.tailnum)
```

احتمالاً هنگام کار با داده‌ها از یک پایگاه داده به اتصالات زیادی نیاز خواهید داشت. این به این دلیل است که جداول پایگاه داده اغلب به صورت بسیار نرمال شده ذخیره می‌شوند، جایی که هر "واقعیت" در یک مکان واحد ذخیره می‌شود و برای داشتن یک مجموعه داده کامل برای تجزیه و تحلیل باید در شبکه پیچیده‌ای از جداول متصل شده توسط کلیدهای اصلی و خارجی حرکت کنید. اگر با این سناریو مواجه شدید، [بسته dm](https://cynkra.github.io/dm/)، توسط Tobias Schieferdecker، Kirill Müller و Darko Bergant، یک نجات‌دهنده است. این بسته می‌تواند به طور خودکار اتصالات بین جداول را با استفاده از محدودیت‌هایی که DBA ها اغلب ارائه می‌دهند تعیین کند، اتصالات را تجسم کند تا ببینید چه اتفاقی می‌افتد، و اتصالاتی که برای اتصال یک جدول به جدول دیگر نیاز دارید را تولید کند.

### ۹.۵.۲۱ افعال دیگر

dbplyr همچنین افعال دیگری مانند `distinct()`، `slice_*()` و `intersect()` را ترجمه می‌کند، و مجموعه رو به رشدی از توابع tidyr مانند `pivot_longer()` و `pivot_wider()` را. آسان‌ترین راه برای دیدن مجموعه کامل آنچه در حال حاضر موجود است بازدید از وبسایت dbplyr است: <https://dbplyr.tidyverse.org/reference/>.

### ۱۰.۵.۲۱ تمرین‌ها

۱. `distinct()` به چه چیزی ترجمه می‌شود؟ `head()` چطور؟

۲. توضیح دهید که هر یک از پرس‌وجوهای SQL زیر چه کاری انجام می‌دهند و سعی کنید آن‌ها را با استفاده از dbplyr بازسازی کنید.

```sql
SELECT * 
FROM flights
WHERE dep_delay < arr_delay

SELECT *, distance / (air_time / 60) AS speed
FROM flights
```

## ۶.۲۱ ترجمه‌های تابع

تا اینجا روی تصویر کلان اینکه چگونه افعال dplyr به بندهای یک پرس‌وجو ترجمه می‌شوند تمرکز کرده‌ایم. اکنون کمی بزرگنمایی می‌کنیم و در مورد ترجمه توابع R که با ستون‌های فردی کار می‌کنند صحبت خواهیم کرد، به عنوان مثال، وقتی از `mean(x)` در یک `summarize()` استفاده می‌کنید چه اتفاقی می‌افتد؟

برای کمک به دیدن آنچه در حال رخ دادن است، از چند تابع کمکی کوچک استفاده خواهیم کرد که یک `summarize()` یا `mutate()` را اجرا می‌کنند و SQL تولید شده را نشان می‌دهند. این کار بررسی چند نوع مختلف و دیدن اینکه چگونه خلاصه‌ها و تبدیلات می‌توانند متفاوت باشند را کمی آسان‌تر می‌کند.

```{r}
summarize_query <- function(df, ...) {
  df |> 
    summarize(...) |> 
    show_query()
}
mutate_query <- function(df, ...) {
  df |> 
    mutate(..., .keep = "none") |> 
    show_query()
}
```

بیایید با برخی خلاصه‌ها شروع کنیم! با نگاه کردن به کد زیر متوجه خواهید شد که برخی از توابع خلاصه، مانند `mean()`، ترجمه نسبتاً ساده‌ای دارند در حالی که دیگران، مانند `median()`، بسیار پیچیده‌تر هستند. پیچیدگی معمولاً برای عملیاتی که در آمار رایج هستند اما در پایگاه‌های داده کمتر رایج هستند بیشتر است.

```{r}
flights |> 
  group_by(year, month, day) |>  
  summarize_query(
    mean = mean(arr_delay, na.rm = TRUE),
    median = median(arr_delay, na.rm = TRUE)
  )
```

ترجمه توابع خلاصه زمانی که آن‌ها را در یک `mutate()` استفاده می‌کنید پیچیده‌تر می‌شود زیرا باید به توابع **پنجره‌ای** (window) تبدیل شوند. در SQL، یک تابع تجمیع معمولی را با افزودن `OVER` بعد از آن به یک تابع پنجره‌ای تبدیل می‌کنید:

```{r}
flights |> 
  group_by(year, month, day) |>  
  mutate_query(
    mean = mean(arr_delay, na.rm = TRUE),
  )
```

در SQL، بند `GROUP BY` به طور انحصاری برای خلاصه‌ها استفاده می‌شود، بنابراین در اینجا می‌بینید که گروه‌بندی از بند `GROUP BY` به `OVER` منتقل شده است.

توابع پنجره‌ای شامل تمام توابعی است که به جلو یا عقب نگاه می‌کنند، مانند `lead()` و `lag()` که به ترتیب به مقدار "قبلی" یا "بعدی" نگاه می‌کنند:

```{r}
flights |> 
  group_by(dest) |>  
  arrange(time_hour) |> 
  mutate_query(
    lead = lead(arr_delay),
    lag = lag(arr_delay)
  )
```

در اینجا مهم است که داده‌ها را `arrange()` کنید، زیرا جداول SQL ترتیب ذاتی ندارند. در واقع، اگر از `arrange()` استفاده نکنید ممکن است هر بار سطرها را با ترتیب متفاوتی دریافت کنید! توجه کنید که برای توابع پنجره‌ای، اطلاعات ترتیب‌بندی تکرار می‌شود: بند `ORDER BY` پرس‌وجوی اصلی به طور خودکار برای توابع پنجره‌ای اعمال نمی‌شود.

یک تابع مهم دیگر SQL `CASE WHEN` است. به عنوان ترجمه `if_else()` و `case_when()`، تابع dplyr که مستقیماً الهام‌بخش آن بوده، استفاده می‌شود. در اینجا چند نمونه ساده است:

```{r}
flights |> 
  mutate_query(
    description = if_else(arr_delay > 0, "delayed", "on-time")
  )
flights |> 
  mutate_query(
    description = 
      case_when(
        arr_delay < -5 ~ "early", 
        arr_delay < 5 ~ "on-time",
        arr_delay >= 5 ~ "late"
      )
  )
```

`CASE WHEN` همچنین برای برخی توابع دیگر که ترجمه مستقیمی از R به SQL ندارند استفاده می‌شود. یک مثال خوب از این `cut()` است:

```{r}
flights |> 
  mutate_query(
    description =  cut(
      arr_delay, 
      breaks = c(-Inf, -5, 5, Inf), 
      labels = c("early", "on-time", "late")
    )
  )
```

dbplyr همچنین توابع رایج دستکاری رشته و تاریخ-زمان را ترجمه می‌کند که می‌توانید در `vignette("translation-function", package = "dbplyr")` در مورد آن‌ها بیاموزید. ترجمه‌های dbplyr قطعاً کامل نیستند و توابع زیادی در R وجود دارند که هنوز ترجمه نشده‌اند، اما dbplyr کار شگفت‌انگیزی در پوشش توابعی که بیشتر اوقات استفاده خواهید کرد انجام می‌دهد.

## ۷.۲۱ خلاصه

در این فصل یاد گرفتید چگونه به داده‌ها از پایگاه‌های داده دسترسی پیدا کنید. ما روی dbplyr تمرکز کردیم، یک "backend" dplyr که به شما امکان می‌دهد کد dplyr که با آن آشنا هستید را بنویسید و به طور خودکار به SQL ترجمه شود. ما از آن ترجمه برای آموزش کمی SQL به شما استفاده کردیم؛ یادگیری مقداری SQL مهم است زیرا رایج‌ترین زبان برای کار با داده‌هاست و دانستن مقداری از آن ارتباط شما را با سایر افراد داده که از R استفاده نمی‌کنند آسان‌تر خواهد کرد.

اگر این فصل را به پایان رسانده‌اید و می‌خواهید بیشتر در مورد SQL بیاموزید، دو توصیه داریم:

- [*SQL for Data Scientists*](https://sqlfordatascientists.com) نوشته Renée M. P. Teate یک مقدمه به SQL است که به طور خاص برای نیازهای دانشمندان داده طراحی شده است و شامل نمونه‌هایی از نوع داده‌های بسیار به هم پیوسته‌ای است که احتمالاً در سازمان‌های واقعی با آن‌ها مواجه خواهید شد.

- [*Practical SQL*](https://www.practicalsql.com) نوشته Anthony DeBarros از دیدگاه یک روزنامه‌نگار داده (یک دانشمند داده متخصص در گفتن داستان‌های جذاب) نوشته شده است و با جزئیات بیشتری در مورد وارد کردن داده‌های خود به یک پایگاه داده و اجرای DBMS خودتان می‌پردازد.

در فصل بعد، در مورد یک backend دیگر dplyr برای کار با داده‌های بزرگ یاد خواهیم گرفت: arrow. Arrow برای کار با فایل‌های بزرگ روی دیسک طراحی شده است و یک مکمل طبیعی برای پایگاه‌های داده است.
