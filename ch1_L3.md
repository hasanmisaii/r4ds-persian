# 3 تبدیل داده‌ها

## 1.3 مقدمه

تصویرسازی ابزار مهمی برای تولید بینش و دانش است، اما به ندرت داده‌ها را دقیقاً در شکل درستی که برای ساخت نمودار مورد نظرتان نیاز دارید، دریافت می‌کنید.
اغلب باید متغیرهای جدیدی ایجاد کنید یا خلاصه‌ سازی‌هایی برای پاسخ دادن به سؤال‌ها با داده‌ها تهیه کنید، یا شاید فقط بخواهید متغیرها را تغییر نام دهید یا مشاهدات را مرتب کنید تا کار با داده‌ها کمی آسان‌تر شود.
در این فصل یاد خواهید گرفت که چگونه همه اینها (و بیشتر!) را انجام دهید، به طوری که با تبدیل داده‌ها با استفاده از بسته **dplyr** و مجموعه داده جدیدی درباره پروازهای خروجی از شهر نیویورک در سال 2013 آشنا خواهید شد.

هدف این فصل ارائه نمای کلی از همه ابزارهای کلیدی برای تبدیل یک data frame است.
ابتدا با توابعی شروع خواهیم کرد که روی سطرها و سپس ستون‌های یک data frame عمل می‌کنند، سپس برمی‌گردیم تا درباره pipe، ابزار مهمی که برای ترکیب کردن توابع استفاده می‌شوند، بیشتر صحبت کنیم.
سپس قابلیت کار با گروه‌ها را معرفی خواهیم کرد.
فصل را با مطالعه موردی که کار با این توابع را در عمل نشان می‌دهد، به پایان خواهیم رساند.
در فصل‌های بعدی، با جزئیات بیشتری به این توابع بازخواهیم گشت به طوری که با آنها انواع خاصی از داده‌ها (مثل اعداد، رشته‌ها، تاریخ‌ها) را بررسی خواهیم کرد.

### 1.1.3 پیش‌نیازها

در این فصل، روی بسته dplyr، دییگر عضو اصلی tidyverse تمرکز خواهیم کرد.
ایده‌های کلیدی را با استفاده از داده‌هایی از بسته nycflights13 نشان خواهیم داد و از ggplot2 برای کمک به درک داده‌ها استفاده خواهیم کرد.

```{r}
library(nycflights13)
library(tidyverse)
#> ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──
#> ✔ dplyr     1.1.4     ✔ readr     2.1.5
#> ✔ forcats   1.0.0     ✔ stringr   1.5.1
#> ✔ ggplot2   3.5.2     ✔ tibble    3.3.0
#> ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
#> ✔ purrr     1.1.0     
#> ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──
#> ✖ dplyr::filter() masks stats::filter()
#> ✖ dplyr::lag()    masks stats::lag()
#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
```

به پیام مغایرت‌هایی که هنگام بارگذاری tidyverse چاپ می‌شود، دقت کنید.
این پیام به شما می‌گوید که dplyr برخی توابع در زبان پایه R را بازنویسی می‌کند.
اگر بخواهید پس از بارگذاری dplyr از نسخه پایه این توابع استفاده کنید، باید از نام کامل آنها استفاده کنید: `()filter::stats` و `()lag::stats`.
تا کنون، این که بسته‌ها شامل چه توابعی هستند را به دلیل کم اهمیت بودنشان نادیده گرفتیم.
با این حال، شناخت آن بسته می‌تواند به یافتن توابع مرتبط کمک کند، پس وقتی دقیقاً نیاز داریم تا بدانیم که یک تابع از کدام بسته می‌آید از دستور یکسان همانند R استفاده خواهیم کرد: `()functionname::packagename`.

### 2.1.3 بسته nycflights13

برای کاوش توابع اصلی dplyr، از `nycflights13::flights` استفاده خواهیم کرد.
این مجموعه داده شامل همه 336,776 پروازهایی است که در سال 2013 از شهر نیویورک حرکت کردند.
داده‌ها از [اداره آمار حمل‌ونقل آمریکا](https://www.transtats.bts.gov/DL_SelectFields.aspx?gnoyr_VQ=FGJ&QO_fu146_anzr=b0-gvzr) می‌آید و در `?flights` مستند شده است.

```{r}
flights
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

داده‌های `flights` یک tibble (ساختار جدید داده در R) است، نوع خاصی از data frame که توسط tidyverse استفاده می‌شود تا از برخی مشکلات رایج جلوگیری کند.
مهم‌ترین تفاوت بین tibble‌ها و data frame‌ها نحوه چاپ tibble‌هاست؛ آنها برای مجموعه داده‌های بزرگ طراحی شده‌اند، بنابراین فقط چند سطر اول و فقط ستون‌هایی که در یک صفحه جا می‌شوند را نشان می‌دهند.
چند گزینه برای دیدن همه مجموعه داده وجود دارد.
اگر از RStudio استفاده می‌کنید، احتمالاً راحت‌ترین روش `View(flights)` است که یک نمای تعاملی، با قابلیت پایین و بالا رفتن و قابلیت فیلترشدن را نمایش می‌دهد.
در غیر این صورت می‌توانید از `print(flights, width = Inf)` برای نشان دادن همه ستون‌ها استفاده کنید، یا از `glimpse()`:

```{r}
glimpse(flights)
#> Rows: 336,776
#> Columns: 19
#> $ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013…
#> $ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…
#> $ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…
#> $ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 55…
#> $ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 60…
#> $ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2,…
#> $ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 8…
#> $ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 8…
#> $ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7,…
#> $ carrier        <chr> "UA", "UA", "AA", "B6", "DL", "UA", "B6", "EV", "B6"…
#> $ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301…
#> $ tailnum        <chr> "N14228", "N24211", "N619AA", "N804JB", "N668DN", "N…
#> $ origin         <chr> "EWR", "LGA", "JFK", "JFK", "LGA", "EWR", "EWR", "LG…
#> $ dest           <chr> "IAH", "IAH", "MIA", "BQN", "ATL", "ORD", "FLL", "IA…
#> $ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149…
#> $ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 73…
#> $ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6…
#> $ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59…
#> $ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-0…
```

در هر دو نمایش، نام متغیرها با اختصاراتی دنبال می‌شوند که نوع هر متغیر را به شما می‌گویند: `<int>` نشان‌دهنده اعداد صحیح، `<dbl>` نشان‌دهنده اعداد حقیقی، `<chr>` برای کارکتر (یا رشته‌ها) و `<dttm>` نشان‌دهنده تاریخ-زمان است.
اینها مهم هستند چون عملیاتی که می‌توانید روی یک ستون انجام دهید به شدت به "نوع" آن بستگی دارد.

### مبانی dplyr

شما در شرف یادگیری فعل‌های (توابع) اصلی dplyr هستید که به شما امکان حل اکثریت قریب به اتفاق چالش‌های دستکاری داده‌تان را خواهد داد.
اما قبل از بحث درباره تفاوت‌های فردی آنها، ارزش دارد که چیزی که مشترک دارند را بیان کنیم:

1. آرگومان اول همیشه یک data frame است.

2. آرگومان‌های بعدی معمولاً توصیف می‌کنند که روی کدام ستون‌ها عمل کنند با استفاده از نام متغیرها (بدون نقل قول).

3. خروجی همیشه یک data frame جدید است.

چون هر فعل یک کار را خوب انجام می‌دهد، حل مسائل پیچیده معمولاً نیاز به ترکیب چندین فعل دارد، و ما این کار را با pipe، `|>` انجام خواهیم داد.
درباره pipe بیشتر در بخش بعد بحث خواهیم کرد، اما به طور خلاصه، pipe چیزی که در سمت چپش است را می‌گیرد و به تابع سمت راستش می‌دهد تا `x |> f(y)` معادل `f(x, y)` باشد، و `x |> f(y) |> g(z)` معادل `g(f(x, y), z)` باشد.
آسان‌ترین راه تلفظ pipe "سپس" است.
این امکان را فراهم می‌کند که حتی اگر هنوز جزئیات را یاد نگرفته‌اید، درک کلی از کد زیر پیدا کنید:

```{r}
#| eval: false
flights |>
  filter(dest == "IAH") |> 
  group_by(year, month, day) |> 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )
```

فعل‌های dplyr در چهار گروه بر اساس آنچه که روی آن عمل می‌کنند سازماندهی شده‌اند: **سطرها**، **ستون‌ها**، **گروه‌ها**، یا **جداول**.
در بخش‌های زیر، مهم‌ترین فعل‌ها برای سطرها، ستون‌ها و گروه‌ها را یاد خواهید گرفت.
سپس، به فعل‌های join که روی جداول کار می‌کنند بازخواهیم گشت.
بیایید شروع کنیم!

## سطرها

مهم‌ترین فعل‌هایی که روی سطرهای یک مجموعه داده عمل می‌کنند `filter()` است که تغییر می‌دهد کدام سطرها موجودند بدون تغییر ترتیبشان، و `arrange()` که ترتیب سطرها را تغییر می‌دهد بدون تغییر اینکه کدام‌ها موجودند.
هر دو تابع فقط روی سطرها تأثیر می‌گذارند و ستون‌ها دست نخورده باقی می‌مانند.
همچنین درباره `distinct()` که سطرهایی با مقادیر منحصر به فرد پیدا می‌کند، بحث خواهیم کرد.
برخلاف `arrange()` و `filter()` می‌تواند به صورت اختیاری ستون‌ها را نیز تغییر دهد.

### `filter()`

`filter()` به شما اجازه می‌دهد سطرها را بر اساس مقادیر ستون‌ها نگه دارید.
آرگومان اول data frame است.
آرگومان دوم و بعدی شرایطی هستند که برای نگه داشتن سطر باید درست باشند.
برای مثال، می‌توانیم همه پروازهایی که بیش از 120 دقیقه (دو ساعت) دیر حرکت کردند را پیدا کنیم:

```{r}
flights |> 
  filter(dep_delay > 120)
```

علاوه بر `>` (بزرگ‌تر از)، می‌توانید از `>=` (بزرگ‌تر یا مساوی)، `<` (کوچک‌تر از)، `<=` (کوچک‌تر یا مساوی)، `==` (مساوی)، و `!=` (نامساوی) استفاده کنید.
همچنین می‌توانید شرایط را با `&` یا `,` برای نشان دادن "و" (بررسی هر دو شرط) یا با `|` برای نشان دادن "یا" (بررسی هر کدام از شرایط) ترکیب کنید:

```{r}
# پروازهایی که در 1 ژانویه حرکت کردند
flights |> 
  filter(month == 1 & day == 1)

# پروازهایی که در ژانویه یا فوریه حرکت کردند
flights |> 
  filter(month == 1 | month == 2)
```

میانبر مفیدی وجود دارد وقتی `|` و `==` را ترکیب می‌کنید: `%in%`.
سطرهایی را نگه می‌دارد که متغیر با یکی از مقادیر سمت راست برابر باشد:

```{r}
# راه کوتاه‌تر برای انتخاب پروازهایی که در ژانویه یا فوریه حرکت کردند
flights |> 
  filter(month %in% c(1, 2))
```

زمانی که `filter()` را اجرا می‌کنید، dplyr عملیات فیلتر را اجرا می‌کند، data frame جدیدی ایجاد می‌کند و سپس آن را چاپ می‌کند.
مجموعه داده موجود `flights` را تغییر نمی‌دهد چون توابع dplyr هرگز ورودی‌هایشان را تغییر نمی‌دهند.
برای ذخیره نتیجه، باید از عملگر تخصیص `<-` استفاده کنید:

```{r}
jan1 <- flights |> 
  filter(month == 1 & day == 1)
```

### اشتباهات رایج

وقتی با R شروع می‌کنید، آسان‌ترین اشتباه استفاده از `=` به جای `==` هنگام آزمایش تساوی است.
`filter()` وقتی این اتفاق بیفتد به شما اطلاع می‌دهد:

```{r}
#| error: true
flights |> 
  filter(month = 1)
```

اشتباه دیگر این است که جملات "یا" را مثل انگلیسی بنویسید:

```{r}
#| eval: false
flights |> 
  filter(month == 1 | 2)
```

این "کار می‌کند"، به این معنا که خطا نمی‌دهد، اما کاری که می‌خواهید انجام نمی‌دهد چون `|` ابتدا شرط `month == 1` را بررسی می‌کند و سپس شرط `2` را که شرط منطقی برای بررسی نیست.

### `arrange()`

`arrange()` ترتیب سطرها را بر اساس مقدار ستون‌ها تغییر می‌دهد.
یک data frame و مجموعه‌ای از نام ستون‌ها (یا عبارات پیچیده‌تر) برای مرتب‌سازی می‌گیرد.
اگر بیش از یک نام ستون ارائه دهید، هر ستون اضافی برای شکستن تساوی در مقادیر ستون‌های قبلی استفاده خواهد شد.
برای مثال، کد زیر بر اساس زمان حرکت که در چهار ستون پخش شده، مرتب می‌کند.
ابتدا زودترین سال‌ها، سپس در هر سال، زودترین ماه‌ها و غیره را می‌گیریم.

```{r}
flights |> 
  arrange(year, month, day, dep_time)
```

می‌توانید از `desc()` روی یک ستون درون `arrange()` استفاده کنید تا data frame را بر اساس آن ستون به ترتیب نزولی (بزرگ به کوچک) مرتب کنید.
برای مثال، این کد پروازها را از بیشترین تا کمترین تأخیر مرتب می‌کند:

```{r}
flights |> 
  arrange(desc(dep_delay))
```

توجه کنید که تعداد سطرها تغییر نکرده است -- ما فقط داره را مرتب می‌کنیم، فیلتر نمی‌کنیم.

### `distinct()`

`distinct()` همه سطرهای منحصر به فرد در یک مجموعه داده را پیدا می‌کند، پس از نظر فنی، عمدتاً روی سطرها عمل می‌کند.
با این حال، بیشتر اوقات، ترکیب متمایز برخی متغیرها را می‌خواهید، پس می‌توانید به صورت اختیاری نام ستون‌ها را نیز ارائه دهید:

```{r}
# حذف سطرهای تکراری، اگر وجود داشته باشند
flights |> 
  distinct()

# پیدا کردن همه جفت‌های منحصر به فرد مبدأ و مقصد
flights |> 
  distinct(origin, dest)
```

همچنین، اگر می‌خواهید هنگام فیلتر کردن برای سطرهای منحصر به فرد، ستون‌های دیگر را نگه دارید، می‌توانید از گزینه `.keep_all = TRUE` استفاده کنید.

```{r}
flights |> 
  distinct(origin, dest, .keep_all = TRUE)
```

تصادفی نیست که همه این پروازهای متمایز در 1 ژانویه هستند: `distinct()` اولین رخداد یک سطر منحصر به فرد در مجموعه داده را پیدا می‌کند و بقیه را دور می‌اندازد.

اگر می‌خواهید تعداد رخدادها را پیدا کنید، بهتر است `distinct()` را با `count()` جایگزین کنید.
با آرگومان `sort = TRUE`، می‌توانید آنها را به ترتیب نزولی تعداد رخدادها مرتب کنید.

```{r}
flights |>
  count(origin, dest, sort = TRUE)
```

### تمرینات

1. در یک pipeline واحد برای هر شرط، همه پروازهایی که شرط را برآورده می‌کنند پیدا کنید:

   - تأخیر ورود دو ساعت یا بیشتر داشتند
   - به هیوستون پرواز کردند (`IAH` یا `HOU`)
   - توسط United، American، یا Delta اداره می‌شدند
   - در تابستان حرکت کردند (ژوئیه، آگوست، و سپتامبر)
   - بیش از دو ساعت دیر رسیدند اما دیر حرکت نکردند
   - حداقل یک ساعت تأخیر داشتند، اما بیش از 30 دقیقه در پرواز جبران کردند

2. `flights` را مرتب کنید تا پروازهایی با بیشترین تأخیر حرکت را پیدا کنید.
   پروازهایی که زودتر از همه صبح حرکت کردند را پیدا کنید.

3. `flights` را مرتب کنید تا سریع‌ترین پروازها را پیدا کنید.

4. آیا در هر روز از سال 2013 پروازی بود؟

5. کدام پروازها بیشترین فاصله را طی کردند؟
   کدام‌ها کمترین فاصله را طی کردند؟

6. آیا ترتیب استفاده از `filter()` و `arrange()` اگر از هر دو استفاده می‌کنید مهم است؟
   چرا/چرا نه؟

## ستون‌ها

چهار فعل مهم وجود دارد که روی ستون‌ها تأثیر می‌گذارند بدون تغییر سطرها: `mutate()` ستون‌های جدیدی که از ستون‌های موجود مشتق شده‌اند ایجاد می‌کند، `select()` تغییر می‌دهد کدام ستون‌ها موجودند، `rename()` نام ستون‌ها را تغییر می‌دهد، و `relocate()` موقعیت ستون‌ها را تغییر می‌دهد.

### `mutate()`

کار `mutate()` اضافه کردن ستون‌های جدیدی است که از ستون‌های موجود محاسبه می‌شوند.
در فصل‌های تبدیل، مجموعه بزرگی از توابع که می‌توانید برای دستکاری انواع مختلف متغیرها استفاده کنید یاد خواهید گرفت.
فعلاً، با جبر پایه که به ما اجازه محاسبه `gain`، میزان زمانی که پرواز تأخیردار در هوا جبران کرد، و `speed` به مایل در ساعت می‌دهد، بسنده می‌کنیم:

```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60
  )
```

به طور پیش‌فرض، `mutate()` ستون‌های جدید را در سمت راست مجموعه داده‌تان اضافه می‌کند که دیدن آنچه اتفاق می‌افتد را دشوار می‌کند.
می‌توانیم از آرگومان `.before` استفاده کنیم تا متغیرها را به سمت چپ اضافه کنیم:

```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .before = 1
  )
```

`.` نشان می‌دهد که `.before` آرگومان تابع است، نه نام متغیر سومی که در حال ایجاد آن هستیم.
همچنین می‌توانید از `.after` برای اضافه کردن بعد از یک متغیر استفاده کنید، و در هر دو `.before` و `.after` می‌توانید از نام متغیر به جای موقعیت استفاده کنید.
برای مثال، می‌توانیم متغیرهای جدید را بعد از `day` اضافه کنیم:

```{r}
#| results: false
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .after = day
  )
```

همچنین، می‌توانید با آرگومان `.keep` کنترل کنید کدام متغیرها نگه داشته شوند.
آرگومان بخصوص مفید `"used"` است که مشخص می‌کند فقط ستون‌هایی که در مرحله `mutate()` درگیر یا ایجاد شدند نگه داریم.
برای مثال، خروجی زیر فقط شامل متغیرهای `dep_delay`، `arr_delay`، `air_time`، `gain`، `hours`، و `gain_per_hour` خواهد بود.

```{r}
#| results: false
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )
```

### `select()`

غیرمعمول نیست که مجموعه داده‌هایی با صدها یا حتی هزاران متغیر دریافت کنید.
در این وضعیت، اولین چالش اغلب فقط تمرکز روی متغیرهایی است که علاقه‌مند هستید.
`select()` به شما اجازه می‌دهد با استفاده از عملیاتی بر اساس نام متغیرها به سرعت روی زیرمجموعه مفیدی زوم کنید:

- انتخاب ستون‌ها با نام:

  ```{r}
  #| results: false
  flights |> 
    select(year, month, day)
  ```

- انتخاب همه ستون‌ها بین year و day (شامل):

  ```{r}
  #| results: false
  flights |> 
    select(year:day)
  ```

- انتخاب همه ستون‌ها به جز آنهایی از year تا day (شامل):

  ```{r}
  #| results: false
  flights |> 
    select(!year:day)
  ```

- انتخاب همه ستون‌هایی که character هستند:

  ```{r}
  #| results: false
  flights |> 
    select(where(is.character))
  ```

تعدادی تابع کمکی وجود دارد که می‌توانید درون `select()` استفاده کنید:

- `starts_with("abc")`: نام‌هایی که با "abc" شروع می‌شوند را منطبق می‌کند.
- `ends_with("xyz")`: نام‌هایی که با "xyz" تمام می‌شوند را منطبق می‌کند.
- `contains("ijk")`: نام‌هایی که شامل "ijk" هستند را منطبق می‌کند.
- `num_range("x", 1:3)`: `x1`، `x2` و `x3` را منطبق می‌کند.

می‌توانید هنگام `select()` کردن متغیرها آنها را با استفاده از `=` تغییر نام دهید.
نام جدید در سمت چپ `=` ظاهر می‌شود و متغیر قدیمی در سمت راست ظاهر می‌شود:

```{r}
flights |> 
  select(tail_num = tailnum)
```

### `rename()`

اگر می‌خواهید همه متغیرهای موجود را نگه دارید و فقط چند تایی را تغییر نام دهید، می‌توانید به جای `select()` از `rename()` استفاده کنید:

```{r}
flights |> 
  rename(tail_num = tailnum)
```

### `relocate()`

از `relocate()` برای جابجایی متغیرها استفاده کنید.
ممکن است بخواهید متغیرهای مرتبط را کنار هم جمع کنید یا متغیرهای مهم را به جلو ببرید.
به طور پیش‌فرض `relocate()` متغیرها را به جلو می‌برد:

```{r}
flights |> 
  relocate(time_hour, air_time)
```

همچنین می‌توانید با استفاده از آرگومان‌های `.before` و `.after`، درست مثل `mutate()`، مشخص کنید کجا قرار دهید:

```{r}
#| results: false
flights |> 
  relocate(year:dep_time, .after = time_hour)
flights |> 
  relocate(starts_with("arr"), .before = dep_time)
```

### تمرینات

1. `dep_time`، `sched_dep_time`، و `dep_delay` را مقایسه کنید.
   انتظار دارید این سه عدد چگونه مرتبط باشند؟

2. تا جای ممکن راه‌های زیادی برای انتخاب `dep_time`، `dep_delay`، `arr_time`، و `arr_delay` از `flights` بیاندیشید.

3. اگر نام همان متغیر را چندین بار در یک فراخوانی `select()` مشخص کنید چه اتفاقی می‌افتد؟

4. تابع `any_of()` چه کاری می‌کند؟
   چرا ممکن است در ارتباط با این بردار مفید باشد؟

   ```{r}
   variables <- c("year", "month", "day", "dep_delay", "arr_delay")
   ```

5. نتیجه اجرای کد زیر شما را متعجب می‌کند؟
   کمک‌کنندگان select به طور پیش‌فرض چگونه با حروف بزرگ و کوچک رفتار می‌کنند؟
   چگونه می‌توانید این پیش‌فرض را تغییر دهید؟

   ```{r}
   #| eval: false
   flights |> select(contains("TIME"))
   ```

6. `air_time` را به `air_time_min` تغییر نام دهید تا واحد اندازه‌گیری را نشان دهد و آن را به ابتدای data frame منتقل کنید.

## Pipe

نمونه‌های ساده pipe را در بالا نشان داده‌ایم، اما قدرت واقعی آن زمانی ظاهر می‌شود که شروع به ترکیب چندین فعل می‌کنید.
برای مثال، تصور کنید می‌خواهید سریع‌ترین پروازها به فرودگاه IAH هیوستون را پیدا کنید: باید `filter()`، `mutate()`، `select()`، و `arrange()` را ترکیب کنید:

```{r}
flights |> 
  filter(dest == "IAH") |> 
  mutate(speed = distance / air_time * 60) |> 
  select(year:day, dep_time, carrier, flight, speed) |> 
  arrange(desc(speed))
```

حتی اگرچه این pipeline چهار مرحله دارد، خواندن آن آسان است چون فعل‌ها در ابتدای هر خط می‌آیند: با داده `flights` شروع کنید، سپس فیلتر، سپس mutate، سپس select، سپس arrange.

اگر pipe نداشتیم چه اتفاقی می‌افتاد؟
می‌توانستیم هر فراخوانی تابع را درون فراخوانی قبلی تو در تو کنیم:

```{r}
#| results: false
arrange(
  select(
    mutate(
      filter(
        flights, 
        dest == "IAH"
      ),
      speed = distance / air_time * 60
    ),
    year:day, dep_time, carrier, flight, speed
  ),
  desc(speed)
)
```

یا می‌توانستیم از یکسری شیء میانی استفاده کنیم:

```{r}
#| results: false
flights1 <- filter(flights, dest == "IAH")
flights2 <- mutate(flights1, speed = distance / air_time * 60)
flights3 <- select(flights2, year:day, dep_time, carrier, flight, speed)
arrange(flights3, desc(speed))
```

در حالی که هر دو شکل زمان و مکان خودشان را دارند، pipe عموماً کد تحلیل داده‌ای تولید می‌کند که نوشتن و خواندن آن آسان‌تر است.

## گروه‌ها

تا کنون درباره توابعی که با سطرها و ستون‌ها کار می‌کنند یاد گرفته‌اید.
dplyr وقتی قابلیت کار با گروه‌ها را اضافه می‌کنید حتی قدرتمندتر می‌شود.
در این بخش، روی مهم‌ترین توابع تمرکز خواهیم کرد: `group_by()`، `summarize()`، و خانواده توابع slice.

### `group_by()`

از `group_by()` برای تقسیم مجموعه داده‌تان به گروه‌هایی که برای تحلیلتان معنادار هستند استفاده کنید:

```{r}
flights |> 
  group_by(month)
```

`group_by()` داده را تغییر نمی‌دهد اما اگر دقت کنید به خروجی، متوجه خواهید شد که نشان می‌دهد "grouped by" month است (`Groups: month [12]`).
این بدان معناست که عملیات بعدی حالا "بر اساس ماه" کار خواهند کرد.
`group_by()` این ویژگی گروه‌بندی (که به عنوان class شناخته می‌شود) را به data frame اضافه می‌کند که رفتار فعل‌های بعدی اعمال شده روی داده را تغییر می‌دهد.

### `summarize()`

مهم‌ترین عملیات گروه‌بندی شده خلاصه‌سازی است که اگر برای محاسبه یک آمار خلاصه واحد استفاده شود، data frame را کاهش می‌دهد تا یک سطر برای هر گروه داشته باشد.
در dplyr، این عملیات توسط `summarize()` انجام می‌شود، همانطور که مثال زیر نشان می‌دهد که میانگین تأخیر حرکت را بر حسب ماه محاسبه می‌کند:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay)
  )
```

اوه! مشکلی پیش آمده، و همه نتایج ما `NA` (تلفظ می‌شود "N-A") هستند، نماد R برای مقدار گمشده.
این اتفاق افتاده چون برخی از پروازهای مشاهده شده داده‌های گمشده در ستون تأخیر داشتند، و بنابراین وقتی میانگین شامل آن مقادیر را محاسبه کردیم، نتیجه `NA` گرفتیم.
با تنظیم آرگومان `na.rm` روی `TRUE` به تابع `mean()` می‌گوییم همه مقادیر گمشده را نادیده بگیرد:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE)
  )
```

می‌توانید تعداد دلخواهی خلاصه در یک فراخوانی `summarize()` ایجاد کنید.
در فصل‌های آینده خلاصه‌های مختلف مفید یاد خواهید گرفت، اما یک خلاصه بسیار مفید `n()` است که تعداد سطرها در هر گروه را برمی‌گرداند:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE), 
    n = n()
  )
```

میانگین‌ها و شمارش‌ها می‌توانند شما را در علم داده تا حد تعجب‌آوری پیش ببرند!

### توابع `slice_`

پنج تابع مفید وجود دارد که به شما اجازه استخراج سطرهای خاص درون هر گروه را می‌دهند:

- `df |> slice_head(n = 1)` اولین سطر از هر گروه را می‌گیرد.
- `df |> slice_tail(n = 1)` آخرین سطر در هر گروه را می‌گیرد.
- `df |> slice_min(x, n = 1)` سطر با کوچک‌ترین مقدار ستون `x` را می‌گیرد.
- `df |> slice_max(x, n = 1)` سطر با بزرگ‌ترین مقدار ستون `x` را می‌گیرد.
- `df |> slice_sample(n = 1)` یک سطر تصادفی می‌گیرد.

می‌توانید `n` را تغییر دهید تا بیش از یک سطر انتخاب کنید، یا به جای `n =`، می‌توانید از `prop = 0.1` استفاده کنید تا (مثلاً) 10 درصد سطرها در هر گروه را انتخاب کنید.
برای مثال، کد زیر پروازهایی که بیشترین تأخیر ورود در هر مقصد دارند را پیدا می‌کند:

```{r}
flights |> 
  group_by(dest) |> 
  slice_max(arr_delay, n = 1) |>
  relocate(dest)
```

توجه کنید که 105 مقصد وجود دارد اما اینجا 108 سطر می‌گیریم.
چه خبر است؟
`slice_min()` و `slice_max()` مقادیر مساوی را نگه می‌دارند پس `n = 1` یعنی همه سطرهایی با بالاترین مقدار را به ما بده.
اگر دقیقاً یک سطر در هر گروه می‌خواهید می‌توانید `with_ties = FALSE` تنظیم کنید.

### گروه‌بندی بر اساس چندین متغیر

می‌توانید با استفاده از بیش از یک متغیر گروه ایجاد کنید.
برای مثال، می‌توانیم برای هر تاریخ یک گروه بسازیم.

```{r}
daily <- flights |>  
  group_by(year, month, day)
daily
```

وقتی tibble گروه‌بندی شده با بیش از یک متغیر را خلاصه می‌کنید، هر خلاصه آخرین گروه را حذف می‌کند.
در نگاه گذشته، این روش خوبی برای کارکرد این تابع نبود، اما تغییر آن بدون شکستن کد موجود دشوار است.
برای واضح کردن آنچه اتفاق می‌افتد، dplyr پیامی نمایش می‌دهد که به شما می‌گوید چگونه می‌توانید این رفتار را تغییر دهید:

```{r}
daily_flights <- daily |> 
  summarize(n = n())
```

### حذف گروه‌بندی

همچنین ممکن است بخواهید گروه‌بندی را از data frame بدون استفاده از `summarize()` حذف کنید.
می‌توانید این کار را با `ungroup()` انجام دهید.

```{r}
daily |> 
  ungroup()
```

حالا ببینیم وقتی یک data frame گروه‌بندی نشده را خلاصه می‌کنید چه اتفاقی می‌افتد.

```{r}
daily |> 
  ungroup() |>
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE), 
    flights = n()
  )
```

یک سطر واحد برمی‌گردانید چون dplyr همه سطرها در یک data frame گروه‌بندی نشده را متعلق به یک گروه در نظر می‌گیرد.

## مطالعه موردی: تجمیع‌ها و اندازه نمونه

هر وقت تجمیعی انجام می‌دهید، همیشه ایده خوبی است که شمارش (`n()`) شامل کنید.
بدین ترتیب، می‌توانید اطمینان حاصل کنید که نتیجه‌گیری بر اساس مقادیر بسیار کم داده نمی‌کنید.
این را با برخی داده‌های بیسبال از بسته **Lahman** نشان خواهیم داد.
به طور خاص، نسبت دفعاتی که بازیکن ضربه می‌زند (`H`) در مقابل تعداد دفعاتی که سعی می‌کند توپ را بازی کند (`AB`) را مقایسه خواهیم کرد:

```{r}
batters <- Lahman::Batting |> 
  group_by(playerID) |> 
  summarize(
    performance = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    n = sum(AB, na.rm = TRUE)
  )
batters
```

وقتی مهارت بازیکن (اندازه‌گیری شده با میانگین ضربه، `performance`) را در مقابل تعداد فرصت‌های ضربه زدن به توپ (اندازه‌گیری شده با times at bat، `n`) رسم می‌کنیم، دو الگو می‌بینید:

1. تنوع در `performance` در میان بازیکنانی با کمتر at-bat بیشتر است.
2. همبستگی مثبتی بین مهارت (`performance`) و فرصت‌های ضربه زدن به توپ (`n`) وجود دارد چون تیم‌ها می‌خواهند بهترین فرصت‌ها را به بهترین بازیکنانشان بدهند.

```{r}
#| warning: false
batters |> 
  filter(n > 100) |> 
  ggplot(aes(x = n, y = performance)) +
  geom_point(alpha = 1 / 10) + 
  geom_smooth(se = FALSE)
```

الگوی مفیدی برای ترکیب ggplot2 و dplyr توجه کنید.
فقط باید یادتان باشد از `|>` برای پردازش مجموعه داده به `+` برای اضافه کردن لایه‌ها به نمودارتان تغییر دهید.

## خلاصه

در این فصل، ابزارهایی که dplyr برای کار با data frame‌ها فراهم می‌کند را یاد گرفته‌اید.
ابزارها تقریباً در سه دسته گروه‌بندی شده‌اند: آنهایی که سطرها را دستکاری می‌کنند (مثل `filter()` و `arrange()`)، آنهایی که ستون‌ها را دستکاری می‌کنند (مثل `select()` و `mutate()`) و آنهایی که گروه‌ها را دستکاری می‌کنند (مثل `group_by()` و `summarize()`).
در این فصل، روی این ابزارهای "کل data frame" تمرکز کرده‌ایم، اما هنوز چیز زیادی درباره آنچه می‌توانید با متغیرهای فردی انجام دهید یاد نگرفته‌اید.
در بخش Transform کتاب، که هر فصل ابزارهایی برای نوع خاصی از متغیر فراهم می‌کند، به آن بازخواهیم گشت.

در فصل بعد، به گردش کار بازخواهیم گشت تا درباره اهمیت سبک کد و نگه داشتن کدتان در سازمان خوب برای آسان کردن خواندن و درک آن برای شما و دیگران بحث کنیم.
