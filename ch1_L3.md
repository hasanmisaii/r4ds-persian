# 3 تبدیل داده‌ها

## 1.3 مقدمه

تصویرسازی ابزار مهمی برای تولید بینش و دانش است، اما به ندرت داده‌ها را دقیقاً در شکل درستی که برای ساخت نمودار مورد نظرتان نیاز دارید، دریافت می‌کنید.
اغلب باید متغیرهای جدیدی ایجاد کنید یا خلاصه‌ سازی‌هایی برای پاسخ دادن به سؤال‌ها با داده‌ها تهیه کنید، یا شاید فقط بخواهید متغیرها را تغییر نام دهید یا مشاهدات را مرتب کنید تا کار با داده‌ها کمی آسان‌تر شود.
در این فصل یاد خواهید گرفت که چگونه همه اینها (و بیشتر!) را انجام دهید، به طوری که با تبدیل داده‌ها با استفاده از بسته **dplyr** و مجموعه داده جدیدی درباره پروازهای خروجی از شهر نیویورک در سال 2013 آشنا خواهید شد.

هدف این فصل ارائه نمای کلی از همه ابزارهای کلیدی برای تبدیل یک data frame است.
ابتدا با توابعی شروع خواهیم کرد که روی سطرها و سپس ستون‌های یک data frame عمل می‌کنند، سپس برمی‌گردیم تا درباره pipe، ابزار مهمی که برای ترکیب کردن توابع استفاده می‌شوند، بیشتر صحبت کنیم.
سپس قابلیت کار با گروه‌ها را معرفی خواهیم کرد.
فصل را با مطالعه موردی که کار با این توابع را در عمل نشان می‌دهد، به پایان خواهیم رساند.
در فصل‌های بعدی، با جزئیات بیشتری به این توابع بازخواهیم گشت به طوری که با آنها انواع خاصی از داده‌ها (مثل اعداد، رشته‌ها، تاریخ‌ها) را بررسی خواهیم کرد.

### 1.1.3 پیش‌نیازها

در این فصل، روی بسته dplyr، دییگر عضو اصلی tidyverse تمرکز خواهیم کرد.
ایده‌های کلیدی را با استفاده از داده‌هایی از بسته nycflights13 نشان خواهیم داد و از ggplot2 برای کمک به درک داده‌ها استفاده خواهیم کرد.

```{r}
library(nycflights13)
library(tidyverse)
#> ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──
#> ✔ dplyr     1.1.4     ✔ readr     2.1.5
#> ✔ forcats   1.0.0     ✔ stringr   1.5.1
#> ✔ ggplot2   3.5.2     ✔ tibble    3.3.0
#> ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
#> ✔ purrr     1.1.0     
#> ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──
#> ✖ dplyr::filter() masks stats::filter()
#> ✖ dplyr::lag()    masks stats::lag()
#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
```

به پیام مغایرت‌هایی که هنگام بارگذاری tidyverse چاپ می‌شود، دقت کنید.
این پیام به شما می‌گوید که dplyr برخی توابع در زبان پایه R را بازنویسی می‌کند.
اگر بخواهید پس از بارگذاری dplyr از نسخه پایه این توابع استفاده کنید، باید از نام کامل آنها استفاده کنید: `()filter::stats` و `()lag::stats`.
تا کنون، این که بسته‌ها شامل چه توابعی هستند را به دلیل کم اهمیت بودنشان نادیده گرفتیم.
با این حال، شناخت آن بسته می‌تواند به یافتن توابع مرتبط کمک کند، پس وقتی دقیقاً نیاز داریم تا بدانیم که یک تابع از کدام بسته می‌آید از دستور یکسان همانند R استفاده خواهیم کرد: `()functionname::packagename`.

### 2.1.3 بسته nycflights13

برای کاوش توابع اصلی dplyr، از `nycflights13::flights` استفاده خواهیم کرد.
این مجموعه داده شامل همه 336,776 پروازهایی است که در سال 2013 از شهر نیویورک حرکت کردند.
داده‌ها از [اداره آمار حمل‌ونقل آمریکا](https://www.transtats.bts.gov/DL_SelectFields.aspx?gnoyr_VQ=FGJ&QO_fu146_anzr=b0-gvzr) می‌آید و در `?flights` مستند شده است.

```{r}
flights
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

داده‌های `flights` یک tibble (ساختار جدید داده در R) است، نوع خاصی از data frame که توسط tidyverse استفاده می‌شود تا از برخی مشکلات رایج جلوگیری کند.
مهم‌ترین تفاوت بین tibble‌ها و data frame‌ها نحوه چاپ tibble‌هاست؛ آنها برای مجموعه داده‌های بزرگ طراحی شده‌اند، بنابراین فقط چند سطر اول و فقط ستون‌هایی که در یک صفحه جا می‌شوند را نشان می‌دهند.
چند گزینه برای دیدن همه مجموعه داده وجود دارد.
اگر از RStudio استفاده می‌کنید، احتمالاً راحت‌ترین روش `View(flights)` است که یک نمای تعاملی، با قابلیت پایین و بالا رفتن و قابلیت فیلترشدن را نمایش می‌دهد.
در غیر این صورت می‌توانید از `print(flights, width = Inf)` برای نشان دادن همه ستون‌ها استفاده کنید، یا از `glimpse()`:

```{r}
glimpse(flights)
#> Rows: 336,776
#> Columns: 19
#> $ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013…
#> $ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…
#> $ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…
#> $ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 55…
#> $ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 60…
#> $ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2,…
#> $ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 8…
#> $ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 8…
#> $ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7,…
#> $ carrier        <chr> "UA", "UA", "AA", "B6", "DL", "UA", "B6", "EV", "B6"…
#> $ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301…
#> $ tailnum        <chr> "N14228", "N24211", "N619AA", "N804JB", "N668DN", "N…
#> $ origin         <chr> "EWR", "LGA", "JFK", "JFK", "LGA", "EWR", "EWR", "LG…
#> $ dest           <chr> "IAH", "IAH", "MIA", "BQN", "ATL", "ORD", "FLL", "IA…
#> $ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149…
#> $ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 73…
#> $ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6…
#> $ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59…
#> $ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-0…
```

در هر دو نمایش، نام متغیرها با اختصاراتی دنبال می‌شوند که نوع هر متغیر را به شما می‌گویند: `<int>` نشان‌دهنده اعداد صحیح، `<dbl>` نشان‌دهنده اعداد حقیقی، `<chr>` برای کارکتر (یا رشته‌ها) و `<dttm>` نشان‌دهنده تاریخ-زمان است.
اینها مهم هستند چون عملیاتی که می‌توانید روی یک ستون انجام دهید به شدت به "نوع" آن بستگی دارد.

### 3.1.3 مبانی dplyr

شما در آغاز یادگیری فعل‌های (توابع) اصلی dplyr هستید که به شما امکان می‌دهد بخش عمده‌ای از چالش‌های دستکاری داده را حل کنید.
اما قبل از اینکه به تفاوت‌های منحصر به فرد آنها بپردازیم، بهتر است به وجوه مشترک آنها اشاره کنیم:
1. آرگومان اول همیشه یک data frame است.
2. آرگومان‌های بعدی معمولاً توصیف می‌کنند که با استفاده از نام متغیرها (بدون علامت نقل قول)، روی کدام ستون‌ها عمل کنند.
3. خروجی همیشه یک data frame جدید است.
 ‍‍
چون هر تابع یک کار را خوب انجام می‌دهد، حل مسائل پیچیده معمولاً نیاز به ترکیب چندین فعل دارد، و این کار را با pipe، `>|` انجام خواهیم داد. درباره pipe بیشتر در بخش بعد بحث خواهیم کرد، اما به طور خلاصه، pipe چیزی که در سمت چپش است را می‌گیرد و به تابع سمت راستش می‌دهد به طوری که `x |> f(y)` معادل `f(x, y)` است، و `x |> f(y) |> g(z)` معادل `g(f(x, y), z)` می‌باشد. ساده‌ترین مفهوم pipe "سپس" است. حتی اگر جزئیات زیادی از pipe یاد نگرفته باشید، قادر خواهید بود کد زیر را بفهمید.

```{r}
#| eval: false
flights |>
  filter(dest == "IAH") |> 
  group_by(year, month, day) |> 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )
```

توابع dplyr در چهار گروه بر اساس آنچه که روی آن عمل می‌کنند سازماندهی شده‌اند: **سطرها**، **ستون‌ها**، **گروه‌ها**، یا **جداول**. در بخش‌های زیر، مهم‌ترین توابع برای سطرها، ستون‌ها و گروه‌ها را یاد خواهید گرفت. سپس، به توابع join که روی جداول عمل می‌کنند بازخواهیم گشت. بیایید شروع کنیم!

## 2.3 سطرها

مهم‌ترین توابعی که روی سطرهای یک مجموعه داده عمل می‌کنند تابع `()filter` است که سطرهای موجود را بدون تغییر ترتیب آنها تغییر می‌دهد، و `()arrange` که ترتیب سطرها را بدون تغییر سطرهای موجود تغییر می‌دهد. هر دو تابع فقط روی سطرها تأثیر می‌گذارند و ستون‌ها دست‌نخورده باقی می‌مانند. همچنین درباره تابع `()distinct` که سطرهایی با مقادیر منحصر به فرد پیدا می‌کند، بحث خواهیم کرد. برخلاف توابع `()arrange` و `()filter` می‌تواند به صورت اختیاری ستون‌ها را نیز تغییر دهد.

### 1.2.3 تابع `()filter`

تابع `()filter` به شما اجازه می‌دهد سطرها را بر اساس مقادیر ستون‌ها انتخاب کنید. آرگومان اول یک data frame است.آرگومان دوم و بعدی شرط‌هایی هستند که برای انتخاب کردن سطر باید درست باشند.برای مثال، می‌توانیم همه پروازهایی که بیش از 120 دقیقه (دو ساعت) دیر حرکت کردند را پیدا کنیم:

```{r}
flights |> 
  filter(dep_delay > 120)
#> # A tibble: 9,723 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      848           1835       853     1001           1950
#> 2  2013     1     1      957            733       144     1056            853
#> 3  2013     1     1     1114            900       134     1447           1222
#> 4  2013     1     1     1540           1338       122     2020           1825
#> 5  2013     1     1     1815           1325       290     2120           1542
#> 6  2013     1     1     1842           1422       260     1958           1535
#> # ℹ 9,717 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```
`=!`
علاوه بر `<` (بزرگ‌تر از)، می‌توانید از `=<` (بزرگ‌تر یا مساوی)، `>` (کوچک‌تر از)، `=>` (کوچک‌تر یا مساوی)، `==` (مساوی)، و `=!` (نامساوی) استفاده کنید. همچنین می‌توانید شرط‌هایی را با `&` یا `,` برای نشان دادن "و" (بررسی هر دو شرط) یا با `|` برای نشان دادن "یا" (بررسی هر کدام از شرایط) ترکیب کنید:

```{r}
# پروازهایی که در 1 ژانویه حرکت کردند
flights |> 
  filter(month == 1 & day == 1)
#> # A tibble: 842 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 836 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …

# پروازهایی که در ژانویه یا فوریه حرکت کردند
flights |>
  filter(month == 1 | month == 2)
#> # A tibble: 51,955 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 51,949 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

میانبر مفیدی وجود دارد وقتی `|` و `==` را ترکیب می‌کنید: `%in%`. سطرهایی را انتخاب می‌کند که متغیر با یکی از مقادیر سمت راست برابر باشد:

```{r}
# راه کوتاه‌تر برای انتخاب پروازهایی که در ژانویه یا فوریه حرکت کردند
flights |> 
  filter(month %in% c(1, 2))
#> # A tibble: 51,955 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 51,949 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```
در فصل 12 با جزئیات بیشتر به این عملگرهای مقایسه‌ای و منطقی بازخواهیم گشت.

زمانی که تابع `filter()` را اجرا می‌کنید، dplyr عملیات فیلتر را اجرا می‌کند، data frame جدیدی ایجاد می‌کند و سپس آن را چاپ می‌کند. این تابع مجموعه داده موجود `flights` را تغییر نمی‌دهد چون توابع dplyr هرگز ورودی‌هایشان را تغییر نمی‌دهند.برای ذخیره نتیجه، باید از عملگر تخصیص `->` استفاده کنید:
 
```{r}
jan1 <- flights |> 
  filter(month == 1 & day == 1)
```

### 2.2.3 اشتباهات رایج

وقتی با R شروع می‌کنید، آسان‌ترین اشتباه استفاده از `=` به جای `==` هنگام انجام تساوی است. وقتی این اتفاق بیفتد، تابع `()filter` با یک خطا به شما اطلاع می‌دهد:
 
```{r}
flights |> 
  filter(month = 1)
#> Error in `filter()`:
#> ! We detected a named input.
#> ℹ This usually means that you've used `=` instead of `==`.
#> ℹ Did you mean `month == 1`?
```

اشتباه دیگر این است که عبارات "یا" را مثل دستور زبان انگلیسی بنویسید:

```{r}
flights |> 
  filter(month == 1 | 2)
```
این دستور اجرا می‌شود، به این معنا که خطایی ایجاد نمی‌کند اما کاری را که می خواهید انجام نمی‌دهد چون `|` ابتدا شرط `month == 1` را بررسی می‌کند و سپس شرط `2` را بررسی می‌کند که شرط منطقی برای بررسی نیست.

### 3.2.3 تابع `()arrange`

تابع `()arrange` ترتیب سطرها را بر اساس مقدار ستون‌ها تغییر می‌دهد. یک data frame و مجموعه‌ای از نام ستون‌ها (یا عبارات پیچیده‌تر) برای مرتب‌سازی می‌گیرد. اگر بیش از یک نام ستون ارائه دهید، هر ستون اضافی برای شکستن تساوی در مقادیر ستون‌های قبلی استفاده خواهد شد. برای مثال، کد زیر بر اساس زمان حرکت که در چهار ستون پخش شده‌اند، مجموعه داده را مرتب می‌کند. ابتدا زودترین سال‌ها، سپس در هر سال، زودترین ماه‌ها و غیره را دریافت می‌کنیم.

```{r}
flights |> 
  arrange(year, month, day, dep_time)
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

می‌توانید از `()desc` روی یک ستون درون `()arrange` استفاده کنید تا data frame را بر اساس آن ستون به ترتیب نزولی (بزرگ به کوچک) مرتب کنید. برای مثال، این کد پروازها را از بیشترین تا کمترین تأخیر مرتب می‌کند:

```{r}
flights |> 
  arrange(desc(dep_delay))
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     9      641            900      1301     1242           1530
#> 2  2013     6    15     1432           1935      1137     1607           2120
#> 3  2013     1    10     1121           1635      1126     1239           1810
#> 4  2013     9    20     1139           1845      1014     1457           2210
#> 5  2013     7    22      845           1600      1005     1044           1815
#> 6  2013     4    10     1100           1900       960     1342           2211
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

توجه کنید که تعداد سطرها تغییر نکرده است - ما فقط داده‌ها را مرتب می‌کنیم، آنها را فیلتر نمی‌کنیم.

### 4.2.3 تابع `()distinct`

تابع `()distinct` همه سطرهای منحصر به فرد در یک مجموعه داده را پیدا می‌کند، پس از نظر فنی، عمدتاً روی سطرها عمل می‌کند. با این حال، بیشتر اوقات، ترکیب متمایز برخی متغیرها را می‌خواهید، پس می‌توانید به صورت اختیاری نام ستون‌ها را نیز ارائه دهید:

```{r}
# حذف سطرهای تکراری، اگر وجود داشته باشند
flights |> 
  distinct()
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …

# پیدا کردن همه جفت‌های منحصر به فرد مبدأ و مقصد
flights |> 
  distinct(origin, dest)
#> # A tibble: 224 × 2
#>   origin dest 
#>   <chr>  <chr>
#> 1 EWR    IAH  
#> 2 LGA    IAH  
#> 3 JFK    MIA  
#> 4 JFK    BQN  
#> 5 LGA    ATL  
#> 6 EWR    ORD  
#> # ℹ 218 more rows
```
همچنین، اگر می‌خواهید هنگام فیلتر کردن برای سطرهای منحصر به فرد، ستون‌های دیگر را نگه دارید، می‌توانید از گزینه `keep_all = TRUE.` استفاده کنید.
 
```{r}
flights |> 
  distinct(origin, dest, .keep_all = TRUE)
#> # A tibble: 224 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 218 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

تصادفی نیست که همه این پروازهای متمایز در 1 ژانویه هستند: `()distinct` اولین رخداد یک سطر منحصر به فرد در مجموعه داده را پیدا می‌کند و بقیه را نادیده می‌گیرد. اگر می‌خواهید تعداد تکرارها را پیدا کنید، بهتر است `()distinct` را با `()count` جایگزین کنید. با آرگومان `sort = TRUE`، می‌توانید آنها را به ترتیب نزولی تعداد تکرارها مرتب کنید. در بخش ۱۳.۳ اطلاعات بیشتری در مورد شمارش یاد خواهید گرفت.

```{r}
flights |>
  count(origin, dest, sort = TRUE)
#> # A tibble: 224 × 3
#>   origin dest      n
#>   <chr>  <chr> <int>
#> 1 JFK    LAX   11262
#> 2 LGA    ATL   10263
#> 3 LGA    ORD    8857
#> 4 JFK    SFO    8204
#> 5 LGA    CLT    6168
#> 6 EWR    ORD    6100
#> # ℹ 218 more rows
```

### 5.2.3 تمرینات
1. در یک pipeline واحد برای هر شرط، همه پروازهایی که شرط زیر را برآورده می‌کنند پیدا کنید:
   - تأخیر ورود دو ساعت یا بیشتر داشتند
   - به هیوستون پرواز کردند (`IAH` یا `HOU`)
   - توسط United، American، یا Delta اداره می‌شدند
   - در تابستان پرواز کردند (ژوئیه، آگوست، و سپتامبر)
   - بیش از دو ساعت دیر رسیدند اما دیر حرکت نکردند
   - حداقل یک ساعت تأخیر داشتند، اما بیش از 30 دقیقه در پرواز جبران کردند
2. مجموعه داده `flights` را مرتب کنید تا پروازهایی با طولانی‌ترین تأخیر در حرکت را پیدا کنید. پروازهایی که صبح زودتر از همه حرکت کردند را پیدا کنید.
3. مجموعه داده `flights` را مرتب کنید تا سریع‌ترین پروازها را پیدا کنید (راهنمایی: سعی کنید یک محاسبه ریاضی را درون تابع خود بگنجانید.)
4. آیا در هر روز از سال 2013 پروازی بود؟
5. کدام پروازها بیشترین فاصله را طی کردند؟ کدام‌ها کمترین فاصله را طی کردند؟
6.  آیا ترتیب استفاده از `()filter` و `()arrange` اگر از هر دو استفاده می‌کنید مهم است؟ چرا/چرا نه؟ به نتایج و میزان کاری که توابع باید انجام دهند فکر کنید. 


## 3.3 ستون‌ها

چهار تابع مهم وجود دارد که بدون تغییر سطرها روی ستون‌ها تأثیر می‌گذارند: `()mutate` ستون‌های جدیدی که از ستون‌های موجود مشتق شده‌اند ایجاد می‌کند، `()select` محجموعه داده‌ای جدید با ستون‌هایی که موجود هستند ایجاد می‌کند، `()rename` نام ستون‌ها را تغییر می‌دهد، و `()relocate` موقعیت ستون‌ها را تغییر می‌دهد.

### 1.3.3 تابع `()mutate`
وظیفه `mutate()` اضافه کردن ستون‌های جدیدی است که از ستون‌های موجود محاسبه می‌شوند. در فصل‌های تبدیل، مجموعه بزرگی از توابع که می‌توانید برای دستکاری انواع مختلف متغیرها استفاده کنید یاد خواهید گرفت.
فعلاً، با جبر پایه که به ما اجازه محاسبه `gain`، میزان زمانی که پرواز تأخیردار در پرواز خود در مسیر هوایی جبران کرد، و `speed` سرعت پرواز بر حسب مایل در ساعت می‌دهد، بسنده می‌کنیم:

```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60
  )
#> # A tibble: 336,776 × 21
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 13 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

به طور پیش‌فرض، `()mutate` ستون‌های جدید را در سمت راست مجموعه داده‌تان اضافه می‌کند به طوری که مشاهده آنچه در مجموعه داده اتفاق افتاده است را دشوار می‌کند. می‌توانیم از آرگومان `before.` استفاده کنیم تا متغیرها را به سمت چپ اضافه کنیم:

```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .before = 1
  )
#> # A tibble: 336,776 × 21
#>    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time
#>   <dbl> <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>
#> 1    -9  370.  2013     1     1      517            515         2      830
#> 2   -16  374.  2013     1     1      533            529         4      850
#> 3   -31  408.  2013     1     1      542            540         2      923
#> 4    17  517.  2013     1     1      544            545        -1     1004
#> 5    19  394.  2013     1     1      554            600        -6      812
#> 6   -16  288.  2013     1     1      554            558        -4      740
#> # ℹ 336,770 more rows
#> # ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, …
```

`.` نشان می‌دهد که `before.` آرگومان تابع است، نه نام متغیر سومی که در حال ایجاد آن هستیم. همچنین می‌توانید از `after.` برای اضافه کردن بعد از یک متغیر استفاده کنید، و در هر دو آرگومان `before.` و `after.` می‌توانید از نام متغیر به جای موقعیت استفاده کنید. برای مثال، می‌توانیم متغیرهای جدید را بعد از `day` اضافه کنیم:

```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .after = day
  )
```

همچنین، می‌توانید با آرگومان `keep.` کنترل کنید کدام متغیرها نگه داشته شوند. آرگومان بسیار مفید `"used"` است که مشخص می‌کند فقط ستون‌هایی را نگه داریم که در مرحله `mutate()` دخیل بوده‌اند یا ایجاد شده‌اند. برای مثال، خروجی زیر فقط شامل متغیرهای `dep_delay`، `arr_delay`، `air_time`، `gain`، `hours`، و `gain_per_hour` خواهد بود.

```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )
```
توجه داشته باشید چون محاسبات بالا را به مجموعه داده ‍‍`flights` با عملگر تخصیص نسبت نداده‌ایم، متغیرهای جدید `gain‍`،
`hours`،
و `gain_per_hour` تنها به عنوان خروجی نمایش داده خواهد شد و به عنوان یک data frame ذخیره نخواهد شد. اگر بخواهیم محاسبات فوق برای استفاده‌های بعدی در یک data frame در دسترس باشند، باید با دقت در مورد اینکه آیا می‌خواهیم نتیجه به `flights` اختصاص داده شود، مجموعه داده اصلی را با متغیرهای بسیار بیشتری بازنویسی کنیم، یا به یک شیء جدید اختصاص دهیم، فکر کنیم. اغلب، پاسخ درست ساخت یک شئ جدید است که به درستی برای نمایش محتویات خود برای مثال `delay_gain` نام‌گذاری شده است، اما ممکن است دلایل خوبی برای بازنویسی داده اولیه یعنی `flights` داشته باشید.

### 2.3.3 تابع `()select`

غیرمعمول نیست که مجموعه داده‌هایی با صدها یا حتی هزاران متغیر دریافت کنید. در این شرایط، اولین چالش اغلب تمرکز روی متغیرهایی است که به آنها علاقمند هستید. تابع `()select` به شما اجازه می‌دهد با استفاده از عملیاتی بر اساس نام متغیرها به سرعت روی زیرمجموعه مفیدی تمرکز کنید:
- انتخاب ستون‌ها با نام:
  ```{r}
  flights |> 
    select(year, month, day)
  ```
- انتخاب همه ستون‌ها بین year و day (شامل):
  ```{r}
  flights |> 
    select(year:day)
  ```
- انتخاب همه ستون‌ها به جز ستون‌های از year تا day (شامل):
  ```{r}
  flights |> 
    select(!year:day)
  ```
   از لحاظ تاریخی این عملیات با `-` به جای `!` انجام می‌شد، بنابراین احتمالاً آن را در دیگر زبان‌های برنامه‌نویسی خواهید دید. این دو عملگر با تفاوت‌های جزئی در عملکردشان، کار یکسانی را انجام می‌دهند. توصیه ما استفاده از عملگر `!` است به این دلیل که به عنوان «نباشد» تفسیر می‌شود و به خوبی با عملگرهای `&` و `|` ترکیب می‌شود.
- انتخاب همه ستون‌هایی که کاراکتر هستند:
  ```{r}
  flights |> 
    select(where(is.character))
  ```

تعدادی تابع کمکی وجود دارد که می‌توانید درون `()select` استفاده کنید:
- دستور `starts_with("abc")`: با نام‌هایی که با "abc" شروع می‌شوند، مطابقت دارد.
- دستور `ends_with("xyz")`: با نام‌هایی که با "xyz" تمام می‌شوند، مطابقت دارد.
- دستور `contains("ijk")`: با نام‌هایی که شامل "ijk" هستند، مطابقت دارد.
- دستور `num_range("x", 1:3)`: با  `x2`، `x1` و `x3` مطابقت دارد.

برای جزئیات بیشتر دستور `select?` را اجرا کنید. وقتی عبارات باقاعده (موضوع فصل ۱۵) را یاد بگیرید، می‌توانید از `()matches` برای انتخاب متغیرهایی که با یک الگو مطابقت دارند نیز استفاده کنید.

می‌توانید هنگام `select()` کردن متغیرها آنها را با استفاده از `=` تغییر نام دهید. نام جدید در سمت چپ `=` و متغیر قدیمی در سمت راست آن ظاهر می‌شود:

```{r}
flights |> 
  select(tail_num = tailnum)
#> # A tibble: 336,776 × 1
#>   tail_num
#>   <chr>   
#> 1 N14228  
#> 2 N24211  
#> 3 N619AA  
#> 4 N804JB  
#> 5 N668DN  
#> 6 N39463  
#> # ℹ 336,770 more rows
```

### 3.3.3 تابع `()rename`

اگر می‌خواهید همه متغیرهای موجود را نگه دارید و فقط چندتایی را تغییر نام دهید، می‌توانید به جای `()select` از `()rename` استفاده کنید:
```{r}
flights |> 
  rename(tail_num = tailnum)
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```
اگر تعداد زیادی ستون با نام‌های نامتناسب دارید و اصلاح دستی همه آنها دشوار است، از `()janitor::clean_names` استفاده کنید که پاکسازی خودکار مفیدی را ارائه می‌دهد.

### 4.3.3 تابع `()relocate`

از `()relocate` برای جابجایی متغیرها استفاده کنید. ممکن است بخواهید متغیرهای مرتبط را کنار هم جمع کنید یا متغیرهای مهم را به ابتدا بیاورید. به طور پیش‌فرض `()relocate` متغیرها را به ابتدای مجموعه داده می‌آورد:
```{r}
flights |> 
  relocate(time_hour, air_time)
#> # A tibble: 336,776 × 19
#>   time_hour           air_time  year month   day dep_time sched_dep_time
#>   <dttm>                 <dbl> <int> <int> <int>    <int>          <int>
#> 1 2013-01-01 05:00:00      227  2013     1     1      517            515
#> 2 2013-01-01 05:00:00      227  2013     1     1      533            529
#> 3 2013-01-01 05:00:00      160  2013     1     1      542            540
#> 4 2013-01-01 05:00:00      183  2013     1     1      544            545
#> 5 2013-01-01 06:00:00      116  2013     1     1      554            600
#> 6 2013-01-01 05:00:00      150  2013     1     1      554            558
#> # ℹ 336,770 more rows
#> # ℹ 12 more variables: dep_delay <dbl>, arr_time <int>, …
```

همچنین می‌توانید با استفاده از آرگومان‌های `before.` و `after.`، درست مثل `()mutate`، مشخص کنید متغیرها را کجا قرار دهید:
```{r}
flights |> 
  relocate(year:dep_time, .after = time_hour)
flights |> 
  relocate(starts_with("arr"), .before = dep_time)
```

### تمرینات
1. ستون‌های `dep_time`، `sched_dep_time`، و `dep_delay` را مقایسه کنید. انتظار دارید این سه عدد چگونه مرتبط باشند؟
2. تا جای ممکن راه‌های زیادی برای انتخاب `dep_time`، `dep_delay`، `arr_time`، و `arr_delay` از `flights` پیدا کنید.
3. اگر نام یک متغیر را چندین بار در یک فراخوانی `()select` مشخص کنید چه اتفاقی می‌افتد؟
4. تابع `()any_of` چه کاری انجام می‌دهد؟ چرا می‌تواند در رابطه با بردار زیر مفید باشد؟
   ```{r}
   variables <- c("year", "month", "day", "dep_delay", "arr_delay")
   ```
5. آیا نتیجه اجرای کد زیر شما را متعجب می‌کند؟ توابع کمکی select به طور پیش‌فرض چگونه با حروف بزرگ و کوچک رفتار می‌کنند؟ چگونه می‌توانید این پیش‌فرض را تغییر دهید؟
   ```{r}
   flights |> select(contains("TIME"))
   ```
6. برای نمایش واحد اندازه‌گیری، متغیر `air_time` را به ‍‍‍`air_time_min`  تغییر نام دهید و آن را به ابتدای data frame منتقل کنید.
7. چرا کد زیر کار نمی‌کند و معنی خطا چیست؟
   ```{r}
   flights |> 
   select(tailnum) |> 
   arrange(arr_delay)
   #> Error in `arrange()`:
   #> ℹ In argument: `..1 = arr_delay`.
   #> Caused by error:
   #> ! object 'arr_delay' not found
   ```

## 4.3 عملیات pipe

نمونه‌های ساده pipe را در بالا نشان داده‌ایم، اما قدرت واقعی آن زمانی ظاهر می‌شود که شروع به ترکیب چندین تابع می‌کنید.برای مثال، تصور کنید می‌خواهید سریع‌ترین پروازها به فرودگاه IAH هیوستون را پیدا کنید: باید `filter()`، `mutate()`، `select()`، و `arrange()` را ترکیب کنید:

```{r}
flights |> 
  filter(dest == "IAH") |> 
  mutate(speed = distance / air_time * 60) |> 
  select(year:day, dep_time, carrier, flight, speed) |> 
  arrange(desc(speed))
#> # A tibble: 7,198 × 7
#>    year month   day dep_time carrier flight speed
#>   <int> <int> <int>    <int> <chr>    <int> <dbl>
#> 1  2013     7     9      707 UA         226  522.
#> 2  2013     8    27     1850 UA        1128  521.
#> 3  2013     8    28      902 UA        1711  519.
#> 4  2013     8    28     2122 UA        1022  519.
#> 5  2013     6    11     1628 UA        1178  515.
#> 6  2013     8    27     1017 UA         333  515.
#> # ℹ 7,192 more rows
```

اگرچه این pipeline چهار مرحله دارد، خواندن آن آسان است چون توابع در ابتدای هر خط می‌آیند: با داده `flights` شروع کنید، سپس filter، سپس mutate، سپس select، در نهایت arrange.

اگر pipe را نداشتیم چه اتفاقی می‌افتاد؟ می‌توانستیم هر فراخوانی تابع را درون فراخوانی قبلی قرار (تودرتو) دهیم:


```{r}
arrange(
  select(
    mutate(
      filter(
        flights, 
        dest == "IAH"
      ),
      speed = distance / air_time * 60
    ),
    year:day, dep_time, carrier, flight, speed
  ),
  desc(speed)
)
```

یا می‌توانستیم از مجموعه‌ای از شئ‌های واسطه استفاده کنیم:

```{r}
flights1 <- filter(flights, dest == "IAH")
flights2 <- mutate(flights1, speed = distance / air_time * 60)
flights3 <- select(flights2, year:day, dep_time, carrier, flight, speed)
arrange(flights3, desc(speed))
```

در حالی که هر دو شکل کد، زمان اجرا و فضای خودشان را دارند، pipe عموماً کد تحلیل داده‌ای تولید می‌کند که نوشتن و خواندن آن آسان‌تر است.

برای افزودن pipe به کد خود، توصیه می‌کینم از کلیدهای میانبر  Ctrl/Cmd + Shift + M تعبیه‌شده در RStudio استفاده کنید. همان طور که در شکل زیر نشان داده شده است، شکل 1.3،  برای استفاده از `<|` به جای `%<%` نیاز دارید تا یک تغییر در تنظیمات RStudio انجام دهید.
> بسته ‍‍magrittr
> 
> اگر مدت زمانی از tidyverse استفاده کرده باشید، ممکن است با عملگر pipe `%<%` ارائه‌شده توسط بسته **magrittr** آشنا باشید. بسته magrittr در هسته tidyverse گنجانده شده است، بنابراین می‌توانید هر زمان که tidyverse را بارگذاری می‌کنید از `%<%` استفاده کنید:
> ```{r}
> library(tidyverse)
>
> mtcars %>% 
>  group_by(cyl) %>%
>  summarize(n = n())
> ```
> برای موارد ساده، عملگرهای `<|` و `%<%` رفتار یکسانی دارند. پس چرا عملگر پایه pipe را توصیه می‌کنیم؟ نخست، چون بخشی از زبان پایه R است، همیشه برای استفاده شما در دسترس است، حتی زمانی که از tidyverse استفاده نمی‌کنید. دوم، `<|` کاملاً ساده‌تر از `%<%` است. در فاصله زمانی بین به وجود آمدن `%<%` در سال ۲۰۱۴ و گنجاندن `<|` در R 4.1.0 در سال ۲۰۲۱، ما درک بهتری از مفهوم pipe به دست آوردیم. این امر باعث شد که پیاده‌سازی پایه، ویژگی‌های کم‌اهمیت‌تر و کم‌استفاده‌تر را کنار بگذارد.

## 5.3 گروه‌ها

تا کنون درباره توابعی که با سطرها و ستون‌ها کار می‌کنند یاد گرفته‌اید. وقتی قابلیت کار با گروه‌ها را هم اضافه کنید، dplyr حتی قدرتمندتر هم می‌شود. در این بخش، روی مهم‌ترین توابع تمرکز خواهیم کرد: `group_by()`، `summarize()`، و خانواده توابع slice.

### 1.5.3 تابع `()group_by`

از `()group_by` برای تقسیم مجموعه داده خود به گروه‌های معنادار برای تحلیل خود استفاده کنید:

```{r}
flights |> 
  group_by(month)
#> # A tibble: 336,776 × 19
#> # Groups:   month [12]
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

تابع `()group_by` داده را تغییر نمی‌دهد اما اگر دقیق به خروجی نگاه کنید، متوجه خواهید شد که نشان می‌دهد مجموعه داده بر اساس ماه گروه‌بندی شده است (`Groups: month [12]`). این بدان معناست که عملیات بعدی حالا «بر اساس ماه» کار خواهند کرد. `()group_by` این ویژگی گروه‌بندی (که به عنوان رده شناخته می‌شود) را به data frame اضافه می‌کند که رفتار توابع بعدی اعمال‌شده روی داده را تغییر می‌دهد.

### 2.5.3 تابع `()summarize`

مهم‌ترین عملیات گروه‌بندی خلاصه‌سازی است که اگر برای محاسبه یک آماره خلاصه استفاده شود، data frame را به یک سطر واحد برای هر گروه کاهش می‌دهد. در dplyr، این عملیات توسط `()summarize` انجام می‌شود، همانند مثال زیر که میانگین تأخیر حرکت پروازها را بر حسب ماه محاسبه می‌کند:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay)
  )
#> # A tibble: 12 × 2
#>   month avg_delay
#>   <int>     <dbl>
#> 1     1        NA
#> 2     2        NA
#> 3     3        NA
#> 4     4        NA
#> 5     5        NA
#> 6     6        NA
#> # ℹ 6 more rows
```

اوه! مشکلی پیش آمده است و همه نتایج `NA` (تلفظ می‌شود "N-A") هستند، که نماد R برای مقدار گمشده است. این اتفاق افتاد چون برخی از پروازهای مشاهده‌شده در ستون تأخیر، داده گمشده‌‌ای داشتند و بنابراین وقتی میانگین شامل آن مقادیر را محاسبه کردیم، نتیجه `NA` گرفتیم. در فصل ۱۸ به تفصیل در مورد مقادیر گمشده بحث خواهیم کرد، اما فعلاً با تنظیم آرگومان `na.rm` روی `TRUE` به تابع `()mean` می‌گوییم همه مقادیر گمشده را نادیده بگیرد:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE)
  )
#> # A tibble: 12 × 2
#>   month avg_delay
#>   <int>     <dbl>
#> 1     1      10.0
#> 2     2      10.8
#> 3     3      13.2
#> 4     4      13.9
#> 5     5      13.0
#> 6     6      20.8
#> # ℹ 6 more rows
```

می‌توانید تعداد دلخواهی خلاصه در یک فراخوانی `()summarize` ایجاد کنید. در فصل‌های آینده خلاصه‌های مختلف مفید یاد خواهید گرفت، اما یک خلاصه بسیار مفید `()n` است که تعداد سطرها در هر گروه را برمی‌گرداند:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE), 
    n = n()
  )
#> # A tibble: 12 × 3
#>   month avg_delay     n
#>   <int>     <dbl> <int>
#> 1     1      10.0 27004
#> 2     2      10.8 24951
#> 3     3      13.2 28834
#> 4     4      13.9 28330
#> 5     5      13.0 28796
#> 6     6      20.8 28243
#> # ℹ 6 more rows
```

میانگین‌ها و شمارش‌ها می‌توانند شما را در علم داده به طرز شگفت‌آوری پیش ببرند!

### 3.5.3 توابع `_slice`

پنج تابع مفید وجود دارد که به شما اجازه استخراج سطرهای خاص درون هر گروه را می‌دهند:

- دستور `df |> slice_head(n = 1)` اولین سطر از هر گروه را برمی‌دارد.
- دستور `df |> slice_tail(n = 1)` آخرین سطر در هر گروه را برمی‌دارد.
- دستور `df |> slice_min(x, n = 1)` سطر با کوچک‌ترین مقدار ستون `x` را برمی‌دارد.
- دستور `df |> slice_max(x, n = 1)` سطر با بزرگ‌ترین مقدار ستون `x` را برمی‌دارد.
- دستور `df |> slice_sample(n = 1)` یک سطر تصادفی برمی‌دارد.

می‌توانید `n` را تغییر دهید تا بیش از یک سطر انتخاب کنید، یا به جای `= n`، می‌توانید از `prop = 0.1` استفاده کنید تا (مثلاً) 10 درصد سطرها در هر گروه را انتخاب کنید. برای مثال، کد زیر پروازهایی که بیشترین تأخیر ورود در هر مقصد دارند را پیدا می‌کند:

```{r}
flights |> 
  group_by(dest) |> 
  slice_max(arr_delay, n = 1) |>
  relocate(dest)
#> # A tibble: 108 × 19
#> # Groups:   dest [105]
#>   dest   year month   day dep_time sched_dep_time dep_delay arr_time
#>   <chr> <int> <int> <int>    <int>          <int>     <dbl>    <int>
#> 1 ABQ    2013     7    22     2145           2007        98      132
#> 2 ACK    2013     7    23     1139            800       219     1250
#> 3 ALB    2013     1    25      123           2000       323      229
#> 4 ANC    2013     8    17     1740           1625        75     2042
#> 5 ATL    2013     7    22     2257            759       898      121
#> 6 AUS    2013     7    10     2056           1505       351     2347
#> # ℹ 102 more rows
#> # ℹ 11 more variables: sched_arr_time <int>, arr_delay <dbl>, …
```

توجه کنید که 105 مقصد وجود دارد اما در اینجا 108 سطر نمایش داده شده است. چه اتفاقی افتاده است؟ توابع `()slice_min` و `()slice_max` مقادیر وابسته را حفظ می‌کنند، بنابراین `1 = n` به این معنی است که همه ردیف‌هایی را که بالاترین مقدار را دارند به ما می‌دهد. اگر دقیقاً یک سطر در هر گروه می‌خواهید می‌توانید `with_ties = FALSE` تنظیم کنید.


### 4.5.3 گروه‌بندی بر اساس چندین متغیر

می‌توانید با استفاده از بیش از یک متغیر گروه ایجاد کنید. برای مثال، می‌توانیم برای هر تاریخ یک گروه بسازیم.


```{r}
daily <- flights |>  
  group_by(year, month, day)
daily
#> # A tibble: 336,776 × 19
#> # Groups:   year, month, day [365]
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

وقتی tibble گروه‌بندی شده با بیش از یک متغیر را خلاصه می‌کنید، هر خلاصه آخرین گروه را حذف می‌کند. در نگاه به گذشته، این روش خوبی برای به کار انداختن این تابع نبود، اما تغییر آن بدون شکستن کد موجود دشوار است. برای این که مشخص چه اتفاق می‌افتد، dplyr پیامی نمایش می‌دهد که به شما می‌گوید چگونه می‌توانید این رفتار را تغییر دهید:

```{r}
daily_flights <- daily |> 
  summarize(n = n())
#> `summarise()` has grouped output by 'year', 'month'. You can override using
#> the `.groups` argument.
```
اگر رفتار خروجی تابع راضی‌کننده است، می‌توانید عدم چاپ پیام را در تابع مشخص کنید:
```{r}
daily_flights <- daily |> 
  summarize(
    n = n(), 
    .groups = "drop_last"
  )
```
روش دیگر، تغییر رفتار پیش‌فرض تابع با تنظیم یک مقدار متفاوت است، برای مثال، می‌توانید از `"drop"` برای حذف همه گروه‌بندی و از `"keep"` برای حفظ همان گروه‌ها استفاده کنید.

### 5.5.3 حذف گروه‌بندی

همچنین ممکن است بخواهید گروه‌بندی را از data frame بدون استفاده از `()summarize` حذف کنید. می‌توانید این کار را با `()ungroup` انجام دهید.

```{r}
daily |> 
  ungroup()
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```

حالا ببینیم وقتی یک data frame گروه‌بندی‌نشده را خلاصه می‌کنید چه اتفاقی می‌افتد.

```{r}
daily |> 
daily |> 
  ungroup() |>
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE), 
    flights = n()
  )
#> # A tibble: 1 × 2
#>   avg_delay flights
#>       <dbl>   <int>
#> 1      12.6  336776
```

یک سطر واحد برمی‌گردانید چون dplyr همه سطرها در یک data frame گروه‌بندی‌نشده را متعلق به یک گروه در نظر می‌گیرد.

### 6.5.3 آرگومان `by.`
بسته dplyr 1.1.0 شامل یک دستور جدید و آزمایشی برای گروه‌بندی هر عملیات، یعنی آرگومان `by.` است. توابع `()group_by` و `()ungroup` حذف نمی‌شوند، اما اکنون می‌توانید از آرگومان `by.` برای گروه‌بندی درون یک عملیات واحد نیز استفاده کنید:

```{r}
flights |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    n = n(),
    .by = month
  )
```


یا اگر می‌خواهید بر اساس چندین متغیر گروه‌بندی کنید:
```{r}
flights |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    n = n(),
    .by = c(origin, dest)
  )
```

آرگومان `by.` با همه توابع کار می‌کند و این مزیت را دارد که نیازی به استفاده از آرگومان `groups.` برای سرکوب پیام گروه‌بندی یا `()ungroup` پس از اتمام کار ندارید. ما در این فصل روی این آرگومان تمرکز نکردیم، زیرا آن هنگام نوشتن کتاب بسیار جدید بود. می‌خواستیم به آن اشاره کنیم چون فکر می‌کنیم پتانسیل زیادی دارد و احتمالاً بسیار محبوب خواهد شد. می‌توانید در پست وبلاگ dplyr 1.1.0 درباره آن بیشتر بدانید.

### 7.5.3 تمرین‌ها
1. کدام شرکت هواپیمایی بدترین میانگین تأخیر را دارد؟ چالش: آیا می‌توانید اثرات فرودگاه‌های بد را از اثرات شرکت‌های هواپیمایی بد جدا کنید؟ چرا/چرا نه؟ (راهنمایی: به دستور `flights |> group_by(carrier, dest) |> summarize(n())` نگاه کنید)
2. پروازهایی را که بیشترین تأخیر را هنگام پرواز از هر مقصد دارند، پیدا کنید.
3. تأخیرها در طول روز چگونه تغییر می‌کنند؟ پاسخ خود را با یک نمودار نشان دهید.
4. اگر به `()slice_min` و توابع مرتبط یک n منفی بدهید، چه اتفاقی می‌افتد؟
5. بر اساس توابع dplyr که تازه یاد گرفته‌اید، توضیح دهید که تابع `()count` چه کاری انجام می‌دهد. همین طور، شرح دهید که آرگومان `sort` در تابع `()count` چه چیزی انجام می‌دهد.
6. فرض کنید ما یک data frame کوچک به صورت زیر داریم:
  الف. چیزی را که فکر می‌کنید خروجی دستور زیر باشد، بنویسید و سپس بررسی کنید که آیا درست حدس زده بودید، و همچنین کاری را که تابع `()group_by` انجام می‌دهد نیز توضیح دهید.
 ```{r}
 df |>
   group_by(y)
 ```
  ب. چیزی را که فکر می‌کنید خروجی دستور زیر باشد، بنویسید و سپس بررسی کنید که آیا درست حدس زده بودید، و همچنین کاری را که تابع `()arrange` انجام می‌دهد نیز توضیح دهید. همچنین، در مورد تفاوت آن با تابع `()group_by` در بخش (الف) توضیح دهید.
 ```{r}
 df |>
   arrange(y)
 ```
  ج. چیزی را که فکر می‌کنید خروجی دستور زیر باشد، بنویسید و سپس بررسی کنید که آیا درست حدس زده بودید، و کاری که pipeline انجام می‌دهد را نیز توصیف کنید.
 ```{r}
 df |>
   group_by(y) |>
   summarize(mean_x = mean(x))
 ```
  د. چیزی را که فکر می‌کنید خروجی دستور زیر باشد، بنویسید و سپس بررسی کنید که آیا درست حدس زده بودید، و کاری که pipeline انجام می‌دهد را نیز توصیف کنید. سپس، در مورد آنچه در پیام آمده است، نظر دهید.
 ```{r}
 df |>
   group_by(y, z) |>
   summarize(mean_x = mean(x))
 ```
  ه. چیزی را که فکر می‌کنید خروجی دستور زیر باشد، بنویسید و سپس بررسی کنید که آیا درست حدس زده بودید، و کاری که pipeline انجام می‌دهد را نیز توصیف کنید. خروجی چه تفاوتی با خروجی بخش (د) دارد؟
 ```{r}
 df |>
   group_by(y, z) |>
   summarize(mean_x = mean(x), .groups = "drop")
 ```
  و. چیزی را که فکر می‌کنید خروجی دستور زیر باشد، بنویسید و سپس بررسی کنید که آیا درست حدس زده بودید، و کاری که pipeline انجام می‌دهد را نیز توصیف کنید. خروجی‌های این دو pipeline چه تفاوتی با هم دارند؟
 ```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))

df |>
  group_by(y, z) |>
  mutate(mean_x = mean(x))
 ```
 
## 6.3 مطالعه موردی: تجمیع‌ها و اندازه نمونه
هر وقت تجمیعی انجام می‌دهید، همیشه ایده خوبی است که شمارش (`()n`) را نیز به آن اضافه کنید. بدین ترتیب، می‌توانید اطمینان حاصل کنید که نتیجه‌گیری بر اساس مقادیر بسیار کم داده نیست. این را با برخی داده‌های بیسبال از بسته **Lahman** نشان خواهیم داد. به طور خاص، نسبت دفعاتی که بازیکن ضربه می‌زند (`H`) در مقابل تعداد دفعاتی که سعی می‌کند توپ را بازی کند (`AB`) را مقایسه خواهیم کرد:


```{r}
batters <- Lahman::Batting |> 
  group_by(playerID) |> 
  summarize(
    performance = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    n = sum(AB, na.rm = TRUE)
  )
batters
#> # A tibble: 20,730 × 3
#>   playerID  performance     n
#>   <chr>           <dbl> <int>
#> 1 aardsda01      0          4
#> 2 aaronha01      0.305  12364
#> 3 aaronto01      0.229    944
#> 4 aasedo01       0          5
#> 5 abadan01       0.0952    21
#> 6 abadfe01       0.111      9
#> # ℹ 20,724 more rows
```

وقتی مهارت بازیکن (اندازه‌گیری شده با میانگین ضربه، `performance`) را در مقابل تعداد فرصت‌های ضربه زدن به توپ (اندازه‌گیری شده با تعداد دفعات ضربه زدن، `n`) رسم می‌کنیم، دو الگو می‌بینید:

1. تغییرپذیری در `performance` در بین بازیکنانی که تعداد ضربه‌های کمتری دارند، بیشتر است. شکل این نمودار بسیار مشخص است: هر زمان که میانگین (یا سایر آمارهای خلاصه) را در مقابل اندازه گروه رسم می‌کنید، خواهید دید که با افزایش اندازه نمونه، تغییرپذیری کاهش می‌یابد.
2. همبستگی مثبتی بین مهارت (`performance`) و فرصت‌های ضربه زدن به توپ (`n`) وجود دارد چون تیم‌ها می‌خواهند بهترین فرصت‌های ضربه زدن به توپ را به بهترین بازیکنانشان بدهند.

```{r}
batters |> 
  filter(n > 100) |> 
  ggplot(aes(x = n, y = performance)) +
  geom_point(alpha = 1 / 10) + 
  geom_smooth(se = FALSE)
```
![Alt text](Images/unnamed-chunk-56-1)


به الگوی مفید ترکیب ggplot2 و dplyr توجه کنید. فقط باید یادتان باشد از `<|` برای پردازش مجموعه داده به `+` برای اضافه کردن لایه‌ها به نمودارتان تغییر دهید.

این موضوع همچنین معانی مهمی برای رتبه‌بندی دارد. اگر به طور ساده بر اساس `desc(performance)` مرتب‌سازی کنید، افرادی که بهترین میانگین ضربه زدن را دارند به وضوح کسانی هستند که دفعات بسیار کمی سعی کرده‌اند توپ را در بازی قرار دهند و اتفاقاً ضربه‌ای هم دریافت کرده‌اند، آنها لزوماً ماهرترین بازیکنان نیستند:
```{r}
batters |> 
  arrange(desc(performance))
#> # A tibble: 20,730 × 3
#>   playerID  performance     n
#>   <chr>           <dbl> <int>
#> 1 abramge01           1     1
#> 2 alberan01           1     1
#> 3 banisje01           1     1
#> 4 bartocl01           1     1
#> 5 bassdo01            1     1
#> 6 birasst01           1     2
#> # ℹ 20,724 more rows
```
می‌توانید توضیح خوبی در مورد این مشکل و نحوه برطرف کردن آن در [http://varianceexplained.org/r/empirical_bayes_baseball/](http://varianceexplained.org/r/empirical_bayes_baseball/) و [https://www.evanmiller.org/how-not-to-sort-by-average-rating.html](https://www.evanmiller.org/how-not-to-sort-by-average-rating.html) پیدا کنید.

## خلاصه

در این فصل، ابزارهایی که dplyr برای کار با data frame‌ها فراهم می‌کند را یاد گرفته‌اید. ابزارها تقریباً در سه دسته گروه‌بندی شده‌اند: آنهایی که سطرها را دستکاری می‌کنند (مثل `()filter` و `()arrange`)، آنهایی که ستون‌ها را دستکاری می‌کنند (مثل `()select` و `()mutate`) و آنهایی که گروه‌ها را دستکاری می‌کنند (مثل `()group_by` و `()summarize`). در این فصل، بر روی ابزارهایی همانند "کل data frame" تمرکز کرده‌ایم، اما هنوز چیز زیادی درباره آنچه می‌توانید با متغیرهای فردی انجام دهید یاد نگرفته‌اید. در بخش «تبدیل» کتاب، که هر فصل ابزارهایی برای نوع خاصی از متغیر فراهم می‌کند، به آن بازخواهیم گشت.

در فصل بعد، به گردش کار بازخواهیم گشت تا درباره اهمیت سبک کد و سازماندهی خوب کد برای آسان کردن خواندن و درک آن برای شما و دیگران بحث کنیم.
