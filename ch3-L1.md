# ۱۲ بردارهای منطقی

## ۱.۱۲ مقدمه

در این فصل، ابزارهایی برای کار با بردارهای منطقی خواهید آموخت. بردارهای منطقی ساده‌ترین نوع بردار هستند زیرا هر عنصر فقط می‌تواند یکی از سه مقدار ممکن باشد: `TRUE`، `FALSE` و `NA`. نسبتاً نادر است که بردارهای منطقی را در داده‌های خام خود پیدا کنید، اما در طول تقریباً هر تحلیلی آن‌ها را ایجاد و دستکاری خواهید کرد.

ما با بحث در مورد رایج‌ترین روش ایجاد بردارهای منطقی شروع می‌کنیم: با مقایسه‌های عددی. سپس یاد خواهید گرفت که چگونه می‌توانید از جبر بولی برای ترکیب بردارهای منطقی مختلف استفاده کنید، همچنین برخی خلاصه‌های مفید را یاد خواهید گرفت. ما با `()if_else` و `()case_when` به پایان می‌رسیم، دو تابع مفید برای ایجاد تغییرات شرطی که توسط بردارهای منطقی قدرت می‌گیرند.

### ۱.۱.۱۲ پیش‌نیازها

بیشتر توابعی که در این فصل یاد خواهید گرفت توسط R پایه ارائه شده‌اند، بنابراین به tidyverse نیازی نداریم، اما ما هنوز آن را بارگذاری خواهیم کرد تا بتوانیم از `()mutate`، `()filter` و دوستانشان برای کار با data frameها استفاده کنیم. همچنین به استفاده از نمونه‌های موجود در مجموعه داده `flights::nycflights13` ادامه خواهیم داد.

```{r}
#| label: setup
library(tidyverse)
library(nycflights13)
```

با این حال، همان‌طور که شروع به پوشش ابزارهای بیشتری می‌کنیم، همیشه یک مثال واقعی کامل وجود نخواهد داشت. بنابراین شروع به ساخت برخی داده‌های ساختگی با `()c` خواهیم کرد:

```{r}
x <- c(1, 2, 3, 5, 7, 11, 13)
x * 2
#> [1]  2  4  6 10 14 22 26
```

این کار توضیح توابع فردی را آسان‌تر می‌کند به قیمت سخت‌تر شدن دیدن اینکه چگونه ممکن است به مشکلات داده‌های شما اعمال شود. فقط به یاد داشته باشید که هر دستکاری که ما روی یک بردار آزاد انجام می‌دهیم، می‌توانید روی یک متغیر داخل یک data frame با `()mutate` و دوستانش انجام دهید.

```{r}
df <- tibble(x)
df |> 
  mutate(y = x * 2)
#> # A tibble: 7 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1     1     2
#> 2     2     4
#> 3     3     6
#> 4     5    10
#> 5     7    14
#> 6    11    22
#> 7    13    26
```

## ۲.۱۲ مقایسه‌ها

یک روش بسیار رایج برای ایجاد یک بردار منطقی از طریق مقایسه عددی با `<`، `<=`، `>`، `>=`، `!=` و `==` است. تاکنون عمدتاً از آن‌ها همراه با `()filter` استفاده کرده‌ایم. به عنوان مثال، در اینجا چگونه می‌توانیم از `()filter` برای یافتن تمام پروازهایی که بیش از یک ساعت تاخیر داشتند استفاده کنیم:

```{r}
flights |> 
  filter(dep_delay > 120)
```

مفید است بدانید که این یک میانبر است و شما می‌توانید به صراحت متغیرهای منطقی زیربنایی را با `()mutate` ایجاد کنید:

```{r}
flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
    .keep = "used"
  )
```

این به ویژه برای منطق پیچیده‌تر مفید است زیرا نام‌گذاری مراحل میانی خواندن کد شما و بررسی صحیح محاسبه هر مرحله را آسان‌تر می‌کند.

در کل، فیلتر اولیه معادل است با:

```{r}
flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
  ) |> 
  filter(daytime & approx_ontime)
```

### ۱.۲.۱۲ اعداد اعشاری

مراقب استفاده از `==` با اعداد باشید. به عنوان مثال، به نظر می‌رسد این بردار شامل اعداد `1` و `2` است:

```{r}
x <- c(1 / 49 * 49, sqrt(2) ^ 2)
x
#> [1] 1 2
```

اما اگر آن‌ها را برای برابری آزمایش کنید، `FALSE` دریافت می‌کنید:

```{r}
x == c(1, 2)
#> [1] FALSE FALSE
```

چه اتفاقی می‌افتد؟ کامپیوترها اعداد را با تعداد ثابتی از اعداد اعشاری ذخیره می‌کنند بنابراین راهی برای نمایش دقیق `1/49` یا `sqrt(2)` وجود ندارد. شما می‌توانید تعداد بیشتری از ارقام را با تنظیم آرگومان `digits` تابع `()print` ببینید:

```{r}
print(x, digits = 16)
#> [1] 0.9999999999999999 2.0000000000000004
```

می‌توانید ببینید چرا R به طور پیش‌فرض این اعداد را گرد می‌کند؛ آن‌ها واقعاً بسیار نزدیک به آنچه شما انتظار دارید هستند.

حالا که دیده‌اید چرا `==` با اعداد غیرقابل اعتماد است، چه کاری می‌توانید انجام دهید؟ یک جایگزین استفاده از `()near` از dplyr است که تفاوت‌های کوچک را نادیده می‌گیرد:

```{r}
near(x, c(1, 2))
#> [1] TRUE TRUE
```

### ۲.۲.۱۲ مقادیر گمشده

مقادیر گمشده ناشناخته را نمایش می‌دهند بنابراین آن‌ها "مسری" هستند: تقریباً هر عملیاتی که شامل یک مقدار ناشناخته می‌شود نیز ناشناخته خواهد بود:

```{r}
NA > 5
#> [1] NA
10 == NA
#> [1] NA
```

گیج‌کننده‌ترین نتیجه این است:

```{r}
NA == NA
#> [1] NA
```

درک اینکه چرا این درست است آسان‌تر است اگر به صورت مصنوعی کمی زمینه بیشتری ارائه دهیم:

```{r}
# ما نمی‌دانیم مری چند سال دارد
age_mary <- NA

# ما نمی‌دانیم جان چند سال دارد
age_john <- NA

# آیا مری و جان هم‌سن هستند؟
age_mary == age_john
#> [1] NA
# ما نمی‌دانیم!
```

بنابراین اگر می‌خواهید تمام پروازهایی را که `dep_time` گمشده دارند پیدا کنید، نمی‌توانید از `dep_time == NA` استفاده کنید:

```{r}
flights |> 
  filter(dep_time == NA)
#> # A tibble: 0 × 19
#> # ℹ 19 variables: year <int>, month <int>, day <int>, dep_time <int>, ...
```

در عوض به یک ابزار جدید نیاز خواهیم داشت: `()is.na`.

### ۳.۲.۱۲ `()is.na`

`()is.na(x)` یک بردار منطقی با همان اندازه `x` که دارای `TRUE` در هر جایی که `x` باشد `NA` برمی‌گرداند:

```{r}
is.na(c(TRUE, NA, FALSE))
#> [1] FALSE  TRUE FALSE
is.na(c(1, NA, 3))
#> [1] FALSE  TRUE FALSE
is.na(c("a", NA, "b"))
#> [1] FALSE  TRUE FALSE
```

ما می‌توانیم از `()is.na` برای یافتن تمام ردیف‌هایی با `dep_time` گمشده استفاده کنیم:

```{r}
flights |> 
  filter(is.na(dep_time))
```

`()is.na` همچنین می‌تواند در `()arrange` مفید باشد. `()arrange` معمولاً تمام مقادیر گمشده را در انتها قرار می‌دهد اما می‌توانید با مرتب‌سازی اول با `()is.na` آن‌ها را در ابتدا نمایش دهید:

```{r}
flights |> 
  filter(month == 1, day == 1) |> 
  arrange(dep_time)

flights |> 
  filter(month == 1, day == 1) |> 
  arrange(desc(is.na(dep_time)), dep_time)
```

ما در فصل ۱۸ به مقادیر گمشده با عمق بیشتری خواهیم پرداخت.

### ۴.۲.۱۲ تمرینات

۱. `()near` از dplyr چگونه کار می‌کند؟ کد منبع آن را بخوانید. رجوع به `?near` مفید است.

۲. از `()mutate`، `()is.na` و `()count` همراه برای توصیف اینکه چگونه مقادیر گمشده در `dep_time`، `sched_dep_time` و `dep_delay` مرتبط هستند استفاده کنید.

## ۳.۱۲ جبر بولی

هنگامی که چندین بردار منطقی دارید، می‌توانید آن‌ها را با استفاده از جبر بولی با هم ترکیب کنید. در R، `&` به معنی "و"، `|` به معنی "یا"، `!` به معنی "نه" و `()xor` به معنی or انحصاری است. به عنوان مثال، `df |> filter(!is.na(x))` تمام ردیف‌هایی که `x` گمشده نیست را پیدا می‌کند و `df |> filter(x < -10 | x > 0)` تمام ردیف‌هایی که `x` کمتر از ۱۰- یا بیشتر از ۰ است را پیدا می‌کند. شکل ۱۲.۱ مجموعه کامل عملیات بولی و نحوه کارکرد آن‌ها را نشان می‌دهد.

![نمایش شش عملیات بولی با دایره‌های ون. AND (تقاطع)، OR (اتحاد)، XOR (تفاوت متقارن)، NOT برای x و y و همه داده‌ها.](images/transform-logical.png)

به علاوه `&` و `|`، R همچنین `&&` و `||` دارد. از آن‌ها استفاده نکنید! ما در فصل ۲۵ توضیح خواهیم داد که چه زمانی باید از آن‌ها استفاده کنید.

### ۱.۳.۱۲ مقادیر گمشده

قوانین مقادیر گمشده در جبر بولی توضیح آن‌ها کمی مشکل است زیرا در نگاه اول ناسازگار به نظر می‌رسند:

```{r}
df <- tibble(x = c(TRUE, FALSE, NA))

df |> 
  mutate(
    and = x & NA,
    or = x | NA
  )
#> # A tibble: 3 × 3
#>   x     and   or   
#>   <lgl> <lgl> <lgl>
#> 1 TRUE  NA    TRUE 
#> 2 FALSE FALSE NA   
#> 3 NA    NA    NA
```

برای درک اینکه چه اتفاقی می‌افتد، در مورد `NA | TRUE` (NA یا TRUE) فکر کنید. یک مقدار گمشده یعنی مقدار می‌تواند `TRUE` یا `FALSE` باشد. `TRUE | TRUE` و `FALSE | TRUE` هر دو `TRUE` هستند بنابراین `NA | TRUE` باید نیز `TRUE` باشد. یک استدلال مشابه نشان می‌دهد که `NA | FALSE` باید `NA` باشد.

با منطق مشابه، می‌توانید نشان دهید که `NA & FALSE` باید `FALSE` باشد.

### ۲.۳.۱۲ ترتیب عملیات

توجه کنید که ترتیب عملیات مانند انگلیسی کار نمی‌کند. کد زیر را در نظر بگیرید که تمام پروازهایی که در نوامبر یا دسامبر حرکت کرده‌اند را پیدا می‌کند:

```{r}
flights |> 
  filter(month == 11 | month == 12)
```

ممکن است وسوسه شوید که آن را مانند انگلیسی بنویسید: "تمام پروازهایی که در نوامبر یا دسامبر حرکت کرده‌اند را پیدا کن":

```{r}
flights |> 
  filter(month == 11 | 12)
```

این کد خطا نمی‌دهد اما به نظر نمی‌رسد کار کرده باشد. چه اتفاقی می‌افتد؟ در اینجا، R ابتدا `month == 11` را ارزیابی می‌کند و یک بردار منطقی ایجاد می‌کند که آن را `nov` بنامیم. سپس `nov | 12` را محاسبه می‌کند. در محاسبات عددی `TRUE` به `1` تبدیل می‌شود و `FALSE` به `0` تبدیل می‌شود. این معادل `nov | TRUE` است که همیشه `TRUE` است، بنابراین هر ردیفی انتخاب می‌شود:

```{r}
flights |> 
  filter(month == 11 | 12) |> 
  count(month)
```

### ۳.۳.۱۲ `%in%`

یک راه آسان برای جلوگیری از مشکل ترتیب نادرست `==` و `|` با استفاده از `%in%` است. `x %in% y` یک بردار منطقی به همان طول `x` که `TRUE` است هرجا که مقداری در `x` مطابق با یک مقدار در `y` باشد برمی‌گرداند:

```{r}
1:12 %in% c(1, 5, 11)
#>  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
letters[1:10] %in% c("a", "e", "i", "o", "u")
#>  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
```

بنابراین برای یافتن تمام پروازها در نوامبر و دسامبر می‌توانیم بنویسیم:

```{r}
flights |> 
  filter(month %in% c(11, 12))
```

توجه کنید که `%in%` دقایق باریک `NA` را به روشی مشابه `==` دنبال نمی‌کند:

```{r}
c(1, 2, NA) == NA
#> [1] NA NA NA
c(1, 2, NA) %in% NA
#> [1] FALSE FALSE  TRUE
```

این می‌تواند برای یک میانبر مفید باشد:

```{r}
flights |> 
  filter(dep_time %in% c(NA, 0800))
```

### ۴.۳.۱۲ تمرینات

۱. تمام پروازهایی را پیدا کنید که:
   - `arr_delay` دارای دو ساعت یا بیشتر تأخیر دارند
   - پرواز به هیوستون (`IAH` یا `HOU`)
   - توسط United، American یا Delta انجام شده است
   - در تابستان (ژوئیه، آگوست و سپتامبر) بوده است
   - بیش از دو ساعت تأخیر ورود داشته است، اما تأخیر خروج نداشته است
   - حداقل یک ساعت تأخیر داشته است، اما بیش از ۳۰ دقیقه در پرواز جبران کرده است

۲. `dep_time` را مرتب کنید تا مقادیر گمشده را ابتدا نمایش دهید، سپس نامگمشده‌ها را به ترتیب نزولی.

## ۴.۱۲ خلاصه‌ها

بخش‌های زیر برخی تکنیک‌های مفید برای خلاصه‌سازی بردارهای منطقی را توصیف می‌کنند. علاوه بر توابعی که فقط به طور خاص با بردارهای منطقی کار می‌کنند، همچنین می‌توانید از توابعی که با بردارهای عددی کار می‌کنند استفاده کنید.

### ۱.۴.۱۲ عملیات منطقی

دو خلاصه منطقی اصلی وجود دارد: `()any` و `()all`. `any(x)` معادل `|` است؛ اگر مقدار `TRUE` در `x` وجود داشته باشد `TRUE` برمی‌گرداند. `all(x)` معادل `&` است؛ فقط در صورتی `TRUE` برمی‌گرداند که تمام مقادیر `x` برابر با `TRUE` باشند.

مانند تمام توابع خلاصه، آن‌ها به `na.rm = TRUE` برای نادیده گرفتن مقادیر گمشده احتیاج دارند.

به عنوان مثال، می‌توانیم از `()all` و `()any` برای یافتن اینکه آیا هر پروازی به خطا درگیر شده است استفاده کنیم:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    all_delayed = all(dep_delay <= 60, na.rm = TRUE),
    any_long_delay = any(arr_delay >= 300, na.rm = TRUE),
    .groups = "drop"
  )
```

در بیشتر موارد، با این حال، `()any` و `()all` بسیار خشن هستند، و بهتر است یک خلاصه عددی بگیریم. در این صورت می‌توانید از توابع مفید زیر استفاده کنید.

### ۲.۴.۱۲ خلاصه‌های عددی یک بردار منطقی

هنگامی که از یک بردار منطقی در یک زمینه عددی استفاده می‌کنید، `TRUE` به `1` و `FALSE` به `0` تبدیل می‌شود. این باعث می‌شود که `()sum` و `()mean` بسیار مفید باشند: `sum(x)` تعداد `TRUE` در `x` را به شما می‌دهد و `mean(x)` نسبت را به شما می‌دهد.

این مثلاً به ما امکان می‌دهد نسبت پروازهایی که حداکثر یک ساعت تأخیر خروج داشته‌اند و تعداد پروازهایی که پنج ساعت یا بیشتر تأخیر ورود داشته‌اند را ببینیم:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    all_delayed = mean(dep_delay <= 60, na.rm = TRUE),
    any_long_delay = sum(arr_delay >= 300, na.rm = TRUE),
    .groups = "drop"
  )
```

### ۳.۴.۱۲ خلاصه‌های منطقی

یک استفاده نهایی برای بردارهای منطقی در خلاصه‌ها وجود دارد: می‌توانید از یک بردار منطقی برای فیلتر یک متغیر منفرد به زیرمجموعه مورد علاقه استفاده کنید. این استفاده از عملگر پایه `[` (که "زیرمجموعه‌گیری" خوانده می‌شود و در فصل ۲۷ بیشتر یاد خواهیم گرفت) را انجام می‌دهد.

تصور کنید می‌خواستیم به میانگین تأخیر فقط برای پروازهایی که واقعاً تأخیر داشته‌اند نگاه کنیم. یک راه این است که ابتدا پروازها را فیلتر کنیم و سپس میانگین تأخیر را محاسبه کنیم:

```{r}
flights |> 
  filter(arr_delay > 0) |> 
  group_by(year, month, day) |> 
  summarize(
    behind = mean(arr_delay),
    n = n(),
    .groups = "drop"
  )
```

این کار می‌کند، اما اگر می‌خواستیم میانگین تأخیر برای پروازهایی که زودتر رسیده‌اند را نیز محاسبه کنیم چه؟ ما باید یک مرحله فیلتر جداگانه انجام دهیم و سپس راهی برای ترکیب دو data frameها پیدا کنیم. در عوض می‌توانید از `[` استفاده کنید تا یک فیلتر درون خط انجام دهید: `arr_delay[arr_delay > 0]` تمام مقادیر مثبت `arr_delay` را بازخواهد گرداند.

این منجر به موارد زیر می‌شود:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    behind = mean(arr_delay[arr_delay > 0], na.rm = TRUE),
    ahead = mean(arr_delay[arr_delay < 0], na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )
```

همچنین به تفاوت اندازه گروه توجه کنید: در قطعه اول `()n` تعداد پروازهای با تأخیر را به ما می‌دهد؛ در قطعه دوم `()n` تعداد کل پروازها را به ما می‌دهد.

### ۴.۴.۱۲ تمرینات

۱. `sum(is.na(x))` چه چیزی را اندازه‌گیری می‌کند؟ `mean(is.na(x))` چطور؟

۲. `()prod` چه کار می‌کند؟ آن با `()min` و `()max` چه رابطه‌ای دارد؟

## ۵.۱۲ تبدیلات شرطی

یکی از قدرتمندترین ویژگی‌های بردارهای منطقی استفاده آن‌ها برای تبدیلات شرطی است، یعنی انجام یک کار برای شرط x، و چیز متفاوتی برای y. دو ابزار مهم برای این کار وجود دارد: `()if_else` و `()case_when`.

### ۱.۵.۱۲ `()if_else`

اگر می‌خواهید از یک مقدار زمانی که یک شرط `TRUE` است و یک مقدار دیگر زمانی که `FALSE` است استفاده کنید، می‌توانید از `()if_else` استفاده کنید. همیشه سه آرگومان دارید؛ اول، `condition`، یک بردار منطقی؛ دوم، `true`، مقداری که باید زمانی که شرط درست است استفاده شود؛ و سوم، `false`، مقداری که باید زمانی که شرط نادرست است استفاده شود.

بیایید با یک مثال ساده شروع کنیم که یک بردار عددی را به عنوان "+ve" (مثبت) یا "-ve" (منفی) برچسب‌گذاری می‌کند:

```{r}
x <- c(-3:3, NA)
if_else(x > 0, "+ve", "-ve")
#> [1] "-ve" "-ve" "-ve" "-ve" "+ve" "+ve" "+ve" NA
```

یک آرگومان چهارم اختیاری، `missing`، وجود دارد که مقداری را که باید زمانی که ورودی `NA` است استفاده شود تعریف می‌کند:

```{r}
if_else(x > 0, "+ve", "-ve", "???")
#> [1] "-ve" "-ve" "-ve" "-ve" "+ve" "+ve" "+ve" "???"
```

همچنین می‌توانید از بردارها برای آرگومان‌های `true` و `false` استفاده کنید. به عنوان مثال، این امکان را به ما می‌دهد که یک پیاده‌سازی ساده از `()abs` ایجاد کنیم:

```{r}
if_else(x < 0, -x, x)
#> [1]  3  2  1  0  1  2  3 NA
```

تاکنون تمام آرگومان‌ها از بردارهای یکسانی استفاده کرده‌اند، اما البته می‌توانید آن‌ها را ترکیب و مطابقت دهید. به عنوان مثال، می‌توانید یک نسخه ساده از `()coalesce` را پیاده‌سازی کنید که یک مقدار گمشده را با مقداری که شما تأمین می‌کنید جایگزین می‌کند:

```{r}
x1 <- c(NA, 1, 2, NA)
if_else(is.na(x1), 0, x1)
#> [1] 0 1 2 0
```

ممکن است متوجه یک ناملایمت کوچک در مثال برچسب‌گذاری بالا شده باشید: صفر نه مثبت است و نه منفی. می‌توانیم این را با افزودن یک `()if_else` اضافی حل کنیم:

```{r}
if_else(x == 0, "0", if_else(x > 0, "+ve", "-ve"), "???")
#> [1] "-ve" "-ve" "-ve" "0"   "+ve" "+ve" "+ve" "???"
```

این در حال حاضر کمی سخت برای خواندن است، و می‌توانید تصور کنید که اگر شرایط بیشتری داشته باشید سخت‌تر خواهد شد. در عوض، می‌توانید به `()case_when` از dplyr تغییر دهید.

### ۲.۵.۱۲ `()case_when`

`()case_when` از dplyr برای الهام گرفته از دستور `CASE` SQL طراحی شده است و یک راه انعطاف‌پذیر برای کنترل چندین شرط ارائه می‌دهد. سینتکس کمی غیرعادی دارد: جفت‌های `condition ~ output` را می‌گیرد. `condition` باید یک بردار منطقی باشد؛ هنگامی که درست است، `output` استفاده خواهد شد.

این بدان معناست که می‌توانیم `()if_else` تودرتوی قبلی خود را دوباره ایجاد کنیم:

```{r}
x <- c(-3:3, NA)
case_when(
  x == 0   ~ "0",
  x > 0    ~ "+ve", 
  x < 0    ~ "-ve",
  is.na(x) ~ "???"
)
#> [1] "-ve" "-ve" "-ve" "0"   "+ve" "+ve" "+ve" "???"
```

این کد بیشتری است، اما همچنین صریح‌تر است.

برای توضیح اینکه چگونه `()case_when` کار می‌کند، بیایید به چند مثال ساده‌تر کشف کنیم. اگر هیچ موردی مطابقت نداشته باشد، خروجی `NA` خواهد بود:

```{r}
case_when(
  x > 0 ~ "+ve",
  x > 2 ~ "big"
)
#> [1] NA    NA    NA    NA    "+ve" "+ve" "+ve" NA
```

اگر می‌خواهید یک "پیش‌فرض"/ثابت ایجاد کنید، از `TRUE` در سمت چپ استفاده کنید:

```{r}
case_when(
  x > 0 ~ "+ve",
  x > 2 ~ "big",
  TRUE ~ "???"
)
#> [1] "???" "???" "???" "???" "+ve" "+ve" "+ve" "???"
```

و توجه کنید که اگر چند شرط مطابقت داشته باشند، فقط اولین مورد استفاده خواهد شد:

```{r}
case_when(
  x > 0 ~ "+ve",
  x > 2 ~ "big"
)
#> [1] NA    NA    NA    NA    "+ve" "+ve" "+ve" NA
```

درست مانند `()if_else` می‌توانید از متغیرها در هر دو طرف `~` استفاده کنید و می‌توانید چندین متغیر را در هر طرف مخلوط کنید. به عنوان مثال، می‌توانیم یک برچسب تقریبی برای وضعیت پرواز ارائه دهیم:

```{r}
flights |> 
  mutate(
    status = case_when(
      is.na(arr_delay)      ~ "cancelled",
      arr_delay < -30       ~ "very early",
      arr_delay < -15       ~ "early",
      abs(arr_delay) <= 15  ~ "on time",
      arr_delay > 15        ~ "late",
      arr_delay > 60        ~ "very late",
    ),
    .keep = "used"
  )
```

مراقب باشید وقتی این نوع `()case_when` پیچیده می‌نویسید. در مثال بالا، ما `arr_delay > 60` و `arr_delay > 15` را داریم، اما از آنجایی که اولی قبل از دومی آمده است، `arr_delay > 60` هرگز اجرا نخواهد شد. ممکن است بخواهید از `<` و `>` با خطوط راهنمایی واضح بین مقادیر برای جلوگیری از این مشکل استفاده کنید.

### ۳.۵.۱۲ انواع سازگار

توجه کنید که هم `()if_else` و هم `()case_when` نیاز دارند که انواع سازگار باشند: هم `true` و هم `false` باید همان نوع بردار باشند. اگر اینطور نباشند، یک خطا دریافت خواهید کرد:

```{r}
if_else(x > 0, x, "some string")
#> Error in `if_else()`:
#> ! Can't combine `true` <double> and `false` <character>.
```

در کل، تعداد نسبتاً کمی از انواع سازگار هستند، زیرا تبدیل خودکار یک نوع بردار به دیگری منبع رایج خطاهاست. در اینجا مهم‌ترین مواردی که سازگار هستند آمده است:

- بردارهای عددی و منطقی سازگار هستند، همان‌طور که در بخش ۱۲.۴.۲ بحث کردیم.
- رشته‌ها و فاکتورها (فصل ۱۶) سازگار هستند، زیرا می‌توانید فاکتورها را به عنوان رشته‌هایی با یک مجموعه محدود از مقادیر ممکن فکر کنید.
- تاریخ‌ها و تاریخ-زمان‌ها، که در فصل ۱۷ بحث خواهیم کرد، سازگار هستند زیرا می‌توانید تاریخ‌ها را به عنوان تاریخ-زمان‌های ویژه فکر کنید.
- `NA`، که فنی است، با همه چیز سازگار است زیرا هر بردار می‌تواند مقادیر گمشده داشته باشد.

ما انتظار نداریم که این قوانین را حفظ کنید، اما آن‌ها باید با گذشت زمان طبیعی شوند زیرا به طور مداوم در سراسر tidyverse اعمال می‌شوند.

### ۴.۵.۱۲ تمرینات

۱. یک عدد زوج است اگر بر دو بخش‌پذیر باشد، که در R می‌توانید با `x %% 2 == 0` متوجه شوید. از `()if_else` برای تعیین اینکه هر عدد بین ۰ تا ۲۰ زوج یا فرد است استفاده کنید.

۲. با توجه به بردار روزها مانند `x <- c("Monday", "Saturday", "Wednesday")`، از `()if_else` برای برچسب‌گذاری آن‌ها به عنوان آخر هفته یا روز هفته استفاده کنید.

۳. از `()if_else` برای محاسبه قدر مطلق یک عدد عددی با استفاده از `x` که قبلاً تعریف شده است استفاده کنید.

۴. یک `()case_when` بنویسید که از متغیرهای `month` و `day` برای برچسب‌گذاری مجموعه انتخابی از روزهای تعطیل مهم استفاده کند (مثلاً سال نو، روز استقلال، کریسمس). ابتدا یک بردار منطقی ایجاد کنید تا روزهایی را که روی یک تعطیل می‌افتند علامت‌گذاری کنید و سپس از آن برای ایجاد یک متغیر کاراکتری برچسب‌دار استفاده کنید که روزهای تعطیل را نام‌گذاری می‌کند.

## ۶.۱۲ خلاصه

تعریف یک بردار منطقی ساده است زیرا هر مقدار باید یا `TRUE`، `FALSE` یا `NA` باشد. اما بردارهای منطقی پایه و اساس علم داده هستند زیرا راه حل برای مسائل رایجی هستند که شامل مقایسه متغیرها، فیلتر کردن ردیف‌ها یا ایجاد خلاصه‌های شرطی است. در این فصل، با ابزارهای زیادی آشنا شده‌اید:

- عملگرهای مقایسه‌ای: `>`، `<`، `<=`، `>=`، `==` و `!=` و `()is.na` برای چک کردن مقادیر گمشده.
- عملگرهای جبر بولی `!` برای NOT، `&` برای AND، و `|` برای OR.
- `()any` و `()all` برای تعیین اینکه آیا یک بردار منطقی حاوی مقدار `TRUE` است.
- `()sum` و `()mean` برای محاسبه تعداد و نسبت `TRUE` در یک بردار منطقی.
- `()if_else` و `()case_when` برای انجام تبدیلات شرطی.

ما بردارهای منطقی را بارها و بارها در فصل‌های زیر خواهیم دید. به عنوان مثال در فصل ۱۴، یاد خواهید گرفت که `str_detect(x, pattern)` یک بردار منطقی برمی‌گرداند که `TRUE` برای عناصری از `x` که `pattern` را دارند و در فصل ۱۹، یاد خواهید گrفت که توابع `join` از یک بردار منطقی برای تعیین اینکه کدام ردیف‌ها باید ترکیب شوند استفاده می‌کنند.
