# ۲۳ داده‌های سلسله‌مراتبی

## ۱.۲۳ مقدمه

در این فصل، شما هنر **مستطیل‌سازی** داده‌ها را یاد خواهید گرفت: گرفتن داده‌هایی که اساساً سلسله‌مراتبی یا درخت‌مانند هستند و تبدیل آن‌ها به یک data frame مستطیلی متشکل از سطرها و ستون‌ها. این مهم است زیرا داده‌های سلسله‌مراتبی به طور شگفت‌انگیزی رایج هستند، به ویژه هنگام کار با داده‌هایی که از وب می‌آیند.

برای یادگیری مستطیل‌سازی، ابتدا باید در مورد لیست‌ها، ساختار داده‌ای که داده‌های سلسله‌مراتبی را ممکن می‌سازد، یاد بگیرید. سپس در مورد دو تابع حیاتی tidyr یاد خواهید گرفت: `tidyr::unnest_longer()` و `tidyr::unnest_wider()`. سپس چند مطالعه موردی را به شما نشان خواهیم داد و این توابع ساده را بارها و بارها برای حل مشکلات واقعی به کار خواهیم برد. در پایان، در مورد JSON صحبت خواهیم کرد، رایج‌ترین منبع مجموعه داده‌های سلسله‌مراتبی و یک فرمت رایج برای تبادل داده در وب.

### ۱.۱.۲۳ پیش‌نیازها

در این فصل، از توابع زیادی از tidyr، یک عضو اصلی tidyverse، استفاده خواهیم کرد. همچنین از repurrrsive برای ارائه برخی مجموعه داده‌های جالب برای تمرین مستطیل‌سازی استفاده خواهیم کرد، و در پایان از jsonlite برای خواندن فایل‌های JSON در لیست‌های R استفاده خواهیم کرد.

```{r}
library(tidyverse)
library(repurrrsive)
library(jsonlite)
```

## ۲.۲۳ لیست‌ها

تاکنون با data frame هایی کار کرده‌اید که حاوی بردارهای ساده مانند اعداد صحیح، اعداد، کاراکترها، تاریخ-زمان‌ها و فاکتورها هستند. این بردارها ساده هستند زیرا همگن هستند: هر عنصر از یک نوع داده یکسان است. اگر می‌خواهید عناصر از انواع مختلف را در یک بردار ذخیره کنید، به یک **لیست** نیاز دارید که آن را با `list()` ایجاد می‌کنید:

```{r}
x1 <- list(1:4, "a", TRUE)
x1
```

اغلب مناسب است که اجزا یا **فرزندان** یک لیست را نام‌گذاری کنید، که می‌توانید به همان روشی که ستون‌های یک tibble را نام‌گذاری می‌کنید این کار را انجام دهید:

```{r}
x2 <- list(a = 1:2, b = 1:3, c = 1:4)
x2
```

حتی برای این لیست‌های بسیار ساده، چاپ فضای زیادی را اشغال می‌کند. یک جایگزین مفید `str()` است که یک نمایش فشرده از **ساختار** ایجاد می‌کند و بر محتویات تأکید کمتری دارد:

```{r}
str(x1)
str(x2)
```

همانطور که می‌بینید، `str()` هر فرزند لیست را در خط خودش نمایش می‌دهد. نام را نمایش می‌دهد، در صورت وجود، سپس یک مخفف از نوع، سپس چند مقدار اول.

### ۱.۲.۲۳ سلسله‌مراتب

لیست‌ها می‌توانند هر نوع شیء را شامل شوند، از جمله لیست‌های دیگر. این آن‌ها را برای نمایش ساختارهای سلسله‌مراتبی (درخت‌مانند) مناسب می‌سازد:

```{r}
x3 <- list(list(1, 2), list(3, 4))
str(x3)
```

این به طور قابل توجهی با `c()` متفاوت است که یک بردار تخت ایجاد می‌کند:

```{r}
c(c(1, 2), c(3, 4))

x4 <- c(list(1, 2), list(3, 4))
str(x4)
```

همانطور که لیست‌ها پیچیده‌تر می‌شوند، `str()` مفیدتر می‌شود، زیرا به شما امکان می‌دهد سلسله‌مراتب را در یک نگاه ببینید:

```{r}
x5 <- list(1, list(2, list(3, list(4, list(5)))))
str(x5)
```

همانطور که لیست‌ها حتی بزرگ‌تر و پیچیده‌تر می‌شوند، `str()` در نهایت شروع به شکست می‌کند، و شما باید به `View()` تغییر دهید. نتیجه فراخوانی `View(x5)` را نشان می‌دهد. نمایشگر با نمایش فقط سطح بالای لیست شروع می‌شود، اما می‌توانید به طور تعاملی هر یک از اجزا را گسترش دهید تا بیشتر ببینید. RStudio همچنین کدی را که برای دسترسی به آن عنصر نیاز دارید به شما نشان خواهد داد. ما به نحوه کار این کد بازخواهیم گشت.

### ۲.۲.۲۳ ستون‌های لیستی

لیست‌ها همچنین می‌توانند در یک tibble زندگی کنند، جایی که ما آن‌ها را ستون‌های لیستی می‌نامیم. ستون‌های لیستی مفید هستند زیرا به شما اجازه می‌دهند اشیایی را در یک tibble قرار دهید که معمولاً در آنجا قرار نمی‌گیرند. به ویژه، ستون‌های لیستی در اکوسیستم [tidymodels](https://www.tidymodels.org) بسیار استفاده می‌شوند، زیرا به شما امکان می‌دهند چیزهایی مانند خروجی‌های مدل یا نمونه‌برداری مجدد را در یک data frame ذخیره کنید.

در اینجا یک مثال ساده از یک ستون لیستی آورده شده است:

```{r}
df <- tibble(
  x = 1:2, 
  y = c("a", "b"),
  z = list(list(1, 2), list(3, 4, 5))
)
df
```

هیچ چیز خاصی در مورد لیست‌ها در یک tibble وجود ندارد؛ آن‌ها مانند هر ستون دیگری رفتار می‌کنند:

```{r}
df |> 
  filter(x == 1)
```

محاسبه با ستون‌های لیستی سخت‌تر است، اما این به این دلیل است که محاسبه با لیست‌ها به طور کلی سخت‌تر است. در این فصل، روی باز کردن ستون‌های لیستی به متغیرهای معمولی تمرکز خواهیم کرد تا بتوانید از ابزارهای موجود خود روی آن‌ها استفاده کنید.

روش چاپ پیش‌فرض فقط یک خلاصه تقریبی از محتویات را نمایش می‌دهد. ستون لیستی می‌تواند به طور دلخواه پیچیده باشد، بنابراین راه خوبی برای چاپ آن وجود ندارد. اگر می‌خواهید آن را ببینید، باید فقط یک ستون لیستی را بیرون بکشید و یکی از تکنیک‌هایی را که در بالا یاد گرفته‌اید اعمال کنید، مانند `df |> pull(z) |> str()` یا `df |> pull(z) |> View()`.

## ۳.۲۳ باز کردن (Unnesting)

اکنون که اصول اولیه لیست‌ها و ستون‌های لیستی را یاد گرفته‌اید، بیایید بررسی کنیم که چگونه می‌توانید آن‌ها را به سطرها و ستون‌های معمولی تبدیل کنید. در اینجا از داده‌های نمونه بسیار ساده استفاده خواهیم کرد تا ایده اصلی را دریافت کنید؛ در بخش بعدی به داده‌های واقعی تغییر خواهیم داد.

ستون‌های لیستی تمایل دارند در دو شکل اساسی بیایند: نام‌گذاری شده و نام‌گذاری نشده. وقتی فرزندان **نام‌گذاری شده** هستند، تمایل دارند در هر سطر نام‌های یکسانی داشته باشند. به عنوان مثال، در `df1`، هر عنصر از ستون لیستی `y` دو عنصر به نام‌های `a` و `b` دارد. ستون‌های لیستی نام‌گذاری شده به طور طبیعی به ستون‌ها باز می‌شوند: هر عنصر نام‌گذاری شده به یک ستون جدید نام‌گذاری شده تبدیل می‌شود.

```{r}
df1 <- tribble(
  ~x, ~y,
  1, list(a = 11, b = 12),
  2, list(a = 21, b = 22),
  3, list(a = 31, b = 32),
)
```

وقتی فرزندان **نام‌گذاری نشده** هستند، تعداد عناصر تمایل دارد از سطر به سطر متفاوت باشد. به عنوان مثال، در `df2`، عناصر ستون لیستی `y` نام‌گذاری نشده هستند و طول آن‌ها از یک تا سه متفاوت است. ستون‌های لیستی نام‌گذاری نشده به طور طبیعی به سطرها باز می‌شوند: برای هر فرزند یک سطر دریافت خواهید کرد.

```{r}
df2 <- tribble(
  ~x, ~y,
  1, list(11, 12, 13),
  2, list(21),
  3, list(31, 32),
)
```

tidyr دو تابع برای این دو حالت فراهم می‌کند: `unnest_wider()` و `unnest_longer()`. بخش‌های زیر توضیح می‌دهند که چگونه کار می‌کنند.

### ۱.۳.۲۳ `unnest_wider()`

وقتی هر سطر تعداد یکسانی از عناصر با نام‌های یکسان دارد، مانند `df1`، طبیعی است که هر جزء را در ستون خودش با `unnest_wider()` قرار دهید:

```{r}
df1 |> 
  unnest_wider(y)
```

به طور پیش‌فرض، نام‌های ستون‌های جدید منحصراً از نام‌های عناصر لیست می‌آیند، اما می‌توانید از آرگومان `names_sep` استفاده کنید تا درخواست کنید که آن‌ها نام ستون و نام عنصر را ترکیب کنند. این برای رفع ابهام از نام‌های تکراری مفید است.

```{r}
df1 |> 
  unnest_wider(y, names_sep = "_")
```

### ۲.۳.۲۳ `unnest_longer()`

وقتی هر سطر حاوی یک لیست نام‌گذاری نشده است، طبیعی‌ترین کار این است که هر عنصر را در سطر خودش با `unnest_longer()` قرار دهید:

```{r}
df2 |> 
  unnest_longer(y)
```

توجه کنید که چگونه `x` برای هر عنصر درون `y` تکرار می‌شود: برای هر عنصر درون ستون لیستی یک سطر خروجی دریافت می‌کنیم. اما اگر یکی از عناصر خالی باشد چه اتفاقی می‌افتد، مانند مثال زیر؟

```{r}
df6 <- tribble(
  ~x, ~y,
  "a", list(1, 2),
  "b", list(3),
  "c", list()
)
df6 |> unnest_longer(y)
```

در خروجی صفر سطر دریافت می‌کنیم، بنابراین سطر عملاً ناپدید می‌شود. اگر می‌خواهید آن سطر را حفظ کنید و `NA` را در `y` اضافه کنید، `keep_empty = TRUE` را تنظیم کنید.

### ۳.۳.۲۳ انواع ناسازگار

اگر یک ستون لیستی را که حاوی انواع مختلف بردار است باز کنید چه اتفاقی می‌افتد؟ به عنوان مثال، مجموعه داده زیر را در نظر بگیرید که ستون لیستی `y` حاوی دو عدد، یک کاراکتر و یک منطقی است که معمولاً نمی‌توانند در یک ستون مخلوط شوند.

```{r}
df4 <- tribble(
  ~x, ~y,
  "a", list(1),
  "b", list("a", TRUE, 5)
)
```

`unnest_longer()` همیشه مجموعه ستون‌ها را بدون تغییر نگه می‌دارد، در حالی که تعداد سطرها را تغییر می‌دهد. پس چه اتفاقی می‌افتد؟ چگونه `unnest_longer()` پنج سطر تولید می‌کند در حالی که همه چیز را در `y` نگه می‌دارد؟

```{r}
df4 |> 
  unnest_longer(y)
```

همانطور که می‌بینید، خروجی حاوی یک ستون لیستی است، اما هر عنصر از ستون لیستی حاوی یک عنصر واحد است. از آنجا که `unnest_longer()` نمی‌تواند یک نوع مشترک از بردار پیدا کند، انواع اصلی را در یک ستون لیستی نگه می‌دارد. ممکن است تعجب کنید که آیا این دستور را که هر عنصر یک ستون باید از نوع یکسان باشد نقض می‌کند یا نه. خیر: هر عنصر یک لیست است، حتی اگر محتویات از انواع مختلف باشند.

برخورد با انواع ناسازگار چالش‌برانگیز است و جزئیات به ماهیت دقیق مشکل و اهداف شما بستگی دارد، اما به احتمال زیاد به ابزارهایی از فصل تکرار نیاز خواهید داشت.

### ۴.۳.۲۳ توابع دیگر

tidyr چند تابع مفید دیگر برای مستطیل‌سازی دارد که در این کتاب پوشش نمی‌دهیم:

- `unnest_auto()` به طور خودکار بین `unnest_longer()` و `unnest_wider()` بر اساس ساختار ستون لیستی انتخاب می‌کند. برای کاوش سریع عالی است، اما در نهایت ایده بدی است زیرا شما را مجبور نمی‌کند بفهمید که داده‌های شما چگونه ساختار یافته‌اند، و کد شما را سخت‌تر برای درک می‌کند.
- `unnest()` هم سطرها و هم ستون‌ها را گسترش می‌دهد. وقتی یک ستون لیستی دارید که حاوی یک ساختار دوبعدی مانند یک data frame است مفید است، که در این کتاب نمی‌بینید، اما ممکن است اگر از اکوسیستم [tidymodels](https://www.tmwr.org/base-r.html#combining-base-r-models-and-the-tidyverse) استفاده کنید با آن مواجه شوید.

این توابع خوب است که بدانید زیرا ممکن است هنگام خواندن کد دیگران یا خودتان در مواجهه با چالش‌های نادرتر مستطیل‌سازی با آن‌ها مواجه شوید.

### ۵.۳.۲۳ تمرین‌ها

۱. وقتی از `unnest_wider()` با ستون‌های لیستی نام‌گذاری نشده مانند `df2` استفاده می‌کنید چه اتفاقی می‌افتد؟ اکنون چه آرگومانی لازم است؟ با مقادیر گم‌شده چه اتفاقی می‌افتد؟

۲. وقتی از `unnest_longer()` با ستون‌های لیستی نام‌گذاری شده مانند `df1` استفاده می‌کنید چه اتفاقی می‌افتد؟ چه اطلاعات اضافی در خروجی دریافت می‌کنید؟ چگونه می‌توانید آن جزئیات اضافی را سرکوب کنید؟

۳. گاهی اوقات با data frame هایی با چندین ستون لیستی با مقادیر تراز شده مواجه می‌شوید. به عنوان مثال، در data frame زیر، مقادیر `y` و `z` تراز هستند (یعنی `y` و `z` همیشه در یک سطر طول یکسانی خواهند داشت، و مقدار اول `y` با مقدار اول `z` مطابقت دارد). اگر دو فراخوانی `unnest_longer()` را به این data frame اعمال کنید چه اتفاقی می‌افتد؟ چگونه می‌توانید رابطه بین `x` و `y` را حفظ کنید؟ (راهنمایی: مستندات را با دقت بخوانید).

```{r}
df4 <- tribble(
  ~x, ~y, ~z,
  "a", list("y-a-1", "y-a-2"), list("z-a-1", "z-a-2"),
  "b", list("y-b-1", "y-b-2", "y-b-3"), list("z-b-1", "z-b-2", "z-b-3")
)
```

## ۴.۲۳ مطالعات موردی

تفاوت اصلی بین مثال‌های ساده‌ای که در بالا استفاده کردیم و داده‌های واقعی این است که داده‌های واقعی معمولاً حاوی سطوح متعددی از تو در تو هستند که نیاز به فراخوانی‌های متعدد `unnest_longer()` و/یا `unnest_wider()` دارند. برای نشان دادن آن در عمل، این بخش سه چالش واقعی مستطیل‌سازی را با استفاده از مجموعه داده‌های بسته repurrrsive انجام می‌دهد.

### ۱.۴.۲۳ داده‌های بسیار گسترده

با `gh_repos` شروع خواهیم کرد. این یک لیست است که حاوی داده‌هایی درباره مجموعه‌ای از مخازن GitHub است که با استفاده از API GitHub بازیابی شده است. این یک لیست بسیار عمیقاً تو در تو است بنابراین نمایش ساختار آن در این کتاب دشوار است؛ توصیه می‌کنیم قبل از ادامه، کمی خودتان با `View(gh_repos)` کاوش کنید.

`gh_repos` یک لیست است، اما ابزارهای ما با ستون‌های لیستی کار می‌کنند، بنابراین با قرار دادن آن در یک tibble شروع خواهیم کرد. ما این ستون را `json` می‌نامیم به دلایلی که بعداً به آن خواهیم رسید.

```{r}
repos <- tibble(json = gh_repos)
repos
```

این tibble شامل ۶ سطر است، یک سطر برای هر فرزند `gh_repos`. هر سطر حاوی یک لیست نام‌گذاری نشده با ۲۶ یا ۳۰ سطر است. از آنجا که اینها نام‌گذاری نشده‌اند، با `unnest_longer()` شروع می‌کنیم تا هر فرزند را در سطر خودش قرار دهیم:

```{r}
repos |> 
  unnest_longer(json)
```

در نگاه اول، ممکن است به نظر برسد که وضعیت را بهبود نداده‌ایم: در حالی که سطرهای بیشتری داریم (۱۷۶ به جای ۶)، هر عنصر `json` هنوز یک لیست است. با این حال، یک تفاوت مهم وجود دارد: اکنون هر عنصر یک لیست **نام‌گذاری شده** است بنابراین می‌توانیم از `unnest_wider()` استفاده کنیم تا هر عنصر را در ستون خودش قرار دهیم:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) 
```

این کار کرده است اما نتیجه کمی خیره‌کننده است: ستون‌های بسیار زیادی وجود دارد که tibble حتی همه آن‌ها را چاپ نمی‌کند! می‌توانیم همه آن‌ها را با `names()` ببینیم؛ و در اینجا به ۱۰ تای اول نگاه می‌کنیم:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  names() |> 
  head(10)
```

بیایید چند تا که جالب به نظر می‌رسند بیرون بیاوریم:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description)
```

می‌توانید از این برای درک نحوه ساختار `gh_repos` استفاده کنید: هر فرزند یک کاربر GitHub بود که حاوی لیستی از حداکثر ۳۰ مخزن GitHub بود که آن‌ها ایجاد کرده بودند.

`owner` یک ستون لیستی دیگر است، و از آنجا که حاوی یک لیست نام‌گذاری شده است، می‌توانیم از `unnest_wider()` برای دریافت مقادیر استفاده کنیم:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description) |> 
  unnest_wider(owner)
```

اوه نه، این ستون لیستی همچنین حاوی یک ستون `id` است و نمی‌توانیم دو ستون `id` در یک data frame داشته باشیم. همانطور که پیشنهاد شده است، بیایید از `names_sep` برای حل مشکل استفاده کنیم:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description) |> 
  unnest_wider(owner, names_sep = "_")
```

این یک مجموعه داده گسترده دیگر می‌دهد، اما می‌توانید حس کنید که `owner` به نظر می‌رسد حاوی داده‌های بیشتری درباره شخصی است که مخزن را "مالک" است.

### ۲.۴.۲۳ داده‌های رابطه‌ای

داده‌های تو در تو گاهی اوقات برای نمایش داده‌هایی استفاده می‌شوند که معمولاً در چندین data frame پخش می‌کنیم. به عنوان مثال، `got_chars` را در نظر بگیرید که حاوی داده‌هایی درباره شخصیت‌هایی است که در کتاب‌ها و سریال تلویزیونی Game of Thrones ظاهر می‌شوند. مانند `gh_repos` این یک لیست است، بنابراین با تبدیل آن به یک ستون لیستی از یک tibble شروع می‌کنیم:

```{r}
chars <- tibble(json = got_chars)
chars
```

ستون `json` حاوی عناصر نام‌گذاری شده است، بنابراین با گسترش آن شروع خواهیم کرد:

```{r}
chars |> 
  unnest_wider(json)
```

و انتخاب چند ستون برای سهولت خواندن:

```{r}
characters <- chars |> 
  unnest_wider(json) |> 
  select(id, name, gender, culture, born, died, alive)
characters
```

این مجموعه داده همچنین حاوی بسیاری از ستون‌های لیستی است:

```{r}
chars |> 
  unnest_wider(json) |> 
  select(id, where(is.list))
```

بیایید ستون `titles` را کاوش کنیم. این یک ستون لیستی نام‌گذاری نشده است، بنابراین آن را به سطرها باز خواهیم کرد:

```{r}
chars |> 
  unnest_wider(json) |> 
  select(id, titles) |> 
  unnest_longer(titles)
```

ممکن است انتظار داشته باشید این داده‌ها را در جدول خودش ببینید زیرا پیوستن آن به داده‌های شخصیت‌ها در صورت نیاز آسان خواهد بود. بیایید این کار را انجام دهیم، که نیاز به کمی پاکسازی دارد: حذف سطرهایی که حاوی رشته‌های خالی هستند و تغییر نام `titles` به `title` زیرا هر سطر اکنون فقط حاوی یک عنوان است.

```{r}
titles <- chars |> 
  unnest_wider(json) |> 
  select(id, titles) |> 
  unnest_longer(titles) |> 
  filter(titles != "") |> 
  rename(title = titles)
titles
```

می‌توانید تصور کنید که یک جدول مانند این را برای هر یک از ستون‌های لیستی ایجاد کنید، سپس از پیوندها برای ترکیب آن‌ها با داده‌های شخصیت در صورت نیاز استفاده کنید.

### ۳.۴.۲۳ تو در تو عمیق

این مطالعات موردی را با یک ستون لیستی که بسیار عمیقاً تو در تو است و نیاز به دورهای مکرر `unnest_wider()` و `unnest_longer()` برای باز کردن آن دارد، پایان می‌دهیم: `gmaps_cities`. این یک tibble دو ستونی است که حاوی پنج نام شهر و نتایج استفاده از [API جغرافیایی](https://developers.google.com/maps/documentation/geocoding) گوگل برای تعیین موقعیت آن‌هاست:

```{r}
gmaps_cities
```

`json` یک ستون لیستی با نام‌های داخلی است، بنابراین با یک `unnest_wider()` شروع می‌کنیم:

```{r}
gmaps_cities |> 
  unnest_wider(json)
```

این به ما `status` و `results` را می‌دهد. ستون status را حذف خواهیم کرد زیرا همه آن‌ها `OK` هستند؛ در یک تحلیل واقعی، همچنین می‌خواهید تمام سطرهایی که `status != "OK"` است را ضبط کنید و بفهمید چه اشتباهی رخ داده است. `results` یک لیست نام‌گذاری نشده است، با یک یا دو عنصر (به زودی خواهیم دید چرا) بنابراین آن را به سطرها باز خواهیم کرد:

```{r}
gmaps_cities |> 
  unnest_wider(json) |> 
  select(-status) |> 
  unnest_longer(results)
```

اکنون `results` یک لیست نام‌گذاری شده است، بنابراین از `unnest_wider()` استفاده خواهیم کرد:

```{r}
locations <- gmaps_cities |> 
  unnest_wider(json) |> 
  select(-status) |> 
  unnest_longer(results) |> 
  unnest_wider(results)
locations
```

اکنون می‌توانیم ببینیم چرا دو شهر دو نتیجه دریافت کردند: Washington هم با ایالت واشنگتن و هم با واشنگتن دی‌سی مطابقت داشت، و Arlington با آرلینگتون، ویرجینیا و آرلینگتون، تگزاس مطابقت داشت.

چند مکان مختلف وجود دارد که می‌توانیم از اینجا برویم. ممکن است بخواهیم موقعیت دقیق تطابق را تعیین کنیم که در ستون لیستی `geometry` ذخیره شده است:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry)
```

این به ما `bounds` جدید (یک منطقه مستطیلی) و `location` (یک نقطه) می‌دهد. می‌توانیم `location` را باز کنیم تا عرض جغرافیایی (`lat`) و طول جغرافیایی (`lng`) را ببینیم:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  unnest_wider(location)
```

استخراج مرزها به چند مرحله بیشتر نیاز دارد:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  select(!location:viewport) |>
  unnest_wider(bounds)
```

سپس `southwest` و `northeast` (گوشه‌های مستطیل) را تغییر نام می‌دهیم تا بتوانیم از `names_sep` برای ایجاد نام‌های کوتاه اما تداعی‌کننده استفاده کنیم:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  select(!location:viewport) |>
  unnest_wider(bounds) |> 
  rename(ne = northeast, sw = southwest) |> 
  unnest_wider(c(ne, sw), names_sep = "_") 
```

توجه کنید که چگونه دو ستون را به طور همزمان با ارائه یک بردار از نام‌های متغیر به `unnest_wider()` باز کردیم.

وقتی مسیر رسیدن به اجزایی که به آن‌ها علاقه‌مند هستید را کشف کردید، می‌توانید آن‌ها را مستقیماً با استفاده از تابع دیگری از tidyr، `hoist()` استخراج کنید:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  hoist(
    geometry,
    ne_lat = c("bounds", "northeast", "lat"),
    sw_lat = c("bounds", "southwest", "lat"),
    ne_lng = c("bounds", "northeast", "lng"),
    sw_lng = c("bounds", "southwest", "lng"),
  )
```

اگر این مطالعات موردی اشتهای شما را برای مستطیل‌سازی بیشتر در زندگی واقعی تحریک کرده است، می‌توانید چند مثال دیگر را در `vignette("rectangling", package = "tidyr")` ببینید.

### ۴.۴.۲۳ تمرین‌ها

۱. تقریباً تخمین بزنید که `gh_repos` چه زمانی ایجاد شد. چرا فقط می‌توانید تاریخ را تقریباً تخمین بزنید؟

۲. ستون `owner` از `gh_repo` حاوی اطلاعات تکراری زیادی است زیرا هر مالک می‌تواند مخازن زیادی داشته باشد. آیا می‌توانید یک data frame `owners` بسازید که شامل یک سطر برای هر مالک باشد؟ (راهنمایی: آیا `distinct()` با ستون‌های لیستی کار می‌کند؟)

۳. مراحل استفاده شده برای `titles` را دنبال کنید تا جداول مشابهی برای نام‌های مستعار، وفاداری‌ها، کتاب‌ها و سریال تلویزیونی برای شخصیت‌های Game of Thrones ایجاد کنید.

۴. کد زیر را خط به خط توضیح دهید. چرا جالب است؟ چرا برای `got_chars` کار می‌کند اما ممکن است به طور کلی کار نکند؟

```{r}
tibble(json = got_chars) |> 
  unnest_wider(json) |> 
  select(id, where(is.list)) |> 
  pivot_longer(
    where(is.list), 
    names_to = "name", 
    values_to = "value"
  ) |>  
  unnest_longer(value)
```

۵. در `gmaps_cities`، `address_components` چه چیزی را شامل می‌شود؟ چرا طول بین سطرها متفاوت است؟ آن را به طور مناسب باز کنید تا متوجه شوید. (راهنمایی: `types` همیشه به نظر می‌رسد حاوی دو عنصر است. آیا `unnest_wider()` کار با آن را نسبت به `unnest_longer()` آسان‌تر می‌کند؟)

## ۵.۲۳ JSON

همه مطالعات موردی در بخش قبلی از JSON وحشی منبع گرفته شده‌اند. JSON مخفف **j**ava**s**cript **o**bject **n**otation است و روشی است که اکثر API های وب داده‌ها را برمی‌گردانند. درک آن مهم است زیرا در حالی که JSON و انواع داده R کاملاً مشابه هستند، یک نگاشت یک به یک کامل وجود ندارد، بنابراین اگر مشکلی پیش بیاید، خوب است که کمی در مورد JSON بدانید.

### ۱.۵.۲۳ انواع داده

JSON یک فرمت ساده است که برای خواندن و نوشتن آسان توسط ماشین‌ها طراحی شده است، نه انسان‌ها. شش نوع داده کلیدی دارد. چهار مورد از آن‌ها اسکالر هستند:

- ساده‌ترین نوع یک null (`null`) است که نقش یکسانی با `NA` در R ایفا می‌کند. نشان‌دهنده عدم وجود داده است.
- یک **رشته** بسیار شبیه به یک رشته در R است، اما باید همیشه از علامت نقل قول دوگانه استفاده کند.
- یک **عدد** شبیه به اعداد R است: می‌توانند از نماد صحیح (مثلاً ۱۲۳)، اعشاری (مثلاً ۱۲۳.۴۵) یا علمی (مثلاً ۱.۲۳e۳) استفاده کنند. JSON از `Inf`، `-Inf` یا `NaN` پشتیبانی نمی‌کند.
- یک **boolean** شبیه به `TRUE` و `FALSE` R است، اما از `true` و `false` با حروف کوچک استفاده می‌کند.

رشته‌ها، اعداد و boolean های JSON کاملاً شبیه به بردارهای کاراکتر، عددی و منطقی R هستند. تفاوت اصلی این است که اسکالرهای JSON فقط می‌توانند یک مقدار واحد را نمایش دهند. برای نمایش چندین مقدار، باید از یکی از دو نوع باقی‌مانده استفاده کنید: آرایه‌ها و اشیا.

هم آرایه‌ها و هم اشیا شبیه به لیست‌ها در R هستند؛ تفاوت این است که آیا نام‌گذاری شده‌اند یا نه. یک **آرایه** مانند یک لیست نام‌گذاری نشده است و با `[]` نوشته می‌شود. به عنوان مثال `[1, 2, 3]` یک آرایه حاوی ۳ عدد است، و `[null, 1, "string", false]` یک آرایه است که حاوی یک null، یک عدد، یک رشته و یک boolean است. یک **شیء** مانند یک لیست نام‌گذاری شده است و با `{}` نوشته می‌شود. نام‌ها (کلیدها در اصطلاح JSON) رشته هستند، بنابراین باید توسط علامت نقل قول احاطه شوند. به عنوان مثال، `{"x": 1, "y": 2}` یک شیء است که `x` را به ۱ و `y` را به ۲ نگاشت می‌کند.

توجه کنید که JSON هیچ راه بومی برای نمایش تاریخ‌ها یا تاریخ-زمان‌ها ندارد، بنابراین اغلب به عنوان رشته ذخیره می‌شوند، و شما باید از `readr::parse_date()` یا `readr::parse_datetime()` استفاده کنید تا آن‌ها را به ساختار داده صحیح تبدیل کنید. به طور مشابه، قوانین JSON برای نمایش اعداد ممیز شناور کمی نامشخص هستند، بنابراین گاهی اوقات اعداد را ذخیره شده در رشته‌ها نیز پیدا خواهید کرد. در صورت نیاز `readr::parse_double()` را اعمال کنید تا نوع متغیر صحیح را دریافت کنید.

### ۲.۵.۲۳ jsonlite

برای تبدیل JSON به ساختارهای داده R، ما بسته jsonlite را توسط Jeroen Ooms توصیه می‌کنیم. فقط از دو تابع jsonlite استفاده خواهیم کرد: `read_json()` و `parse_json()`. در زندگی واقعی، از `read_json()` برای خواندن یک فایل JSON از دیسک استفاده خواهید کرد. به عنوان مثال، بسته repurrsive همچنین منبع `gh_user` را به عنوان یک فایل JSON فراهم می‌کند و می‌توانید آن را با `read_json()` بخوانید:

```{r}
# مسیری به یک فایل json درون بسته:
gh_users_json()

# آن را با read_json() بخوانید
gh_users2 <- read_json(gh_users_json())

# بررسی کنید که یکسان با داده‌ای است که قبلاً استفاده می‌کردیم
identical(gh_users, gh_users2)
```

در این کتاب، همچنین از `parse_json()` استفاده خواهیم کرد، زیرا یک رشته حاوی JSON را می‌گیرد که آن را برای تولید مثال‌های ساده خوب می‌کند. برای شروع، در اینجا سه مجموعه داده ساده JSON آورده شده است، با شروع از یک عدد، سپس قرار دادن چند عدد در یک آرایه، سپس قرار دادن آن آرایه در یک شیء:

```{r}
str(parse_json('1'))
str(parse_json('[1, 2, 3]'))
str(parse_json('{"x": [1, 2, 3]}'))
```

jsonlite یک تابع مهم دیگر به نام `fromJSON()` دارد. ما اینجا از آن استفاده نمی‌کنیم زیرا ساده‌سازی خودکار (`simplifyVector = TRUE`) را انجام می‌دهد. این اغلب به خوبی کار می‌کند، به ویژه در موارد ساده، اما ما فکر می‌کنیم بهتر است مستطیل‌سازی را خودتان انجام دهید تا بدانید دقیقاً چه اتفاقی می‌افتد و بتوانید به راحتی پیچیده‌ترین ساختارهای تو در تو را مدیریت کنید.

### ۳.۵.۲۳ شروع فرآیند مستطیل‌سازی

در بیشتر موارد، فایل‌های JSON حاوی یک آرایه سطح بالای واحد هستند، زیرا برای ارائه داده‌هایی درباره چندین "چیز" طراحی شده‌اند، مثلاً چندین صفحه، یا چندین رکورد، یا چندین نتیجه. در این مورد، مستطیل‌سازی خود را با `tibble(json)` شروع خواهید کرد تا هر عنصر یک سطر شود:

```{r}
json <- '[
  {"name": "John", "age": 34},
  {"name": "Susan", "age": 27}
]'
df <- tibble(json = parse_json(json))
df

df |> 
  unnest_wider(json)
```

در موارد نادرتر، فایل JSON از یک شیء JSON سطح بالای واحد تشکیل شده است که یک "چیز" را نمایش می‌دهد. در این مورد، باید فرآیند مستطیل‌سازی را با پیچیدن آن در یک لیست، قبل از قرار دادن آن در یک tibble، شروع کنید.

```{r}
json <- '{
  "status": "OK", 
  "results": [
    {"name": "John", "age": 34},
    {"name": "Susan", "age": 27}
 ]
}
'
df <- tibble(json = list(parse_json(json)))
df

df |> 
  unnest_wider(json) |> 
  unnest_longer(results) |> 
  unnest_wider(results)
```

به طور جایگزین، می‌توانید به داخل JSON تجزیه شده بروید و با بخشی که واقعاً به آن اهمیت می‌دهید شروع کنید:

```{r}
df <- tibble(results = parse_json(json)$results)
df |> 
  unnest_wider(results)
```

### ۴.۵.۲۳ تمرین‌ها

۱. `df_col` و `df_row` زیر را مستطیل کنید. آن‌ها دو روش کدگذاری یک data frame در JSON را نمایش می‌دهند.

```{r}
json_col <- parse_json('
  {
    "x": ["a", "x", "z"],
    "y": [10, null, 3]
  }
')
json_row <- parse_json('
  [
    {"x": "a", "y": 10},
    {"x": "x", "y": null},
    {"x": "z", "y": 3}
  ]
')

df_col <- tibble(json = list(json_col)) 
df_row <- tibble(json = json_row)
```

## ۶.۲۳ خلاصه

در این فصل، یاد گرفتید که لیست‌ها چه هستند، چگونه می‌توانید آن‌ها را از فایل‌های JSON تولید کنید، و چگونه آن‌ها را به data frame های مستطیلی تبدیل کنید. شگفت‌انگیز است که فقط به دو تابع جدید نیاز داریم: `unnest_longer()` برای قرار دادن عناصر لیست در سطرها و `unnest_wider()` برای قرار دادن عناصر لیست در ستون‌ها. مهم نیست که ستون لیستی چقدر عمیقاً تو در تو است؛ تنها کاری که باید انجام دهید فراخوانی مکرر این دو تابع است.

JSON رایج‌ترین فرمت داده بازگردانده شده توسط API های وب است. اگر وب‌سایت API نداشته باشد، اما بتوانید داده‌ای را که می‌خواهید در وب‌سایت ببینید چه اتفاقی می‌افتد؟ سپس باید از web scraping استفاده کنید، موضوع فصل بعدی.
