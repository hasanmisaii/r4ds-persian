# ۱۵ عبارات منظم

## ۱.۱۵ مقدمه

عبارات منظم (Regular Expressions) یک زبان مختصر و قدرتمند برای توصیف الگوها در رشته‌ها هستند. آن‌ها کمی ترسناک به نظر می‌رسند زیرا بسیار فشرده هستند و به‌طور معمول زمانی که برای اولین بار آن‌ها را می‌بینید، معنای واضحی ندارند. اما با تمرین، این الگوها برای شما طبیعی خواهند شد و قادر خواهید بود از آن‌ها برای حل طیف گسترده‌ای از مشکلات استفاده کنید.

در R، بستهٔ stringr (بخشی از tidyverse) رابط ساده و ثابتی برای کار با رشته‌ها فراهم می‌کند. stringr از موتور عبارات منظم ICU استفاده می‌کند که در اغلب سیستم‌ها سازگار و قابل‌اتکا است.

در این فصل با مبانی عبارات منظم در R آشنا می‌شوید: نحوهٔ ساخت الگوهای ساده، کلاس‌های کاراکتر، کمّیت‌ها (quantifiers)، گروه‌بندی و ارجاع‌های عقبی (backreferences)، لنگرها (anchors)، تشخیص و شمارش مطابقت‌ها، استخراج داده با و بدون گروه‌های نام‌دار، جایگزینی و تقسیم رشته، و در پایان نحوهٔ تنظیم جزئیات الگو با regex()، fixed()، coll() و boundary().
هدف این فصل یادگیری عبارات منظم در R است. ما با مبانی شروع می‌کنیم و به تدریج الگوهای پیچیده‌تر را می‌سازیم. این یک فصل طولانی است، اما هر بخش با مثال‌های متعدد همراه است تا به شما در درک مفاهیم کمک کند.


### ۱.۱.۱۵ پیش‌نیازها

در این فصل، از توابع عبارات منظم از بستهٔ stringr استفاده خواهیم کرد. همچنین از داده‌های نمونه برای نشان دادن نحوهٔ کار الگوها بهره می‌بریم.

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(stringr)
```

## ۲.۱۵ الگوی اولیه

ساده‌ترین الگو یک متن ساده است که باید عیناً در رشته ظاهر شود. برای بررسی وجود یک الگو از str_detect() و برای زیرمجموعه‌گیری از str_subset() استفاده می‌کنیم.

```{r}
x <- c("apple", "banana", "pear", "pineapple")

str_detect(x, "apple")
str_subset(x, "apple")
```

- الگوهای متن-ساده حساس به بزرگی/کوچکی حروف‌اند مگر این‌که خلافش را مشخص کنید.
- اگر می‌خواهید «apple» را فقط به‌عنوان یک واژهٔ کامل بیابید (نه به‌صورت زیررشته‌ای)، از مرز واژه (word boundary) استفاده کنید: `\\bapple\\b`.

```{r}
str_detect(x, "\\bapple\\b")
str_subset(x, "\\bapple\\b")
```

برای دیدن محل دقیق تطابق در رشته‌ها از str_view() و str_view_all() استفاده کنید. این توابع در محیط‌های تعاملی مفیدند و نتایج را به‌صورت هایلایت‌شده نمایش می‌دهند.

```{r}
str_view(x, "apple")
str_view_all(x, "a")
```

نکتهٔ مهم: چون در R برای نمایش بک‌اسلش در رشته‌ها نیاز به escape داریم، در الگوها اغلب از `\\` استفاده می‌شود (مثلاً `\\b`, `\\d`, ...).

## ۳.۱۵ کاراکترهای کلیدی (متاکاراکترها)

برخی کاراکترها معنای ویژه‌ای در عبارات منظم دارند و باید یا از آن‌ها آگاه باشید یا در صورت نیاز به معنای «متنی»شان، آن‌ها را escape کنید.

- نقطه `.`: با هر کاراکتر (به‌جز خط‌جدید) مطابقت می‌دهد.
- بک‌اسلش `\`: کاراکتر escape است و معنی ویژه می‌دهد (در R باید «دوتایی» نوشته شود: `\\`).
- کروشه‌ها `[]`: برای تعریف کلاس کاراکترها هستند.
- پرانتزها `()`: برای گروه‌بندی و گرفتن زیررشتهٔ capture.
- آکولادها `{}`: برای تعیین تعداد تکرار (quantifier).
- علامت جمع `+`، ستاره `*`، پرسش `?`: کمّیت‌دهنده‌ها.
- عمود `|`: یا (alternation).
- کَرَت `^` و دلار `$`: لنگر آغاز و پایان رشته.

اگر یکی از این کاراکترها را به‌صورت متنی بخواهید، باید آن را escape کنید:

```{r}
str_view(c("a.b", "a?b", "a*b"), "a\\.b")
str_view(c("a.b", "a?b", "a*b"), "a\\?b")
str_view(c("a.b", "a?b", "a*b"), "a\\*b")
```

نقطه `.` بسیار مفید است اما به یاد داشته باشید حریص (greedy) نیست؛ نقطه فقط یک کاراکتر را می‌گیرد. حریص‌بودن مربوط به کمّیت‌دهنده‌هاست که در ادامه می‌آید.

## ۴.۱۵ کلاس‌های کاراکتر

کلاس کاراکتر مجموعه‌ای از کاراکترهای مجاز در یک موقعیت از الگو است.

- کروشه‌ها: `[abc]` یکی از a یا b یا c.
- بازه‌ها: `[a-z]`, `[A-Z]`, `[0-9]`.
- نفی: `[^abc]` هر چیزی به‌جز a/b/c.

```{r}
str_view(c("cat", "cut", "cot", "cit"), "c[aeiou]t")
str_view(c("Room 101", "Room A12", "Room X"), "Room [A-Z0-9]+")
str_view(c("abc", "a1c", "a-c"), "a[^0-9]c")
```

کلاس‌های از پیش‌ساخته:

- `\\d` رقم (digit)؛ `\\D` غیرِرقم
- `\\s` فاصلهٔ سفید (space/tab/newline)؛ `\\S` غیرِسفید
- `\\w` کاراکتر «کلمه» (حروف لاتین، رقم، آندرلاین)؛ `\\W` غیرِکلمه
- مرز واژه: `\\b`، و «غیرمرز»: `\\B`

```{r}
str_view(c("x9", "x_", "x-"), "x\\w")
str_view(c("a b", "ab", "a-b"), "\\bab\\b")
```

نکته: تعریف `\\w` محدود به الفبای لاتین/ارقام و آندرلاین است. برای زبان‌ها/اسکریپت‌های دیگر باید کلاس‌های صریح‌تری بسازید (مثلاً بازه‌های یونیکد یا استفاده از coll()).

## ۵.۱۵ کمّیت‌دهنده‌ها (Quantifiers)

کمّیت‌دهنده‌ها تعیین می‌کنند یک الگو چند بار تکرار می‌شود:

- `?` صفر یا یک بار
- `*` صفر یا بیشتر
- `+` یک یا بیشتر
- `{n}` دقیقاً n بار
- `{n,}` حداقل n بار
- `{n,m}` بین n تا m بار

```{r}
str_view(c("color", "colour", "colouur"), "colou?r")
str_view(c("aa", "a", ""), "a*")
str_view(c("a", "aa", "aaa"), "a{2,3}")
```

حریص (greedy) در برابر کاهل/تنبل (lazy):

- به‌صورت پیش‌فرض، کمّیت‌دهنده‌ها حریص‌اند: بیشترین کاراکتر ممکن را می‌گیرند.
- با افزودن `?` پس از کمّیت‌دهنده، آن را کاهل (lazy) می‌کنید: کمترین مقدار ممکن.

```{r}
x <- "<tag>value</tag><tag>v2</tag>"

# حریص: از اولین <tag> تا آخرین </tag>
str_view(x, "<tag>.*</tag>")

# کاهل: کمترین تطابق‌های مجزا
str_view_all(x, "<tag>.*?</tag>")
```

بسیاری از موتورهای ICU همچنین کمّیت‌دهنده‌های «تملیکی/ملکی» (possessive) را پشتیبانی می‌کنند (مانند `*+`, `++`, `?+`, `{n,m}+`) که backtracking را ممنوع می‌کنند. این‌ها در الگوهای پیچیده برای بهبود کارایی مفیدند، اما در کارهای روزمره به‌ندرت لازم می‌شوند.

## ۶.۱۵ گروه‌بندی و ارجاع‌های عقبی

پرانتزها `()` برای دو منظور استفاده می‌شوند:

- گروه‌بندی: تغییر دامنهٔ یک کمّیت‌دهنده یا اولویت عملگر `|`.
- گرفتن (capture): استخراج زیررشتهٔ منطبق برای استفادهٔ بعدی (در خروجی یا در جایگزینی).

```{r}
# گروه‌بندی برای کمّیت‌دهنده
str_view("lolol", "(lo)+l")

# یا (alternation)
str_view(c("gray", "grey", "graay"), "gr(a|e)y")
```

برای گرفتنِ گروه‌ها و استخراج آن‌ها:

- str_match(): اولین تطابق را برمی‌گرداند و ستون‌هایی برای هر گروه capture دارد.
- str_match_all(): همهٔ تطابق‌ها را بازمی‌گرداند.
- str_extract(): فقط کل تطابق را بازمی‌گرداند (بدون گروه‌ها).

```{r}
x <- c("Name: Ali, Age: 30", "Name: Sara, Age: 27")

m <- str_match(x, "Name:\\s*([A-Za-z]+),\\s*Age:\\s*(\\d+)")
m
colnames(m) <- c("match", "name", "age")
m
```

ارجاع عقبی (Backreference) به گروه‌های قبلی با `\\1`, `\\2`, ... (در رشتهٔ R باید دو بک‌اسلش بنویسید) انجام می‌شود:

```{r}
# واژهٔ تکرارشونده: "bye bye", "no no", ...
str_view(c("bye bye", "no no", "why"), "\\b(\\w+)\\s+\\1\\b")
```

گروه غیرقابل‌گرفتن (non-capturing) با `(?: ...)` تعریف می‌شود، وقتی فقط برای گروه‌بندی (و نه استخراج) نیاز دارید:

```{r}
str_view_all(c("gray", "grey"), "gr(?:a|e)y")
```

## ۷.۱۵ لنگرها (Anchors)

- `^` آغاز رشته
- `$` پایان رشته
- `\\b` مرز واژه
- `\\B` غیرمرز واژه

```{r}
x <- c("start here", "in the start middle", "here end")
str_view(x, "^start")
str_view(x, "end$")
```

اگر می‌خواهید `^` و `$` آغاز/پایان «هر خط» را هدف بگیرید (و نه کل رشته)، حالت چندخطی (multiline) را فعال کنید. در stringr می‌توانید از regex(..., multiline = TRUE) استفاده کنید یا پرچم `(?m)` را در الگو بگنجانید.

```{r}
txt <- "alpha\nbeta\ngamma"
str_view_all(txt, regex("^\\w+", multiline = TRUE))
```

## ۸.۱۵ تشخیص و شمارش مطابقت‌ها

- str_detect(x, pattern): وجود حداقل یک تطابق
- str_count(x, pattern): تعداد تطابق‌ها
- str_which(x, pattern): اندیس عناصر منطبق
- str_subset(x, pattern): زیرمجموعهٔ عناصر منطبق

```{r}
x <- c("abc", "a1b2c3", "123")

str_detect(x, "\\d")
str_count(x, "\\d")
str_which(x, "\\d")
str_subset(x, "\\d")
```

برای بررسی چند الگو روی یک بردار، می‌توانید از mutate و across یا map استفاده کنید.

```{r}
patterns <- c("digit" = "\\d", "word" = "\\w+")

tibble(x) |>
  mutate(
    digits = str_count(x, patterns["digit"]),
    words  = str_count(x, patterns["word"])
  )
```

## ۹.۱۵ استخراج داده

- str_extract(x, pattern): اولین تطابق
- str_extract_all(x, pattern): همهٔ تطابق‌ها (لیستی)
- str_match(x, pattern): اولین تطابق به‌همراه گروه‌ها (ماتریس)
- str_match_all(x, pattern): همهٔ تطابق‌ها به‌همراه گروه‌ها (لیستِ ماتریس‌ها)

```{r}
x <- c("Item A (10)", "Item B (5)", "Item C (12)")

str_extract(x, "\\d+")
str_extract_all(x, "\\w+")
str_match(x, "([A-Z])\\w+\\s*\\((\\d+)\\)")
```

برای کار با دادهٔ جدولی، اغلب tidyr::extract سودمند است که گروه‌ها را مستقیماً به ستون‌های جدید می‌ریزد:

```{r}
library(tidyr)

tbl <- tibble(line = x)

tbl |>
  extract(
    line,
    into = c("item", "qty"),
    regex = "Item\\s+([A-Z]).*\\((\\d+)\\)",
    convert = TRUE
  )
```

## ۱۰.۱۵ گروه‌های با نام‌گذاری (Named groups)

در بسیاری از موتورها، از جمله ICU، می‌توانید گروه‌ها را نام‌گذاری کنید تا خروجی خواناتر شود. نحو رایج: `(?<name>...)`.

```{r}
x <- "Name: Ali, Age: 30"

m <- str_match(x, "(?<label1>Name):\\s*(?<name>[A-Za-z]+),\\s*(?<label2>Age):\\s*(?<age>\\d+)")
m
colnames(m)
```

در stringr، نام گروه‌ها به‌عنوان نام ستون‌های ماتریس str_match برگردانده می‌شوند (ستون اول همیشه کل تطابق است و نام ندارد).

برای جایگزینی با ارجاع به گروه‌های نام‌دار می‌توانید از `\\k<name>` در replacement استفاده کنید، یا راحت‌تر: از جایگزینِ تابعی استفاده کنید تا مستقیماً با مقادیر کار کنید (در بخش جایگزینی ببینید).

## ۱۱.۱۵ جایگزینی

- str_replace(x, pattern, replacement): جایگزینی اولین تطابق
- str_replace_all(x, pattern, replacement): جایگزینی همهٔ تطابق‌ها
- str_remove / str_remove_all: معادل جایگزینی با replacement = ""

در replacement می‌توانید از ارجاع به گروه‌ها استفاده کنید: `\\1`, `\\2`, ... یا `\\k<name>` (در صورت پشتیبانی).

```{r}
x <- c("2024-07-15", "1999-12-31")

# سال-ماه-روز -> روز/ماه/سال
str_replace(x, "(\\d{4})-(\\d{2})-(\\d{2})", "\\3/\\2/\\1")
```

Replacement تابعی: اگر replacement یک تابع باشد، stringr بردارِ تطابق‌ها را به آن پاس می‌دهد و خروجی تابع جایگزین می‌شود. این روش برای استفاده از گروه‌های نام‌دار بسیار تمیز است.

```{r}
x <- c("X:10,Y:20", "X:3,Y:4")

pattern <- "(?<x>\\d+),(?:Y:)?(?<y>\\d+)$"

str_replace(x, pattern, function(m) {
  # m یک ماتریس مانند str_match است
  xy <- as.integer(m[, c("x", "y"), drop = TRUE])
  as.character(xy["x"] + xy["y"])
})
```

```{r}
str_remove_all("a1 b2 c3", "\\d")
```

## ۱۲.۱۵ تقسیم

- str_split(x, pattern): تقسیم بر اساس الگو؛ خروجی لیستی از بردارها
- str_split_1(x, pattern): برای یک رشتهٔ منفرد؛ خروجی بردار
- str_split_fixed(x, pattern, n): دقیقاً n ستون بازمی‌گرداند (پر کردن با NA در صورت نیاز)

```{r}
str_split(c("a,b,c", "d,e", "f"), ",")
str_split_1("a b   c", "\\s+")
str_split_fixed(c("a|b|c", "d|e"), "\\|", 3)
```

نکته: برای تقسیم بر مرزهای واژه/جمله/کاراکتر یونیکد از boundary() استفاده کنید (بخش جزئیات الگو).

## ۱۳.۱۵ جزئیات الگو

stringr چند سازنده برای الگو دارد که رفتار موتور را تنظیم می‌کنند:

- regex(pattern, ...): الگوی عبارات منظم با پرچم‌ها
  - ignore_case = TRUE: نادیده‌گرفتن بزرگی/کوچکی
  - multiline = TRUE: `^` و `$` برای هر خط
  - comments = TRUE: چشم‌پوشی از فاصله‌های سفید و اجازهٔ کامنت با `#`
  - dotall = TRUE: اجازهٔ `.` برای تطبیق خط‌جدید
- fixed(pattern): تطبیق متن-ساده (بدون regex) سریع و امن
- coll(pattern, ...): تطبیق متنی با قوانین محلی (locale-sensitive) برای ترتیب/برابری
- boundary(type = c("character", "word", "line_break", "sentence")): مرزهای متنی یونیکد

نمونه‌ها:

```{r}
x <- c("Apple", "APPLE", "banana")

str_detect(x, regex("apple", ignore_case = TRUE))
str_split_1("a\nb\nc", regex("$", multiline = TRUE))

# حالت توضیحی (comments=TRUE) برای الگوهای خوانا
pat <- regex("
  ^                # آغاز رشته
  (?<user>\\w+)    # نام کاربری
  @
  (?<host>[\\w.]+) # میزبان/دامنه
  $                # پایان
", comments = TRUE)

str_match(c("hasan@site.com", "bad@host@x"), pat)

# تطبیق متنی ساده و ایمن (بدون تفسیر regex)
str_detect("a.b", fixed("a.b"))

# مرز واژه/جمله
txt <- "This is a sentence. And another one!"
str_split_1(txt, boundary("word"))
```

پرچم‌های درون‌خطی: بسیاری از این تنظیمات را می‌توانید مستقیم در الگو فعال کنید، مثلاً `(?i)` برای ignore_case، `(?m)` برای multiline، `(?s)` برای dotall، و `(?x)` برای comments. مثال:

```{r}
str_detect(c("A", "a"), "(?i)a")
```

## ۱۴.۱۵ تمرین‌ها

- با استفاده از str_view_all نشان دهید که الگوهای زیر دقیقاً چه چیزهایی را در رشتهٔ `"abc ABC 123_-"` می‌گیرند:
  - `\\w+`
  - `\\W+`
  - `\\d+`
  - `\\s+`
- یک الگو بنویسید که تاریخ‌های قالب `YYYY-MM-DD` را بیابد و سال، ماه و روز را به‌صورت سه گروه capture کند.
- یک الگو برای ایمیل ساده بسازید که نام کاربریِ شامل حروف، اعداد، نقطه و آندرلاین و دامنهٔ سادهٔ شامل حروف/نقطه را بپذیرد. سپس با str_match گروه‌های نام‌دار user و host را استخراج کنید.
- برای رشتهٔ `"<p>one</p><p>two</p><p>three</p>"` تفاوت `<p>.*</p>` و `<p>.*?</p>` را با str_view_all نشان دهید.
- با استفاده از str_replace_all و گروه‌های capture، رشتهٔ `"Last, First"` را به `"First Last"` تبدیل کنید.
- با boundary("word") تعداد واژه‌های جملهٔ `"R is a free software environment for statistical computing."` را بشمارید.

## ۱۵.۱۵ خلاصه

- stringr با موتور ICU رابطی پایدار برای عبارات منظم در R فراهم می‌کند.
- کار با regex از چند ستون اصلی تشکیل می‌شود: کاراکترهای خاص، کلاس‌های کاراکتر، کمّیت‌دهنده‌ها، گروه‌بندی/ارجاع عقبی، لنگرها.
- برای کار عملی:
  - تشخیص/شمارش: str_detect، str_count
  - مشاهدهٔ تطابق‌ها: str_view، str_view_all
  - استخراج: str_extract(_all)، str_match(_all)، و tidyr::extract
  - جایگزینی/حذف: str_replace(_all)، str_remove(_all) با replacement متنی یا تابعی
  - تقسیم: str_split، str_split_1، str_split_fixed
- جزئیات الگو و رفتار موتور را با regex(), fixed(), coll(), boundary() کنترل کنید. از پرچم‌ها برای حساسیت به حروف، چندخطی، حالت توضیحی و dotall استفاده کنید.
- با تمرین و مشاهدهٔ نتایج (str_view) ذهنیت الگوها سریعاً شکل می‌گیرد؛ از کوچک شروع کنید و تدریجاً الگو را گسترش دهید.

```{r}
# جمع‌بندی کوچک با چند مثال
x <- c("Name: Ali, Age: 30", "Name: Sara, Age: 27")
str_match(x, "Name:\\s*([A-Za-z]+),\\s*Age:\\s*(\\d+)") |>
  as_tibble(.name_repair = "minimal") |>
  set_names(c("match", "name", "age"))

str_replace("2025-10-15", "(\\d{4})-(\\d{2})-(\\d{2})", "\\3/\\2/\\1")
str_split_1("a,b,c", ",")
str_count(c("abc", "a1b2c3"), "\\d")
```
