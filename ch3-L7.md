# ۱۸ مقادیر گمشده

## ۱.۱۸ مقدمه

شما قبلاً مبانی مقادیر گمشده را در بخش‌های قبلی کتاب یاد گرفته‌اید. اولین بار آن‌ها را در فصل ۱ دیدید که منجر به یک هشدار هنگام ایجاد نمودار شدند و همچنین در بخش ۳.۵.۲ که در محاسبه آمارهای خلاصه اختلال ایجاد کردند، و در بخش ۱۲.۲.۲ درباره ماهیت عفونی آن‌ها و نحوه بررسی وجود آن‌ها یاد گرفتید. اکنون به طور عمیق‌تری به آن‌ها بازمی‌گردیم تا بتوانید جزئیات بیشتری بیاموزید.

ما با بحث درباره برخی ابزارهای کلی برای کار با مقادیر گمشده ثبت شده به عنوان `NA` شروع خواهیم کرد. سپس ایده مقادیر گمشده ضمنی را بررسی خواهیم کرد، مقادیری که به سادگی از داده‌های شما غایب هستند، و برخی ابزارهایی را که می‌توانید برای صریح کردن آن‌ها استفاده کنید نشان خواهیم داد. با بحثی مرتبط درباره گروه‌های خالی که توسط سطوح فاکتوری که در داده‌ها ظاهر نمی‌شوند ایجاد می‌شوند، به پایان خواهیم رسید.

### ۱.۱.۱۸ پیش‌نیازها

توابع برای کار با داده‌های گمشده عمدتاً از dplyr و tidyr می‌آیند که اعضای اصلی tidyverse هستند.

```{r}
library(tidyverse)
```

## ۲.۱۸ مقادیر گمشده صریح

برای شروع، بیایید چند ابزار مفید برای ایجاد یا حذف مقادیر گمشده صریح را بررسی کنیم، یعنی سلول‌هایی که در آن‌ها یک `NA` می‌بینید.

### ۱.۲.۱۸ انتقال آخرین مشاهده به جلو

یک استفاده رایج برای مقادیر گمشده به عنوان یک راحتی در ورود داده است. وقتی داده‌ها به صورت دستی وارد می‌شوند، مقادیر گمشده گاهی اوقات نشان می‌دهند که مقدار در ردیف قبلی تکرار شده است (یا به جلو منتقل شده است):

```{r}
treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)
```

می‌توانید این مقادیر گمشده را با `tidyr::fill()` پر کنید. این مانند `select()` کار می‌کند و مجموعه‌ای از ستون‌ها را می‌گیرد:

```{r}
treatment |> 
  fill(everything())
#> # A tibble: 4 × 3
#>   person           treatment response
#>   <chr>                <dbl>    <dbl>
#> 1 Derrick Whitmore         1        7
#> 2 Derrick Whitmore         2       10
#> 3 Derrick Whitmore         3       10
#> 4 Katherine Burke          1        4
```

این روش گاهی اوقات "انتقال آخرین مشاهده به جلو" نامیده می‌شود، یا به اختصار **locf**. می‌توانید از آرگومان `.direction` برای پر کردن مقادیر گمشده‌ای که به روش‌های عجیب‌تری تولید شده‌اند استفاده کنید.

### ۲.۲.۱۸ مقادیر ثابت

گاهی اوقات مقادیر گمشده یک مقدار ثابت و شناخته شده را نمایش می‌دهند، که معمولاً 0 است. می‌توانید از `dplyr::coalesce()` برای جایگزینی آن‌ها استفاده کنید:

```{r}
x <- c(1, 4, 5, 7, NA)
coalesce(x, 0)
#> [1] 1 4 5 7 0
```

گاهی اوقات با مشکل مخالف مواجه می‌شوید، جایی که یک مقدار مشخص در واقع نمایانگر یک مقدار گمشده است. این معمولاً در داده‌هایی که توسط نرم‌افزار قدیمی‌تر تولید شده‌اند رخ می‌دهد که روش مناسبی برای نمایش مقادیر گمشده ندارند، بنابراین باید به جای آن از یک مقدار خاص مانند 99 یا -999 استفاده کنند.

در صورت امکان، این مورد را هنگام خواندن داده‌ها مدیریت کنید، به عنوان مثال، با استفاده از آرگومان `na` در `readr::read_csv()`، مثلاً `read_csv(path, na = "99")`. اگر بعداً مشکل را کشف کردید، یا منبع داده شما راهی برای مدیریت آن در هنگام خواندن ارائه نمی‌دهد، می‌توانید از `dplyr::na_if()` استفاده کنید:

```{r}
x <- c(1, 4, 5, 7, -99)
na_if(x, -99)
#> [1]  1  4  5  7 NA
```

### ۳.۲.۱۸ NaN

قبل از ادامه، یک نوع خاص از مقدار گمشده وجود دارد که هر از گاهی با آن مواجه خواهید شد: `NaN` (تلفظ می‌شود "نن")، یا **n**ot **a** **n**umber (عددی نیست). دانستن آن چندان مهم نیست زیرا به طور کلی دقیقاً مانند `NA` رفتار می‌کند:

```{r}
x <- c(NA, NaN)
x * 10
#> [1]  NA NaN
x == 1
#> [1] NA NA
is.na(x)
#> [1] TRUE TRUE
```

در موارد نادری که نیاز دارید یک `NA` را از یک `NaN` تمیز دهید، می‌توانید از `is.nan(x)` استفاده کنید.

به طور کلی زمانی با یک `NaN` مواجه می‌شوید که یک عملیات ریاضی انجام می‌دهید که نتیجه نامشخصی دارد:

```{r}
0 / 0
#> [1] NaN
0 * Inf
#> [1] NaN
Inf - Inf
#> [1] NaN
sqrt(-1)
#> Warning in sqrt(-1): NaNs produced
#> [1] NaN
```

## ۳.۱۸ مقادیر گمشده ضمنی

تا اینجا درباره مقادیرگمشده‌ای صحبت کردیم که **صریحاً** گمشده هستند، یعنی می‌توانید یک `NA` را در داده‌های خود ببینید. اما مقادیر گمشده همچنین می‌توانند **ضمنی** باشند، اگر یک ردیف کامل از داده‌ها به سادگی از داده‌ها غایب باشد. بیایید تفاوت را با یک مجموعه داده ساده که قیمت برخی سهام را در هر سه ماهه ثبت می‌کند نشان دهیم:

```{r}
stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

این مجموعه داده دو مشاهده گمشده دارد:

- `price` در سه ماهه چهارم سال 2020 به صراحت گمشده است، زیرا مقدار آن `NA` است.

- `price` برای سه ماهه اول سال 2021 به صورت ضمنی گمشده است، زیرا به سادگی در مجموعه داده ظاهر نمی‌شود.

یک راه برای فکر کردن درباره تفاوت این است با این کوآن ذن‌مانند:

یک مقدار گمشده صریح حضور یک غیبت است.

یک مقدار گمشده ضمنی غیبت یک حضور است.

گاهی اوقات می‌خواهید مقادیر گمشده ضمنی را صریح کنید تا چیزی فیزیکی برای کار داشته باشید. در موارد دیگر، مقادیر گمشده صریح با ساختار داده‌ها به شما تحمیل می‌شوند و می‌خواهید از شر آن‌ها خلاص شوید. بخش‌های زیر برخی ابزارها را برای حرکت بین گمشدگی ضمنی و صریح مورد بحث قرار می‌دهند.

### ۱.۳.۱۸ محوری کردن

قبلاً یک ابزار را دیده‌اید که می‌تواند مقادیر گمشده ضمنی را صریح کند و بالعکس: محوری کردن. گسترده‌تر کردن داده‌ها می‌تواند مقادیر گمشده ضمنی را صریح کند زیرا هر ترکیب از ردیف‌ها و ستون‌های جدید باید مقداری داشته باشد. به عنوان مثال، اگر `stocks` را محوری کنیم تا `quarter` را در ستون‌ها قرار دهیم، هر دو مقدار گمشده صریح می‌شوند:

```{r}
stocks |> 
  pivot_wider(
    names_from = qtr, 
    values_from = price
  )
#> # A tibble: 2 × 5
#>    year   `1`   `2`   `3`   `4`
#>   <dbl> <dbl> <dbl> <dbl> <dbl>
#> 1  2020  1.88  0.59  0.35 NA   
#> 2  2021 NA     0.92  0.17  2.66
```

به طور پیش‌فرض، بلندتر کردن داده‌ها مقادیر گمشده صریح را حفظ می‌کند، اما اگر آن‌ها مقادیر گمشده ساختاری هستند که فقط به این دلیل وجود دارند که داده‌ها مرتب نیستند، می‌توانید آن‌ها را حذف کنید (ضمنی کنید) با تنظیم `values_drop_na = TRUE`. مثال‌ها را در بخش ۵.۲ برای جزئیات بیشتر ببینید.

### ۲.۳.۱۸ تکمیل

`tidyr::complete()` به شما اجازه می‌دهد با ارائه مجموعه‌ای از متغیرها که ترکیب ردیف‌هایی را که باید وجود داشته باشند تعریف می‌کنند، مقادیر گمشده صریح تولید کنید. به عنوان مثال، ما می‌دانیم که همه ترکیبات `year` و `qtr` باید در داده `stocks` وجود داشته باشند:

```{r}
stocks |> 
  complete(year, qtr)
#> # A tibble: 8 × 3
#>    year   qtr price
#>   <dbl> <dbl> <dbl>
#> 1  2020     1  1.88
#> 2  2020     2  0.59
#> 3  2020     3  0.35
#> 4  2020     4 NA   
#> 5  2021     1 NA   
#> 6  2021     2  0.92
#> # ℹ 2 more rows
```

معمولاً، شما `complete()` را با نام‌های متغیرهای موجود فراخوانی می‌کنید و ترکیبات گمشده را پر می‌کنید. با این حال، گاهی اوقات خود متغیرهای فردی ناقص هستند، بنابراین می‌توانید به جای آن داده‌های خود را ارائه دهید. به عنوان مثال، ممکن است بدانید که مجموعه داده `stocks` قرار است از 2019 تا 2021 اجرا شود، بنابراین می‌توانید آن مقادیر را به صراحت برای `year` ارائه دهید:

```{r}
stocks |> 
  complete(year = 2019:2021, qtr)
#> # A tibble: 12 × 3
#>    year   qtr price
#>   <dbl> <dbl> <dbl>
#> 1  2019     1 NA   
#> 2  2019     2 NA   
#> 3  2019     3 NA   
#> 4  2019     4 NA   
#> 5  2020     1  1.88
#> 6  2020     2  0.59
#> # ℹ 6 more rows
```

اگر محدوده یک متغیر صحیح است، اما همه مقادیر موجود نیستند، می‌توانید از `full_seq(x, 1)` برای تولید همه مقادیر از `min(x)` تا `max(x)` با فاصله 1 استفاده کنید.

در برخی موارد، مجموعه کامل مشاهدات را نمی‌توان با یک ترکیب ساده از متغیرها تولید کرد. در آن صورت، می‌توانید به صورت دستی کاری را که `complete()` برای شما انجام می‌دهد انجام دهید: یک دیتافریم ایجاد کنید که شامل همه ردیف‌هایی که باید وجود داشته باشند باشد (با استفاده از هر ترکیبی از تکنیک‌هایی که نیاز دارید)، سپس آن را با مجموعه داده اصلی خود با `dplyr::full_join()` ترکیب کنید.

### ۳.۳.۱۸ اتصال‌ها

این ما را به روش مهم دیگری برای آشکار کردن مشاهدات گمشده ضمنی می‌رساند: اتصال‌ها. در فصل ۱۹ بیشتر درباره اتصال‌ها یاد خواهید گرفت، اما می‌خواستیم به سرعت آن‌ها را اینجا به شما ذکر کنیم زیرا اغلب فقط می‌توانید بدانید که مقادیر از یک مجموعه داده گمشده هستند وقتی آن را با مجموعه داده دیگری مقایسه می‌کنید.

`dplyr::anti_join(x, y)` ابزار به خصوص مفیدی در اینجا است زیرا فقط ردیف‌های `x` را که تطابقی در `y` ندارند انتخاب می‌کند. به عنوان مثال، می‌توانیم از دو `anti_join()` استفاده کنیم تا آشکار کنیم که اطلاعات مربوط به چهار فرودگاه و 722 هواپیما که در `flights` ذکر شده‌اند را نداریم:

```{r}
library(nycflights13)

flights |> 
  distinct(faa = dest) |> 
  anti_join(airports)
#> Joining with `by = join_by(faa)`
#> # A tibble: 4 × 1
#>   faa  
#>   <chr>
#> 1 BQN  
#> 2 SJU  
#> 3 STT  
#> 4 PSE

flights |> 
  distinct(tailnum) |> 
  anti_join(planes)
#> Joining with `by = join_by(tailnum)`
#> # A tibble: 722 × 1
#>   tailnum
#>   <chr>  
#> 1 N3ALAA 
#> 2 N3DUAA 
#> 3 N542MQ 
#> 4 N730MQ 
#> 5 N9EAMQ 
#> 6 N532UA 
#> # ℹ 716 more rows
```

### ۴.۳.۱۸ تمرین‌ها

1. آیا می‌توانید رابطه‌ای بین حامل و ردیف‌هایی که به نظر می‌رسد از `planes` گمشده‌اند پیدا کنید؟

## ۴.۱۸ فاکتورها و گروه‌های خالی

یک نوع نهایی از گمشدگی، گروه خالی است، گروهی که هیچ مشاهده‌ای ندارد، که می‌تواند هنگام کار با فاکتورها پیش بیاید. به عنوان مثال، تصور کنید مجموعه داده‌ای داریم که حاوی برخی اطلاعات سلامتی درباره افراد است:

```{r}
health <- tibble(
  name   = c("Ikaia", "Oletta", "Leriah", "Dashay", "Tresaun"),
  smoker = factor(c("no", "no", "no", "no", "no"), levels = c("yes", "no")),
  age    = c(34, 88, 75, 47, 56),
)
```

و می‌خواهیم تعداد سیگاری‌ها را با `dplyr::count()` بشماریم:

```{r}
health |> count(smoker)
#> # A tibble: 1 × 2
#>   smoker     n
#>   <fct>  <int>
#> 1 no         5
```

این مجموعه داده فقط حاوی غیرسیگاری‌ها است، اما می‌دانیم که سیگاری‌ها وجود دارند؛ گروه غیرسیگاری‌ها خالی است. می‌توانیم از `count()` بخواهیم همه گروه‌ها را حفظ کند، حتی آن‌هایی که در داده‌ها دیده نمی‌شوند با استفاده از `.drop = FALSE`:

```{r}
health |> count(smoker, .drop = FALSE)
#> # A tibble: 2 × 2
#>   smoker     n
#>   <fct>  <int>
#> 1 yes        0
#> 2 no         5
```

همین اصل برای محورهای گسسته ggplot2 اعمال می‌شود، که همچنین سطوحی را که هیچ مقداری ندارند حذف می‌کند. می‌توانید با ارائه `drop = FALSE` به محور گسسته مناسب، آن‌ها را مجبور به نمایش کنید:

```{r}
ggplot(health, aes(x = smoker)) +
  geom_bar() +
  scale_x_discrete()

ggplot(health, aes(x = smoker)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)
```

همین مشکل به طور کلی‌تری با `dplyr::group_by()` پیش می‌آید. و دوباره می‌توانید از `.drop = FALSE` برای حفظ همه سطوح فاکتور استفاده کنید:

```{r}
health |> 
  group_by(smoker, .drop = FALSE) |> 
  summarize(
    n = n(),
    mean_age = mean(age),
    min_age = min(age),
    max_age = max(age),
    sd_age = sd(age)
  )
#> # A tibble: 2 × 6
#>   smoker     n mean_age min_age max_age sd_age
#>   <fct>  <int>    <dbl>   <dbl>   <dbl>  <dbl>
#> 1 yes        0      NaN     Inf    -Inf   NA  
#> 2 no         5       60      34      88   21.6
```

نتایج جالبی در اینجا می‌گیریم زیرا هنگام خلاصه‌سازی یک گروه خالی، توابع خلاصه به بردارهای با طول صفر اعمال می‌شوند. تفاوت مهمی بین بردارهای خالی، که طول 0 دارند، و مقادیر گمشده، که هر کدام طول 1 دارند، وجود دارد.

```{r}
# یک بردار حاوی دو مقدار گمشده
x1 <- c(NA, NA)
length(x1)
#> [1] 2

# یک بردار که چیزی ندارد
x2 <- numeric()
length(x2)
#> [1] 0
```

همه توابع خلاصه با بردارهای با طول صفر کار می‌کنند، اما ممکن است نتایجی را برگردانند که در نگاه اول تعجب‌آور هستند. در اینجا می‌بینیم که `mean(age)` مقدار `NaN` را برمی‌گرداند زیرا `mean(age)` = `sum(age)/length(age)` که در اینجا 0/0 است. `max()` و `min()` برای بردارهای خالی -Inf و Inf برمی‌گردانند، بنابراین اگر نتایج را با یک بردار غیرخالی از داده‌های جدید ترکیب کنید و دوباره محاسبه کنید، حداقل یا حداکثر داده‌های جدید را دریافت خواهید کرد.

گاهی اوقات یک رویکرد ساده‌تر این است که خلاصه را انجام دهید و سپس گمشدگی‌های ضمنی را با `complete()` صریح کنید.

```{r}
health |> 
  group_by(smoker) |> 
  summarize(
    n = n(),
    mean_age = mean(age),
    min_age = min(age),
    max_age = max(age),
    sd_age = sd(age)
  ) |> 
  complete(smoker)
#> # A tibble: 2 × 6
#>   smoker     n mean_age min_age max_age sd_age
#>   <fct>  <int>    <dbl>   <dbl>   <dbl>  <dbl>
#> 1 yes       NA       NA      NA      NA   NA  
#> 2 no         5       60      34      88   21.6
```

اشکال اصلی این رویکرد این است که یک `NA` برای شمارش دریافت می‌کنید، حتی اگر می‌دانید که باید صفر باشد.

## ۵.۱۸ خلاصه

مقادیر گمشده عجیب هستند! گاهی اوقات آن‌ها به عنوان یک `NA` صریح ثبت می‌شوند اما گاهی اوقات فقط با غیبت آن‌ها متوجه می‌شوید. این فصل برخی ابزارها برای کار با مقادیر گمشده صریح، ابزارهایی برای کشف مقادیر گمشده ضمنی، و برخی از راه‌هایی که ضمنی می‌تواند صریح شود و بالعکس را به شما داده است.

در فصل بعد، به آخرین فصل این بخش از کتاب می‌پردازیم: اتصال‌ها. این کمی تغییری نسبت به فصل‌های تا اینجا است زیرا قصد داریم درباره ابزارهایی بحث کنیم که با دیتافریم‌ها به عنوان یک کل کار می‌کنند، نه چیزی که داخل یک دیتافریم قرار می‌دهید.
