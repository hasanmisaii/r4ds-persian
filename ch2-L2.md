# ۲ تحلیل اکتشافی داده‌ها

## مقدمه

John Tukey یکی از اولین افرادی بود که تحلیل اکتشافی داده‌ها (Exploratory Data Analysis یا EDA) را به عنوان یک رویکرد رسمی در آمار معرفی کرد. EDA فرآیند بررسی، تجسم و خلاصه‌سازی داده‌ها برای درک بهتر آن‌ها و کشف الگوها، روابط و ناهنجاری‌هاست.

EDA یک چرخه تکراری است که در آن شما:

1. سؤالاتی درباره داده‌هایتان تولید می‌کنید.

2. پاسخ‌ها را با تجسم، تبدیل و مدل‌سازی داده‌هایتان جست‌وجو می‌کنید.

3. آنچه یاد گرفته‌اید را برای پالایش سؤالات خود یا تولید سؤالات جدید استفاده می‌کنید.

EDA یک فرآیند رسمی با مجموعه دقیقی از قوانین نیست. بیش از هر چیز، EDA حالت ذهنی است. در مراحل اولیه EDA، باید آزادانه هر ایده‌ای را که به ذهن‌تان می‌رسد بررسی کنید. برخی از این ایده‌ها موفق خواهند بود، و برخی راه‌های مسدود خواهند بود. همان‌طور که کاوش خود را ادامه می‌دهید، بر روی چند ناحیه پرثمر متمرکز می‌شوید که در نهایت برای درک و ارتباط با دیگران توسعه می‌دهید.

EDA بخش مهمی از هر تحلیل داده است، حتی اگر سؤالات به شما داده شده باشند، زیرا همیشه باید کیفیت داده‌هایتان را بررسی کنید. پاک‌سازی داده‌ها فقط یکی از کاربردهای EDA است: شما سؤالاتی درباره اینکه آیا داده‌هایتان انتظاراتتان را برآورده می‌کند یا خیر می‌پرسید. برای انجام پاک‌سازی داده‌ها، باید تمام مشکلات رایج کیفیت داده‌ها را تشخیص دهید.

### پیش‌نیازها

در این فصل، ترکیبی از سؤالات و تجسم برای کشف منظم داده‌هایتان استفاده خواهیم کرد. برای شروع، نیاز به بارگذاری tidyverse دارید:

```{r}
#| label: setup
#| message: false
library(tidyverse)
```

## سؤالات

> "بر اساس تجربه من، روش‌های آماری پیچیده و محاسبات فشرده مانند کامپیوتر کمتر مهم هستند تا... تولید سؤالات زیادی، ایجاد فضای ذهنی، و سپس نگاه کردن به تعداد زیادی نمودار." — John Tukey

هدف شما در طول EDA درک داده‌هایتان است. راه‌ترین راه برای این کار **پرسیدن سؤالات** است که شما را در مسیر کاوش راهنمایی کند. وقتی سؤال می‌پرسید، سؤال توجه شما را روی بخش خاصی از مجموعه داده‌تان متمرکز می‌کند و به شما کمک می‌کند تصمیم بگیرید که کدام متغیرها، مشاهدات، یا نوع تحلیل را بررسی کنید.

EDA اساساً یک فرآیند خلاقانه است. و مانند بیشتر فرآیندهای خلاقانه، کلید پرسیدن **سؤالات با کیفیت** است. این راهنمایی کلی نمی‌تواند در مورد اینکه چه سؤالاتی باید بپرسید تجویز کند، زیرا بهترین سؤالات بستگی به داده‌هایتان دارد، اما می‌توانیم با ارائه چند نوع سؤالات که همیشه مفیدند، شما را شروع کنیم. این دو نوع سؤال پایه هستند:

1. **چه نوع تنوعی در متغیرهای من رخ می‌دهد؟**

2. **چه نوع همبستگی بین متغیرهای من رخ می‌دهد؟**

بقیه این فصل به این سؤالات نگاه خواهد کرد. من هر سؤال را تعریف خواهم کرد، سپس نشان خواهم داد که چگونه از تجسم برای پاسخ دادن به آن استفاده کنید.

## تنوع

**تنوع** (Variation) تمایل مقادیر یک متغیر به تغییر از اندازه‌گیری به اندازه‌گیری است. می‌توانید تنوع را به راحتی در زندگی واقعی ببینید؛ اگر همین متغیر را دوبار اندازه‌گیری کنید، دو نتیجه متفاوت خواهید گرفت. این حتی زمانی درست است که مقادیری را اندازه‌گیری کنید که ثابت هستند، مانند سرعت نور. هر اندازه‌گیری شامل مقداری خطای کوچک است که با زمان تغییر می‌کند. متغیرهای طبقه‌بندی نیز می‌توانند تغییر کنند اگر بین اشیاء مختلف (مانند رنگ چشم افراد مختلف) یا زمان‌های مختلف (مانند سطوح انرژی یک الکترون در لحظات مختلف) اندازه‌گیری شوند.

هر متغیر الگوی تنوع منحصر به فرد خود را دارد، که می‌تواند بینش‌های جالبی را نشان دهد. بهترین راه برای درک آن الگو، توزیع مقادیر متغیر را تجسم کردن است.

### تجسم توزیع‌ها

نحوه تجسم توزیع یک متغیر بستگی به این دارد که متغیر طبقه‌بندی یا پیوسته باشد. یک متغیر **طبقه‌بندی** (categorical) است اگر بتواند فقط یکی از مجموعه کوچکی از مقادیر را بگیرد. در R، متغیرهای طبقه‌بندی معمولاً به عنوان factors یا character vectors ذخیره می‌شوند. برای بررسی توزیع یک متغیر طبقه‌بندی، از نمودار میله‌ای استفاده کنید:

```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))
```

ارتفاع هر میله تعداد مشاهداتی را نشان می‌دهد که با هر مقدار x رخ داده‌اند. می‌توانید این تعدادها را به صورت دستی با `dplyr::count()` محاسبه کنید:

```{r}
diamonds |> 
  count(cut)
```

یک متغیر **پیوسته** (continuous) است اگر بتواند هر یک از مجموعه نامحدودی از مقادیر مرتب را بگیرد. اعداد و تاریخ-زمان نمونه‌هایی از متغیرهای پیوسته هستند. برای بررسی توزیع یک متغیر پیوسته، از هیستوگرام استفاده کنید:

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)
```

می‌توانید عرض فاصله‌ها را در هیستوگرام با آرگومان `binwidth` تنظیم کنید، که در واحد متغیر x اندازه‌گیری می‌شود. همیشه باید چندین binwidth را بررسی کنید زمانی که با هیستوگرام‌ها کار می‌کنید، زیرا binwidth‌های مختلف ممکن است الگوهای مختلفی را آشکار کنند.

```{r}
smaller <- diamonds |> 
  filter(carat < 3)

ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.1)
```

اگر می‌خواهید چندین هیستوگرام را در یک نمودار همپوشانی کنید، پیشنهاد می‌دهم از `geom_freqpoly()` به جای `geom_histogram()` استفاده کنید. `geom_freqpoly()` همان محاسبه `geom_histogram()` را انجام می‌دهد، اما به جای نمایش تعداد با میله‌ها، از خطوط استفاده می‌کند. آسان‌تر است چندین خط را مقایسه کرد تا چندین میله:

```{r}
ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +
  geom_freqpoly(binwidth = 0.1)
```

### مقادیر معمول

در هر دو نوع نمودار—میله‌ای و هیستوگرام—مناطق پر و خالی دنبال کنید. مناطق پر نشان‌دهنده مقادیر مشترک متغیرتان است، و مناطق خالی مقادیری را نشان می‌دهد که کمتر دیده می‌شوند. برای تبدیل این اطلاعات به سؤالات مفید، دنبال هر چیز غیرمنتظره‌ای باشید:

* کدام مقادیر رایج‌ترین هستند؟ چرا؟

* کدام مقادیر نادر هستند؟ چرا؟ آیا این با انتظارات شما مطابقت دارد؟

* آیا می‌توانید الگوهای غیرمعمولی ببینید؟ چه چیزی ممکن است آن‌ها را توضیح دهد؟

به عنوان مثال، هیستوگرام زیر چندین سؤال جالب پیش می‌کشد:

* چرا الماس‌های بیشتری در قراط‌های کامل و کسرهای معمول قراط وجود دارد؟

* چرا الماس‌هایی با اندازه کمی بیش از 1 قراط بیشتر از الماس‌های کمی کمتر از 1 قراط وجود دارد؟

```{r}
ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.01)
```

کلاسترهای مشابه مقادیر نشانگر وجود زیرگروه‌ها در داده‌هایتان هستند. برای درک زیرگروه‌ها، بپرسید:

* افراد موجود در هر کلاستر چگونه یکدیگر شبیه هستند؟

* افراد موجود در کلاسترهای جداگانه چگونه با یکدیگر متفاوت هستند؟

* چگونه می‌توانید کلاسترها را توضیح یا توصیف کنید؟

* چرا ممکن است ظاهر کلاسترها گمراه‌کننده باشد؟

### مقادیر غیرمعمول

Outlierها—مشاهداتی که غیرمعمول هستند؛ نقاط دادهای که به نظر الگوی معمول را دنبال نمی‌کنند. گاهی outlierها خطاهای ورود داده هستند؛ گاهی اوقات آن‌ها فقط تنها مقادیر انتهایی هستند که اتفاق افتاده به طور تصادفی در این مجموعه داده مشاهده شده‌اند. گاهی اوقات outlierها پیشنهاد‌کننده علم جدید مهم هستند. وقتی outlierها در یک هیستوگرام دارید، شما نمی‌توانید آن‌ها را به خوبی ببینید زیرا میله‌های کوتاه outlierها توسط میله‌های بلند مشاهدات معمول پنهان می‌شوند. برای آسان‌تر کردن دیدن مقادیر غیرمعمول، باید محور y را با `coord_cartesian()` بزرگ‌نمایی کنید:

```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)
```

مقادیر غیرمعمول زیادی در صورت کلی رایج نیستند، بنابراین Outlierها ممکن است در هیستوگرام نامرئی باشند. اما آن‌ها در اینجا در محور y هستند. با `coord_cartesian()` بر روی مقادیر کوچک محور y بزرگ‌نمایی می‌کنیم:

```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))
```

(`coord_cartesian()` همچنین یک آرگومان `xlim()` برای زمانی که نیاز به بزرگ‌نمایی محور x دارید نیز دارد. ggplot2 همچنین توابع `xlim()` و `ylim()` دارد که کمی متفاوت کار می‌کنند: آن‌ها کلیه داده‌هایی را که خارج از محدوده‌ها است دور می‌اندازند.)

این کار ما را قادر می‌سازد تا سه مقدار غیرمعمول ببینیم: ~0، ~30، و ~60. آن‌ها را با dplyr بیرون می‌کشیم:

```{r}
unusual <- diamonds |> 
  filter(y < 3 | y > 20) |> 
  select(price, x, y, z) |>
  arrange(y)
unusual
```

متغیر `y` عرض یک الماس را بر حسب میلی‌متر اندازه‌گیری می‌کند. ما می‌دانیم که الماس‌ها نمی‌توانند عرض 0 میلی‌متر داشته باشند، بنابراین این مقادیر باید نادرست باشند. ما همچنین ممکن است مشکوک شویم که اندازه‌گیری 32 و 59 میلی‌متر غیر منطقی است: این الماس‌ها بیش از یک اینچ طول دارند، اما هزینه صدها دلار!

این یک اتفاق رایج است که شما مشاهدات غیرمعمولی که در داده‌هایتان قابل فهم نیست را کشف کنید. اگر این اتفاق می‌افتد، دو گزینه دارید:

1. **مقادیر غیرمعمول را حذف کنید.**

   اگر دلیل خوبی برای باور اینکه مشاهدات فقط خطاهای ورود داده هستند دارید، حذف کل سطر قابل قبول است:

   ```{r}
   diamonds2 <- diamonds |> 
     filter(between(y, 3, 20))
   ```

   با این حال، من توصیه نمی‌کنم این گزینه را بدون دلیل قوی انتخاب کنید، فقط بخاطر اینکه یک outlier وجود دارد. یک مشاهده outlier ممکن است یک اشاره مهم به یک کیفیت پایین داده باشد، و نباید بدون توجیه قوی آن را کنار بگذارید.

2. **به جای آن، مقادیر غیرمعمول را با مقادیر missing جایگزین کنید.**

   اگر مقادیر غیرمعمول تأثیر قابل توجهی بر نتایجتان داشته باشد و نمی‌توانید دلیل اینکه چرا آن‌جا هستند را پیدا کنید، یک گزینه عاقلانه جایگزین کردن آن‌ها با مقادیر missing است.

   ```{r}
   diamonds2 <- diamonds |> 
     mutate(y = ifelse(y < 3 | y > 20, NA, y))
   ```

`ifelse()` سه آرگومان دارد. آرگومان اول `test` یک بردار منطقی است. نتیجه `value` خواهد بود زمانی که `test` درست است، و `no` زمانی که غلط است. بدلیل اینکه این `mutate()` درون یک pipeline قرار دارد.

ggplot2 شما را هشدار می‌دهد که مقادیر missing حذف شده‌اند:

```{r}
ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + 
  geom_point()
```

گاهی اوقات می‌خواهید بفهمید که چه باعث مشاهدات با مقادیر missing در یک متغیر نسبت به مشاهدات with recorded values متفاوت می‌کند. برای مثال، در `nycflights13::flights`، مقادیر missing در متغیر `dep_time` نشان می‌دهد که پرواز لغو شده است. بنابراین ممکن است بخواهید پروازهای لغو شده و غیر لغو شده را مقایسه کنید. می‌توانید این کار را با ایجاد یک متغیر جدید با `is.na()` انجام دهید.

```{r}
nycflights13::flights |> 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + sched_min / 60
  ) |> 
  ggplot(mapping = aes(sched_dep_time)) + 
    geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)
```

### تمرینات

1. مناسبترین binwidth برای کاوش توزیع `carat` چیست؟

2. در `price` چه چیزی یاد می‌گیرید؟ چرا توزیع با فاصله 1000 دلار خیلی ناهموار است؟

3. چند الماس 0.99 قراط هست؟ چند الماس 1 قراط هست؟ چه چیزی باعث تفاوت شده؟

4. `xlim()` و `ylim()` را با `coord_cartesian()` مقایسه و تضاد کنید. اگر binwidth را نشان ندهید چه اتفاق می‌افتد؟ اگر زوم روی فقط نیمی از یک میله کنید چه اتفاق می‌افتد؟

## همبستگی

اگر تنوع پدیده‌ای **درون** یک متغیر است، همبستگی پدیده‌ای **بین** متغیرها است. **همبستگی** (Covariation) تمایل مقادیر دو یا چند متغیر به تغییر همزمان به شیوه‌ای مرتبط است. بهترین راه برای کشف همبستگی تجسم رابطه بین دو یا چند متغیر است. نحوه انجام آن دوباره بستگی به نوع متغیرهای درگیر دارد.

### یک متغیر طبقه‌بندی و یک متغیر پیوسته

اغلب مفید است کاوش توزیع یک متغیر پیوسته که بر اساس یک متغیر طبقه‌بندی شکسته شده، همان‌طور که در مثال `geom_freqpoly()` پیشین کردیم. نمای پیش‌فرض `geom_freqpoly()` کمک زیادی نمی‌کند زیرا ارتفاع تحت تأثیر تعداد کل قرار می‌گیرد که در هر گروه بسیار متفاوت است.

```{r}
ggplot(data = diamonds, mapping = aes(x = price)) + 
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)
```

آسان نیست مقایسه شکل این توزیع‌ها زیرا تعداد کل کلی بسیار متفاوت است:

```{r}
ggplot(diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

برای آسان‌تر کردن مقایسه، نیاز به تغییر آنچه بر محور y نمایش داده می‌شود داریم. به جای نمایش تعداد، **چگالی** (density) نمایش دهیم، که تعداد استانداردشده به طوری که ناحیه زیر هر چندضلعی فرکانس یک است:

```{r}
ggplot(data = diamonds, mapping = aes(x = price, y = after_stat(density))) + 
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)
```

چیز جالبی وجود دارد در مورد این نمودار - به نظر می‌رسد الماس‌های "Fair" (پایین‌ترین کیفیت) میانگین قیمت بالاترین را دارند! اما شاید این بخاطر آن باشد که چگالی فرکانس کمی دشوار برای تفسیر است. روش دیگری برای نمایش این نوع توزیع boxplot است.

```{r}
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
  geom_boxplot()
```

ما کمتر اطلاعات در مورد توزیع با boxplot می‌بینیم، اما boxplotها بسیار فشرده هستند بنابراین راحت‌تر است چندین مورد را مقایسه کنیم (و آن‌ها کمتر جا می‌گیرند). آن‌ها الگوی عمومی کمتری از رابطه بین `cut` و `price` را حمایت می‌کنند: الماس‌های با کیفیت بهتر ارزان‌ترند! در تمرینات، شما به کشف علت خواهید پرداخت.

`cut` یک متغیر مرتب است: Fair بدتر از Good است، که بدتر از Very Good و غیره است. بسیاری از متغیرهای طبقه‌بندی نظم طبیعی ندارند، بنابراین ممکن است بخواهید آن‌ها را مرتب کنید تا نمایش آموزنده‌تری ایجاد کنید. یکی از راه‌های انجام آن استفاده از `reorder()` است.

برای مثال، متغیر `class` در مجموعه داده `mpg` نظم طبیعی ندارد:

```{r}
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
  geom_boxplot()
```

برای آسان‌تر کردن درک الگو، می‌توانیم `class` را بر اساس مقدار میانه `hwy` مجدداً مرتب کنیم:

```{r}
ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy))
```

اگر نام‌های متغیرها طویل باشند، `geom_boxplot()` بهتر کار می‌کند اگر آن را 90 درجه بچرخانید. می‌توانید این کار را با `coord_flip()` انجام دهید.

```{r}
ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
  coord_flip()
```

### دو متغیر طبقه‌بندی

برای تجسم همبستگی بین متغیرهای طبقه‌بندی، باید تعداد مشاهدات برای هر ترکیب را بشمارید. یک راه انجام این کار با geom داخلی `geom_count()` است:

```{r}
ggplot(data = diamonds) +
  geom_count(mapping = aes(x = cut, y = color))
```

اندازه هر دایره در نمودار تعداد مشاهدات را نشان می‌دهد که در هر ترکیب از مقادیر اتفاق افتاده‌اند. همبستگی توسط اندازه نسبی دایره‌ها نمایان خواهد شد که برای هر x، y ظاهر می‌شوند.

روش دیگر محاسبه تعداد با dplyr است:

```{r}
diamonds |> 
  count(color, cut)
```

سپس آن را با `geom_tile()` و aesthetic fill تجسم کنید:

```{r}
diamonds |> 
  count(color, cut) |>  
  ggplot(mapping = aes(x = color, y = cut)) +
    geom_tile(mapping = aes(fill = n))
```

اگر متغیرهای طبقه‌بندی مرتب نشده باشند، ممکن است بخواهید از بسته seriation به طور همزمان rows و columns را مجدداً مرتب کنید تا الگوی جالب‌تری را آشکار سازد. برای نمودارهای بزرگ‌تر، ممکن است بخواهید از بسته d3heatmap یا heatmaply استفاده کنید که نمودارهای تعاملی ایجاد می‌کنند.

### دو متغیر پیوسته

شما قبلاً یک geom بزرگ برای تجسم همبستگی بین دو متغیر پیوسته دیده‌اید: `geom_point()`. Scatterplotها یکی از مفیدترین نمایش‌ها هستند، اما به دلیل overplotting برای مجموعه داده‌های بزرگ کمتر مفید می‌شوند. شما می‌توانید مشکل overplotting را در نمودار زیر ببینید. فقط ~54,000 نقطه وجود دارد، اما آن‌ها نمی‌توانند به طور منحصر به فرد تصویر داده شوند.

```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = carat, y = price))
```

شما قبلاً یک راه برای بهبود نمودار دیده‌اید: استفاده از aesthetic alpha برای اضافه کردن شفافیت.

```{r}
ggplot(data = diamonds) + 
  geom_point(mapping = aes(x = carat, y = price), alpha = 1 / 100)
```

اما استفاده از شفافیت می‌تواند برای مجموعه داده‌های بسیار بزرگ چالش‌برانگیز باشد. روش دیگر استفاده از bins است. قبلاً از `geom_histogram()` و `geom_freqpoly()` برای bin یک بعد استفاده کردید. حالا یاد خواهید گرفت که چگونه از `geom_bin2d()` و `geom_hex()` برای bin در دو بعد استفاده کنید.

`geom_bin2d()` و `geom_hex()` صفحه x-y را به bins دوبعدی تقسیم می‌کنند و سپس از پر کردن رنگ برای نمایش تعداد نقاط در هر bin استفاده می‌کنند. `geom_bin2d()` bins مستطیلی ایجاد می‌کند. `geom_hex()` bins شش‌ضلعی ایجاد می‌کند. برای استفاده از `geom_hex()` باید بسته hexbin را نصب کنید.

```{r}
ggplot(data = smaller) +
  geom_bin2d(mapping = aes(x = carat, y = price))

# install.packages("hexbin")
ggplot(data = smaller) +
  geom_hex(mapping = aes(x = carat, y = price))
```

گزینه دیگر bin یکی از متغیرهای پیوسته بنابراین آن مانند متغیر طبقه‌بندی عمل کند است. سپس می‌توانید یکی از تکنیک‌هایی را که برای ترکیب متغیر طبقه‌بندی و متغیر پیوسته یاد گرفته‌اید استفاده کنید. برای مثال، می‌توانید `carat` را bin کنید و سپس برای هر گروه boxplot بکشید:

```{r}
ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)))
```

`cut_width(x, width)` همان‌طور که از نام مشخص است، `x` را به bins با عرض `width` تقسیم می‌کند. به طور پیش‌فرض، boxplotها تقریباً یکسان به نظر می‌رسند (غیر از تعداد outlierها) که نشان می‌دهد توزیع `price` بسیار به `carat` بستگی ندارد.

`cut_width(x, width)` بر روی هر bin تعداد یکسانی از نقاط نمایش می‌دهد. `cut_number(x, n)` تقریباً تعداد یکسانی از نقاط در هر bin نمایش می‌دهد:

```{r}
ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_number(carat, 20)))
```

### تمرینات

1. به جای استفاده از `cut_width()` یا `cut_number()`, چگونه می‌توانید کاوش کنید که `price` چگونه بر اساس `carat` توزیع شده است؟

2. نمودار رابطه `carat` و `price` نشان می‌دهد که الماس‌های 1.5 قراطه گران‌تر از الماس‌های 2 قراطه هستند. چرا فکر می‌کنید این اتفاق می‌افتد؟

3. خوشه‌بندی الماس‌هایی که شبیه به هم هستند را در نمودار cut_number() نمایش دهید. چه چیزی درباره توزیع رنگ، وضوح، و cut در مقادیر مختلف قراط می‌توانید فرض کنید؟

4. چرا گاهی اوقات مفیدتر است که `cut_number()` را به جای `cut_width()` استفاده کنید؟

5. دو نمودار زیر مشابه هستند، اما کمی متفاوت. یکی `color` بر اساس `cut` و دیگری `cut` بر اساس `color` گروه‌بندی می‌کند. چگونه می‌توانید آن دو نمودار را بگویید که کدام کدام است؟

   ```{r}
   ggplot(data = diamonds, mapping = aes(x = color, y = price)) +
     geom_boxplot()
   ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
     geom_boxplot()
   ```

## الگوها و مدل‌ها

الگوها در داده‌ها نشان‌دهنده روابط هستند. اگر یک رابطه منظم بین دو متغیر وجود داشته باشد، آن در داده‌هایتان به عنوان یک الگو ظاهر خواهد شد. اگر یک الگو را کشف کنید، خودتان بپرسید:

+ آیا می‌تواند این الگو به دلیل اتفاق باشد (یعنی نمونه‌گیری تصادفی)؟

+ چه رابطه‌ای توسط الگو ضمنی است؟

+ این رابطه چقدر قوی است؟

+ چه متغیرهای دیگری ممکن است بر رابطه تأثیر بگذارند؟

+ آیا رابطه اگر به زیرگروه‌های داده نگاه کنید تغییر می‌کند؟

یک scatterplot از Old Faithful eruption data الگوی جالبی نشان می‌دهد: زمان‌های انتظار طولانی‌تر با فوران‌های طولانی‌تر همراه هستند. scatterplot همچنین دو کلاستر نقاط را آشکار می‌کند، که ممکن است نشان‌دهنده دو نوع فوران باشد (کوتاه یا بلند)، و چندین outlier.

```{r}
ggplot(data = faithful) + 
  geom_point(mapping = aes(x = eruptions, y = waiting))
```

الگوها ابزاری قدرتمند برای دانشمندان داده ارائه می‌دهند زیرا آن‌ها همبستگی را آشکار می‌کنند. اگر یک رابطه علت و معلولی وجود داشته باشد، الگو در داده‌هایتان قابل مشاهده خواهد بود.

مدل‌ها ابزاری برای استخراج الگوها از داده‌ها هستند. برای مثال، در نظر بگیرید الگوی داده‌های الماس. از داده‌هایمان دشوار است که رابطه بین `cut` و `price` را درک کنیم، زیرا `cut` و `carat`، و `carat` و `price` به شدت به هم مربوط هستند. امکان استفاده از مدل برای حذف رابطه بسیار قوی بین `price` و `carat` وجود دارد بنابراین می‌توانیم باقی‌مانده‌ها را کشف کنیم، که خواهد بود آنچه باقی مانده پس از حذف آن اثر.

```{r}
library(modelr)

mod <- lm(log(price) ~ log(carat), data = diamonds)

diamonds2 <- diamonds |> 
  add_residuals(mod) |> 
  mutate(resid = exp(resid))

ggplot(data = diamonds2) + 
  geom_point(mapping = aes(x = carat, y = resid))
```

یکبار که اثر `carat` را حذف کرده‌اید، می‌توانید ببینید که آنچه انتظار دارید درباره رابطه بین `cut` و `price`: نسبت به اندازه‌شان، الماس‌های با کیفیت بهتر گران‌ترند.

```{r}
ggplot(data = diamonds2) + 
  geom_boxplot(mapping = aes(x = cut, y = resid))
```

شما یاد خواهید گرفت که چگونه مدل‌ها، یک ابزار بسیار عمومی برای استخراج الگوها از داده‌ها، در [مدل‌سازی](#model-intro) کار می‌کنند.

### تمرینات

1. در نمودار scatterplot های `diamonds`, چرا تراکم الماس‌ها در محدوده‌هایی که `x = 1`, `y = 1`, و `z = 1` نزدیک صفر است؟

2. کاوش کنید توزیع `price` per `carat`، بین الماس‌هایی که `color`, `cut`, و `clarity` کمتر از یک قراط در مقابل الماس‌هایی که بیش از یک قراط هستند.

3. الماس‌های بزرگ معمولاً کیفیت پایین‌تری دارند. آیا این را در داده‌ها می‌بینید؟ اگر چنین است، چگونه فکر می‌کنید چرا؟

4. در نمودار boxplot برای `cut` بر اساس `price`, هر boxplot مقادیر z با برخی outlierها ادامه دارد. چرا؟ (راهنمایی: think در مورد `ylim()`.)

## ارتباط: ggplot2calls

از آن جایی که یکبار الگو را کشف کرده‌اید، ممکن است بخواهید آن را به کسان دیگری نشان دهید. Exploration و communication را آسان کردن هدف اصلی ggplot2 است. در حقیقت، همیشه باید یک سؤال در ذهنتان داشته باشید وقتی که نموداری می‌سازید: «آیا این نمودار به من در پیدا کردن الگوها کمک می‌کند؟» یا «آیا این نمودار دیگران را قادر می‌سازد تا الگویی که من کشف کرده‌ام را ببینند؟»

## خلاصه

در این فصل، مبانی اکتشاف داده‌ها (EDA) را یاد گرفتید، یک فرآیند چرخه‌ای پرسیدن سؤالات، تجسم، تبدیل، و مدل‌سازی داده‌هایتان. EDA همچنین نقطه شروع و اساس همه کارهای دیگری است که با داده انجام می‌دهید.

در فصل بعدی، بر روی communication در تمرکز خواهیم کرد - نحوه درک و بهبود نمودارهایتان تا آن‌ها ایده‌هایتان را به طور واضح و مؤثر به دیگران منتقل کنند.