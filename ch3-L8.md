# ۱۹ اتصالات

## ۱.۱۹ مقدمه

به ندرت یک تحلیل داده فقط شامل یک دیتافریم واحد است. معمولاً دیتافریم‌های زیادی دارید و برای پاسخ به سؤالاتی که به آن‌ها علاقه‌مند هستید، باید آن‌ها را با هم **متصل** کنید (join). این فصل دو نوع مهم از اتصالات را به شما معرفی می‌کند:

- اتصالات جهش‌دهنده (Mutating joins)، که متغیرهای جدید را از مشاهدات منطبق در یک دیتافریم دیگر به یک دیتافریم اضافه می‌کنند.
- اتصالات فیلتری (Filtering joins)، که مشاهدات را از یک دیتافریم بر اساس اینکه آیا با یک مشاهده در دیتافریم دیگری منطبق هستند یا نه، فیلتر می‌کنند.

ابتدا با بحث درباره کلیدها شروع می‌کنیم، متغیرهایی که برای اتصال یک جفت دیتافریم در یک join استفاده می‌شوند. سپس تئوری را با بررسی کلیدها در مجموعه‌داده‌های بسته nycflights13 تثبیت می‌کنیم و از آن دانش برای شروع اتصال دیتافریم‌ها استفاده می‌کنیم. در ادامه درباره نحوه کار joinها بحث خواهیم کرد و بر روی عملکردشان روی سطرها تمرکز خواهیم کرد. در نهایت با بحثی درباره اتصالات غیرمساوی (non-equi joins) به پایان می‌رسیم، خانواده‌ای از joinها که روشی انعطاف‌پذیرتر برای تطبیق کلیدها نسبت به رابطه تساوی پیش‌فرض ارائه می‌دهند.

### ۱.۱.۱۹ پیش‌نیازها

در این فصل، پنج مجموعه داده مرتبط از nycflights13 را با استفاده از توابع join از dplyr بررسی خواهیم کرد.

```{r}
library(tidyverse)
library(nycflights13)
```

## ۲.۱۹ کلیدها

برای درک joinها، ابتدا باید بفهمید که چگونه دو جدول می‌توانند از طریق یک جفت کلید، در هر جدول، متصل شوند. در این بخش، درباره دو نوع کلید یاد خواهید گرفت و نمونه‌هایی از هر دو را در مجموعه‌داده‌های بسته nycflights13 خواهید دید. همچنین یاد می‌گیرید چگونه بررسی کنید که کلیدهای شما معتبر هستند و در صورتی که جدول شما فاقد کلید است چه کاری انجام دهید.

### ۱.۲.۱۹ کلیدهای اولیه و خارجی

هر join شامل یک جفت کلید است: یک کلید اولیه و یک کلید خارجی. **کلید اولیه** (primary key) یک متغیر یا مجموعه‌ای از متغیرها است که هر مشاهده را به طور منحصر به فرد شناسایی می‌کند. وقتی بیش از یک متغیر مورد نیاز است، کلید را **کلید مرکب** (compound key) می‌نامیم. به عنوان مثال، در nycflights13:

- `airlines` دو قطعه داده درباره هر شرکت هواپیمایی ثبت می‌کند: کد حامل آن و نام کامل آن. می‌توانید یک شرکت هواپیمایی را با کد دو حرفی حامل آن شناسایی کنید، بنابراین `carrier` کلید اولیه است.

```{r}
airlines
```

- `airports` داده‌هایی درباره هر فرودگاه ثبت می‌کند. می‌توانید هر فرودگاه را با کد سه حرفی فرودگاه آن شناسایی کنید، بنابراین `faa` کلید اولیه است.

```{r}
airports
```

- `planes` داده‌هایی درباره هر هواپیما ثبت می‌کند. می‌توانید یک هواپیما را با شماره دُم آن شناسایی کنید، بنابراین `tailnum` کلید اولیه است.

```{r}
planes
```

- `weather` داده‌هایی درباره آب و هوا در فرودگاه‌های مبدأ ثبت می‌کند. می‌توانید هر مشاهده را با ترکیب موقعیت و زمان شناسایی کنید، بنابراین `origin` و `time_hour` کلید اولیه مرکب را تشکیل می‌دهند.

```{r}
weather
```

**کلید خارجی** (foreign key) یک متغیر (یا مجموعه‌ای از متغیرها) است که مطابق با کلید اولیه در جدول دیگری است. به عنوان مثال:

- `flights$tailnum` یک کلید خارجی است که مطابق با کلید اولیه `planes$tailnum` است.
- `flights$carrier` یک کلید خارجی است که مطابق با کلید اولیه `airlines$carrier` است.
- `flights$origin` یک کلید خارجی است که مطابق با کلید اولیه `airports$faa` است.
- `flights$dest` یک کلید خارجی است که مطابق با کلید اولیه `airports$faa` است.
- `flights$origin`-`flights$time_hour` یک کلید خارجی مرکب است که مطابق با کلید اولیه مرکب `weather$origin`-`weather$time_hour` است.

این روابط به صورت بصری خلاصه شده‌اند.

یک ویژگی خوب در طراحی این کلیدها متوجه خواهید شد: کلیدهای اولیه و خارجی تقریباً همیشه نام‌های یکسانی دارند، که همان‌طور که به زودی خواهید دید، زندگی شما را در هنگام اتصال بسیار آسان‌تر می‌کند. همچنین ارزش دارد رابطه معکوس را در نظر بگیریم: تقریباً هر نام متغیری که در چندین جدول استفاده می‌شود، در هر جا معنای یکسانی دارد. فقط یک استثنا وجود دارد: `year` به معنای سال پرواز در `flights` و سال ساخت در `planes` است. این موضوع زمانی که شروع به اتصال واقعی جداول می‌کنیم مهم خواهد بود.

### ۲.۲.۱۹ بررسی کلیدهای اولیه

حال که کلیدهای اولیه را در هر جدول شناسایی کردیم، عمل خوبی است که تأیید کنیم آن‌ها واقعاً هر مشاهده را به طور منحصر به فرد شناسایی می‌کنند. یک راه برای انجام این کار این است که کلیدهای اولیه را `count()` کنیم و به دنبال ورودی‌هایی بگردیم که در آن‌ها `n` بیشتر از یک باشد. این نشان می‌دهد که `planes` و `weather` هر دو خوب هستند:

```{r}
planes |> 
  count(tailnum) |> 
  filter(n > 1)

weather |> 
  count(time_hour, origin) |> 
  filter(n > 1)
```

همچنین باید مقادیر گمشده در کلیدهای اولیه خود را بررسی کنید --- اگر یک مقدار گمشده باشد، نمی‌تواند یک مشاهده را شناسایی کند!

```{r}
planes |> 
  filter(is.na(tailnum))

weather |> 
  filter(is.na(time_hour) | is.na(origin))
```

### ۳.۲.۱۹ کلیدهای جایگزین

تا اینجا درباره کلید اولیه برای `flights` صحبت نکردیم. اینجا فوق‌العاده مهم نیست، چون دیتافریمی وجود ندارد که از آن به عنوان کلید خارجی استفاده کند، اما همچنان مفید است که در نظر بگیریم زیرا کار با مشاهدات آسان‌تر است اگر راهی برای توصیف آن‌ها به دیگران داشته باشیم.

پس از کمی فکر کردن و آزمایش، متوجه شدیم که سه متغیر با هم هر پرواز را به طور منحصر به فرد شناسایی می‌کنند:

```{r}
flights |> 
  count(time_hour, carrier, flight) |> 
  filter(n > 1)
```

آیا عدم وجود موارد تکراری به طور خودکار `time_hour`-`carrier`-`flight` را به یک کلید اولیه تبدیل می‌کند؟ این قطعاً یک شروع خوب است، اما تضمین نمی‌کند. به عنوان مثال، آیا ارتفاع و عرض جغرافیایی یک کلید اولیه خوب برای `airports` هستند؟

```{r}
airports |>
  count(alt, lat) |> 
  filter(n > 1)
```

شناسایی یک فرودگاه با ارتفاع و عرض جغرافیایی آن به وضوح ایده بدی است، و به طور کلی نمی‌توان فقط از داده‌ها فهمید که آیا ترکیبی از متغیرها کلید اولیه خوبی را تشکیل می‌دهد یا نه. اما برای پروازها، ترکیب `time_hour`، `carrier` و `flight` معقول به نظر می‌رسد زیرا واقعاً گیج‌کننده خواهد بود اگر یک شرکت هواپیمایی و مشتریان آن چندین پرواز با همان شماره پرواز به طور همزمان در هوا داشته باشند.

با این حال، ممکن است بهتر باشد یک کلید جایگزین عددی ساده با استفاده از شماره سطر معرفی کنیم:

```{r}
flights2 <- flights |> 
  mutate(id = row_number(), .before = 1)
flights2
```

کلیدهای جایگزین می‌توانند به ویژه هنگام برقراری ارتباط با انسان‌های دیگر مفید باشند: گفتن به کسی که به پرواز 2001 نگاه کند بسیار آسان‌تر از گفتن به پرواز UA430 که در ساعت 9 صبح 2013-01-03 پرواز کرد است.

### ۴.۲.۱۹ تمرین‌ها

1. فراموش کردیم رابطه بین `weather` و `airports` را ترسیم کنیم. رابطه چیست و چگونه باید در نمودار ظاهر شود؟

2. `weather` فقط حاوی اطلاعات برای سه فرودگاه مبدأ در NYC است. اگر شامل سوابق آب و هوا برای همه فرودگاه‌های ایالات متحده بود، چه اتصال اضافی به `flights` ایجاد می‌کرد؟

3. متغیرهای `year`، `month`، `day`، `hour` و `origin` تقریباً یک کلید مرکب برای `weather` تشکیل می‌دهند، اما یک ساعت وجود دارد که مشاهدات تکراری دارد. می‌توانید بفهمید چه چیزی درباره آن ساعت خاص است؟

4. می‌دانیم که برخی روزهای سال خاص هستند و کمتر از حد معمول افراد در آن‌ها پرواز می‌کنند (مثلاً شب کریسمس و روز کریسمس). چگونه ممکن است آن داده را به عنوان یک دیتافریم نمایش دهید؟ کلید اولیه چه خواهد بود؟ چگونه به دیتافریم‌های موجود متصل می‌شود؟

5. نمودار نشان‌دهنده ارتباطات بین دیتافریم‌های `Batting`، `People` و `Salaries` در بسته Lahman ترسیم کنید. نمودار دیگری که رابطه بین `People`، `Managers`، `AwardsManagers` را نشان دهد ترسیم کنید. چگونه رابطه بین دیتافریم‌های `Batting`، `Pitching` و `Fielding` را توصیف می‌کنید؟

## ۳.۱۹ اتصالات پایه

حال که درک کردید دیتافریم‌ها چگونه از طریق کلیدها متصل می‌شوند، می‌توانیم شروع به استفاده از joinها برای درک بهتر مجموعه داده `flights` کنیم. dplyr شش تابع join ارائه می‌دهد: `left_join()`، `inner_join()`، `right_join()`، `full_join()`، `semi_join()` و `anti_join()`. همه آن‌ها رابط یکسانی دارند: یک جفت دیتافریم (`x` و `y`) می‌گیرند و یک دیتافریم برمی‌گردانند. ترتیب سطرها و ستون‌های `x` همیشه حفظ می‌شود تا حد امکان.

در این بخش، توابع مختلف join را با استفاده از ویژگی تجسمی `x` و `y` در زیر یاد خواهید گرفت. این مثالی مصنوعی است، اما مفید است زیرا اجازه می‌دهد بفهمیم که هر join چه کاری انجام می‌دهد بدون اینکه به جزئیات چه اتفاقی برای هر متغیر می‌افتد فکر کنیم. نماد‌گذاری ساده است:

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

این مجموعه‌داده‌های خیلی کوچک نشان می‌دهند که هنگام اتصال چه اتفاقی می‌افتد. کلید یک رنگ به هم می‌خورد، و شماره‌ها نشان می‌دهند که سطرها از x و y منشأ می‌گیرند.

### ۱.۳.۱۹ اتصالات جهش‌دهنده

اتصالات جهش‌دهنده به شما اجازه می‌دهند متغیرها را از دو دیتافریم ترکیب کنید. آن‌ها ابتدا مشاهدات را با کلیدهایشان مطابقت می‌دهند، سپس متغیرها را از یک دیتافریم به دیگری کپی می‌کنند. مانند `mutate()`، توابع join متغیرهای جدید را در سمت راست اضافه می‌کنند، بنابراین اگر مجموعه داده بسیار بزرگی با ستون‌های زیاد دارید، نخواهید توانست همه متغیرهای جدید را ببینید. برای این مثال‌ها، ما یک راه ساده برای جلوگیری از این مشکل معرفی خواهیم کرد: محدود کردن خروجی فقط به متغیرهای جدید که به هر join اضافه شده‌اند.

رایج‌ترین نوع join `left_join()` است. این ویژه است زیرا خروجی همیشه همان سطرها مانند `x` دارد، و به طور پیش‌فرض، دیتافریم خروجی همان ستون‌های `x` را دارد. بیایید ببینیم که آیا تاخیرهای خروج و ورود مرتبط با سن هواپیماها هستند یا نه:

```{r}
flights2 <- flights |> 
  select(year, time_hour, origin, dest, tailnum, carrier)

flights2 |>
  left_join(airlines)
```

یا ببینیم که آیا ارتباطی بین دما و تاخیرهای خروج وجود دارد یا نه:

```{r}
flights2 |> 
  left_join(weather |> select(origin, time_hour, temp, wind_speed))
```

یا ببینیم که هر هواپیما به کجا پرواز کرد:

```{r}
flights2 |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

وقتی `left_join()` برای تطبیق سطرها در `y` با `x` شکست می‌خورد، خانه‌های جدیدی در `y` با `NA` پر می‌شوند. به عنوان مثال، توجه کنید که ما برای همه این شماره دُم‌ها از `planes` اطلاعاتی نداریم، بنابراین ستون‌های `type` و `engines` و `seats` با NA پر خواهند شد:

```{r}
flights2 |> 
  filter(tailnum == "N3ALAA") |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

در ادامه نحوه کار این کار و سایر join‌ها را با یک ابزار بصری یاد خواهید گرفت.

### ۲.۳.۱۹ مشخص کردن متغیرهای کلید

به طور پیش‌فرض، `left_join()` از همه متغیرهایی که در هر دو دیتافریم ظاهر می‌شوند به عنوان کلید استفاده می‌کند، به اصطلاح **natural join**. این یک قرارداد مفید است زیرا معمولاً کار مورد نظر را انجام می‌دهد. برای مثال، وقتی به `flights2` و `weather` بپیوندیم، از متغیرهای مشترک استفاده می‌کند: `time_hour` و `origin`.

```{r}
flights2 |> 
  left_join(weather)
```

همان‌طور که انتظار دارید، می‌توانید این رفتار را با `join_by()` کنترل کنید. برای مثال، دو راه برای پیوستن `flights2` و `planes` به `tailnum` وجود دارد:

```{r}
flights2 |> 
  left_join(planes, join_by(tailnum))

flights2 |> 
  left_join(planes, join_by(tailnum == tailnum))
```

این شبیه به نام‌گذاری `=` و `==` در `dplyr::mutate()` است، جایی که `x = 1` یک متغیر جدید به نام `x` با مقدار 1 ایجاد می‌کند و `x == 1` یک بردار منطقی ایجاد می‌کند که بررسی می‌کند `x` برابر با 1 است یا نه. متأسفانه کلمه کلیدی برای این تمایز در اینجا با SQL یکسان‌سازی شده و با قراردادهای tidyverse بیگانه است، بنابراین باید یک توافق متفاوت استفاده کنید.

`join_by(tailnum)` کوتاه‌نویسی برای `join_by(tailnum == tailnum)` است. این مهم است چون هنگام به هم پیوستن جداولی که در آن‌ها کلیدها نام‌های متفاوت دارند مهم است. به عنوان مثال، توجه کنید که در `flights` متغیر `faa` فرودگاه مبدأ، `origin` نامیده می‌شود:

```{r}
flights2 |> 
  left_join(airports, join_by(dest == faa))

flights2 |> 
  left_join(airports, join_by(origin == faa))
```

در کد قدیمی ممکن است `by` را ببینید که این نیز کار می‌کند اما کمی محدودتر است و ما توصیه می‌کنیم از `join_by()` استفاده کنید زیرا می‌تواند برای انواع بیشتری از join استفاده شود.

### ۳.۳.۱۹ فیلتر کردن اتصالات

همان‌طور که نام آن نشان می‌دهد، فیلتر کردن اتصالات مشاهدات را فیلتر می‌کند. دو نوع وجود دارد: semi-joins و anti-joins. **Semi-joins** همه سطرهای `x` را که دارای تطابق در `y` هستند نگه می‌دارد. **Anti-joins** همه سطرهای `x` را که تطابقی در `y` ندارند برمی‌گرداند. این توابع هیچ‌وقت ستون از `y` به `x` اضافه نمی‌کنند.

### ۴.۳.۱۹ تمرین‌ها

1. سایر چهار فرودگاه در `airports` که توسط `dest` متصل نشده‌اند چه نقطه قوتی دارند که چگونه می‌توانید آن را بفهمید؟

2. با استفاده از `flights2`، محاسبه کنید که میانگین تأخیر (به صورت دقیقه) برای هر فرودگاه مقصد چقدر است و سپس به `airports` بپیوندید تا یک نقشه بزرگ از تأخیرها ایجاد کنید. در اینجا شروع می‌کنید:

```{r}
avg_dest_delays <-
  flights |>
  group_by(dest) |>
  summarize(delay = mean(arr_delay, na.rm = TRUE)) |>
  inner_join(airports, by = c(dest = "faa"))
```

(اگر به تمرین‌های فصل 7 رسیده‌اید، می‌دانید چگونه این کار را انجام دهید.)

3. از مجموعه داده‌های `flights` و `planes` برای یافتن این استفاده کنید: آیا ارتباطی بین سن هواپیما و تاخیرهای آن وجود دارد؟

## ۴.۱۹ نحوه کار joinها

حال که توانسته‌اید از joinها استفاده کنید، وقت آن رسیده است که درباره چگونگی کارکرد آن‌ها بیشتر بیاموزید، با تمرکز بر نحوه تأثیر هر join روی سطرها. ابزار اصلی برای درک آن یک چارت است که نشان می‌دهد چگونه هر مشاهده در دیتافریم x و y در هر join مرتبط است.

برای ساده‌سازی کمی، فرض می‌کنیم که تنها یک کلید در هر جدول وجود دارد. در کد، این کلید با یک رنگ نمایش داده می‌شود:

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

نمودار زیر نشان می‌دهد همه ارتباطات بالقوه بین `x` و `y`. هر تقاطع دو خط با یک زوج مطابقت بالقوه نشان داده می‌شود.

### ۱.۴.۱۹ سطرهای داخلی

سطرهای خروجی `inner_join()` هر بار که کلیدهای برابر باشند نشان داده می‌شوند. خروجی یک دیتافریم جدید است که شامل کلید، ستون‌های x و ستون‌های y است:

```{r}
x |> 
  inner_join(y, join_by(key))
```

مهم‌ترین ویژگی inner join این است که سطرهای بدون تطابق در خروجی گنجانده نمی‌شوند. این بدان معنی است که به طور کلی inner join‌ها معمولاً برای استفاده در تحلیل مناسب نیستند زیرا خیلی آسان است که مشاهداتی را از دست بدهید.

### ۲.۴.۱۹ سطرهای خارجی

یک inner join همه سطرها را که در هر دو جدول ظاهر می‌شوند نگه می‌دارد. یک **outer join** همه سطرهایی را که حداقل در یکی از جداول ظاهر می‌شوند نگه می‌دارد. سه نوع outer join وجود دارد:

- یک **left join** همه سطرها را در `x` نگه می‌دارد.
- یک **right join** همه سطرها را در `y` نگه می‌دارد.
- یک **full join** همه سطرها را در `x` یا `y` نگه می‌دارد.

این joinها با اضافه کردن یک مشاهده "مجازی" اضافی به هر جدول کار می‌کنند. این مشاهده دارای یک کلید است که همیشه منطبق است (اگر هیچ کلید دیگری منطبق نباشد)، و مقادیری که با `NA` پر شده‌اند.

رایج‌ترین نوع join، left join است: هر بار که به دنبال داده‌های اضافی از جدول دیگری هستید آن را استفاده می‌کنید، زیرا مشاهدات را حفظ می‌کند حتی اگر تطابقی وجود نداشته باشد. left join باید join پیش‌فرض شما باشد: مگر اینکه دلیل خاصی برای ترجیح دادن یکی از join‌های دیگر داشته باشید، از آن استفاده کنید.

تفاوت مهم دیگر بین inner و outer join این است که چگونه با کلیدهایی که با چند سطر منطبق هستند رفتار می‌کنند.

### ۳.۴.۱۹ تمرین‌ها

1. می‌دانید که توجه ویژه‌ای به `airports` نیاز دارید زیرا داده‌ها کامل نیستند. چه فرآیندهای دیگری ممکن است در نظر بگیرید؟

2. ما می‌دانیم که برخی روزهای سال "خاص" هستند و کمتر افراد در آن‌ها پرواز می‌کنند. چگونه این داده‌ها را به عنوان یک دیتافریم نمایش می‌دهید؟ کلید اولیه چیست؟ چگونه به جداول موجود متصل می‌شود؟

## ۵.۱۹ اتصالات غیرمساوی

تا اینجا، فقط درباره اتصالات مساوی (equi joins) یاد گرفته‌اید، جایی که سطرها با برابری کلیدها منطبق می‌شوند. حالا زمان آن رسیده که کمی پیچیده‌تر شویم و درباره **اتصالات غیرمساوی** (non-equi joins) بحث کنیم، که نوعی join است که از شرایط تطبیق دیگری غیر از تساوی استفاده می‌کند.

تقریباً همه اتصالات غیرمساوی شامل نابرابری هستند (`>=`، `>`، `<` و `<=`)، بنابراین آن‌ها را **اتصالات نابرابر** (inequality joins) نیز می‌نامند.

اتصالات نابرابر بسیار قدرتمند هستند اما نسبتاً سخت‌تر برای درک آن‌ها هستند، بنابراین با چند مثال کاربردی شروع می‌کنیم.

### ۱.۵.۱۹ اتصالات متقاطع

قبل از اینکه به اتصالات نابرابر بپردازیم، باید درباره یک نوع مهم اتصال غیرمساوی صحبت کنیم: **cross join**. یک cross join با همه ترکیبات ممکن سطرها از `x` و `y` منطبق است، که به او دادن `TRUE` برای شرط join می‌دهد:

```{r}
x |> 
  full_join(y, join_by(), keep = TRUE)
```

معمولاً برای تولید داده‌های تصادفی از cross join استفاده نمی‌کنید، بلکه آن‌ها می‌توانند مفید باشند وقتی می‌خواهید تمام ترکیبات دو جدول را تولید کنید.

### ۲.۵.۱۹ اتصالات نابرابر

اتصالات نابرابر از `<`، `<=`، `>`، یا `>=` به جای `==` استفاده می‌کنند. یک استفاده رایج برای یافتن همه سوابق "نزدیک" است. به عنوان مثال، می‌توانیم از یک inequality join برای یافتن هر پرواز استفاده کنیم که کمتر از یک ساعت قبل از آن پرواز دیگری با مبدأ یکسان انجام شده:

```{r}
flights2 <- flights |> 
  select(year, month, day, hour, origin, dest, tailnum, carrier)

flights2 |> 
  inner_join(
    flights2, 
    join_by(origin, dest, hour <= hour)
  )
```

این مفید است برای محاسبه اختلافات بین مشاهدات. برای مثال، می‌توانیم از این برای محاسبه فاصله زمانی بین هر پرواز با پرواز بعدی از همان مبدأ استفاده کنیم:

```{r}
flights |> 
  group_by(origin) |> 
  arrange(year, month, day, hour) |> 
  mutate(
    time_diff = time_hour - lag(time_hour),
    .before = time_hour
  )
```

این یک تکنیک مهم است هنگامی که می‌خواهید مشاهدات متوالی را مقایسه کنید.

### ۳.۵.۱۹ اتصالات غلتشی

اتصالات غلتشی (Rolling joins) نوع خاصی از اتصالات نابرابر هستند که بسیار قدرتمند هستند. اجازه دهید یک دیتافریم جالب بسازیم:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03"))
)
parties
```

و بیایید یک مجموعه از تولدها ایجاد کنیم:

```{r}
set.seed(123)
employees <- tibble(
  name = sample(babynames::babynames$name, 100),
  birthday = ymd("2022-01-01") + (sample(365, 100, replace = TRUE) - 1)
)
employees
```

و برای هر کارمند می‌خواهیم آخرین تاریخ مهمانی را که قبل از تولدشان (یا در همان روز) می‌آید پیدا کنیم. می‌توانیم آن را با یک rolling join بیان کنیم:

```{r}
employees |> 
  left_join(parties, join_by(closest(birthday >= party)))
```

با این حال، یک مشکل با این رویکرد وجود دارد: افرادی که تولدشان قبل از 10 ژانویه است مهمانی دریافت نمی‌کنند:

```{r}
employees |> 
  anti_join(parties, join_by(closest(birthday >= party)))
```

برای حل این مشکل باید مسئله را به روش متفاوتی حل کنیم، با اتصالات همپوشانی.

### ۴.۵.۱۹ اتصالات همپوشانی

اتصالات همپوشانی سه کمک‌کننده ارائه می‌دهند که از اتصالات نابرابر برای کار با فواصل راحت‌تر استفاده می‌کنند:

- `between(x, y_lower, y_upper)` کوتاه‌نویسی برای `x >= y_lower, x <= y_upper` است.
- `within(x_lower, x_upper, y_lower, y_upper)` کوتاه‌نویسی برای `x_lower >= y_lower, x_upper <= y_upper` است.
- `overlaps(x_lower, x_upper, y_lower, y_upper)` کوتاه‌نویسی برای `x_lower <= y_upper, x_upper >= y_lower` است.

بیایید مثال تولد را ادامه دهیم تا ببینیم چگونه ممکن است از آن‌ها استفاده کنید. یک مشکل با استراتژی که در بالا استفاده کردیم وجود دارد: هیچ مهمانی قبل از تولدهای 1-9 ژانویه نیست. بنابراین ممکن است بهتر باشد درباره بازه‌های تاریخی که هر مهمانی را شامل می‌شود صریح باشیم، و یک مورد خاص برای آن تولدهای اولیه بسازیم:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-10", "2022-10-02", "2022-12-31"))
)
parties
```

Hadley به طرز نومیدانه‌ای در ورود داده بد است، بنابراین او همچنین می‌خواست بررسی کند که دوره‌های مهمانی همپوشانی ندارند. یک راه برای انجام این کار استفاده از یک self-join برای بررسی اینکه آیا هر فاصله شروع-پایان با فاصله دیگری همپوشانی دارد:

```{r}
parties |> 
  inner_join(parties, join_by(overlaps(start, end, start, end), q < q)) |> 
  select(start.x, end.x, start.y, end.y)
```

اوه، یک همپوشانی وجود دارد، بنابراین بیایید آن مشکل را رفع کنیم و ادامه دهیم:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-10", "2022-10-02", "2022-12-31"))
)
```

حالا می‌توانیم هر کارمند را به مهمانی‌اش منطبق کنیم. این جای خوبی برای استفاده از `unmatched = "error"` است زیرا می‌خواهیم به سرعت بفهمیم آیا کارمندی مهمانی دریافت نکرده است.

```{r}
employees |> 
  inner_join(parties, join_by(between(birthday, start, end)), unmatched = "error")
```

### ۵.۵.۱۹ تمرین‌ها

1. می‌توانید توضیح دهید چه اتفاقی برای کلیدها در این equi join می‌افتد؟ چرا آن‌ها متفاوت هستند؟

```{r}
x |> full_join(y, join_by(key == key))

x |> full_join(y, join_by(key == key), keep = TRUE)
```

2. وقتی برای یافتن اینکه آیا هر دوره مهمانی با دوره مهمانی دیگری همپوشانی دارد، از `q < q` در `join_by()` استفاده کردیم؟ چرا؟ اگر این نابرابری را حذف کنید چه اتفاقی می‌افتد؟

## ۶.۱۹ خلاصه

در این فصل، یاد گرفتید چگونه از اتصالات جهش‌دهنده و فیلتری برای ترکیب داده از یک جفت دیتافریم استفاده کنید. در طول راه یاد گرفتید چگونه کلیدها را شناسایی کنید و تفاوت بین کلیدهای اولیه و خارجی. همچنین فهمیدید چگونه joinها کار می‌کنند و چگونه مشخص کنید خروجی چند سطر خواهد داشت. سرانجام، نگاهی به قدرت اتصالات غیرمساوی انداختید و چند مورد استفاده جالب دیدید.

این فصل بخش "تبدیل" کتاب را نتیجه‌گیری می‌کند که در آن تمرکز بر ابزارهایی بود که می‌توانید با ستون‌ها و tibble‌های فردی استفاده کنید. شما درباره توابع dplyr و base برای کار با بردارهای منطقی، اعداد و جداول کامل، توابع stringr برای کار با رشته‌ها، توابع lubridate برای کار با تاریخ-زمان، و توابع forcats برای کار با فاکتورها یاد گرفتید.

در بخش بعدی کتاب، درباره وارد کردن انواع مختلف داده در R به شکل تمیز بیشتر یاد خواهید گرفت.
