# 5 تمیز کردن داده‌ها
## 1.5 مقدمه
> «خانواده‌های خوشبخت همه مثل هم هستند؛ هر خانواده‌ی بدبختی به شیوه‌ی خودش بدبخت است.»
> 
> — لئو تولستوی

> «مجموعه داده‌های مرتب همه شبیه هم هستند، اما هر مجموعه داده‌ی نامرتب، به شیوه‌ی خودش نامرتب است.»
> 
> — هادلی ویکهام


در فصل‌های قبل با نحوه تصویرسازی و تبدیل داده‌ها آشنا شدید. حال زمان آن رسیده که درباره مفهومی بحث کنیم که در قلب tidyverse قرار دارد: **تمیز کردن داده‌ها (Tidy Data)**. تمیز کردن داده‌ها روشی یکسان برای سازماندهی مجموعه داده‌هاست که باعث می‌شود کار با ابزارهای tidyverse آسان‌تر و موثرتر شود.

بیشتر مجموعه داده‌های واقعی در شکل مرتب نیستند. دلایل متعددی برای این امر وجود دارد:

1. بیشتر افراد با اصول داده‌های مرتب آشنا نیستند و منطق مشترکی برای ساختاردهی به داده‌ها وجود ندارد.

2. داده‌ها اغلب برای هدف دیگری به جز تحلیل (مثل ورود داده) سازماندهی می‌شوند.

3. هر مجموعه داده آشفته به شیوه منحصر به فرد خود آشفته است، اما همه مجموعه داده‌های مرتب به شکل یکسان هستند.

در این فصل ابتدا مفهوم داده‌های مرتب و تمیز شده را تعریف خواهیم کرد و نشان خواهیم داد که چگونه از بسته **tidyr** برای مرتب کردن داده‌های آشفته استفاده کنیم.

### پیش‌نیازها

در این فصل روی بسته tidyr تمرکز خواهیم کرد که بخشی از tidyverse است:

```{r}
#| label: setup
library(tidyverse)
```

## تعریف داده‌های مرتب

می‌توانید همان داده را به روش‌های مختلف نمایش دهید. مثال زیر همان داده را به چهار شکل مختلف نشان می‌دهد. هر مجموعه داده تعداد موارد سل ثبت شده توسط سازمان جهانی بهداشت در افغانستان، برزیل و چین را در سال‌های ۱۹۹۹ و ۲۰۰۰ نشان می‌دهد.

```{r}
table1
```

```{r}
table2
```

```{r}
table3
```

```{r}
# بخش‌های جداگانه در دو جدول
table4a  # موارد
```

```{r}
table4b  # جمعیت
```

همه این جداول همان داده اصلی را نشان می‌دهند، اما در راحتی استفاده یکسان نیستند. یکی از آنها، `table1`، با ابزارهای tidyverse کار کردن آسان‌تر خواهد بود.

**سه قانون که یک مجموعه داده را مرتب می‌کند:**

1. هر متغیر باید ستون جداگانه‌ای داشته باشد.
2. هر مشاهده باید سطر جداگانه‌ای داشته باشد.
3. هر مقدار باید سلول جداگانه‌ای داشته باشد.

شکل زیر این قوانین را به صورت تصویری نشان می‌دهد:

![قوانین داده‌های مرتب](images/tidy-data.png)

این سه قانین به هم مرتبط هستند چرا که معمولاً نمی‌توانید فقط دو تا از آنها را برآورده کنید و سومی را نادیده بگیرید. این درهم تنیدگی منجر به دستورالعمل عملی ساده‌تری می‌شود:

1. هر مجموعه داده را در یک tibble قرار دهید.
2. هر متغیر را در یک ستون قرار دهید.

در این مثال، فقط `table1` مرتب است. این تنها جدولی است که هر متغیر در ستون جداگانه‌ای قرار دارد.

### چرا اطمینان از مرتب بودن داده‌ها؟

دو مزیت اصلی وجود دارد:

1. **یکسان‌سازی**: انتخاب یک روش یکسان برای ذخیره داده مزیت عمومی دارد. اگر ساختار داده‌های شما یکسان باشد، ابزارهایی که با آن کار می‌کنند نیز یکسان خواهند بود.

2. **مزیت خاص**: قرار دادن متغیرها در ستون‌ها با ساختار R هماهنگ است. R یک زبان برداری (vectorized) است، و اکثر توابع R با بردارها کار می‌کنند. این باعث می‌شود تبدیل داده‌های مرتب طبیعی احساس شود.

dplyr، ggplot2 و همه بسته‌های دیگر در tidyverse طوری طراحی شده‌اند که با داده‌های مرتب کار کنند. در ادامه چند مثال کوچک نشان خواهیم داد:

```{r}
# محاسبه نرخ برای 10000 نفر
table1 %>% 
  mutate(rate = cases / population * 10000)
```

```{r}
# محاسبه موارد برای هر سال
table1 %>% 
  count(year, wt = cases)
```

```{r}
# تصویرسازی تغییرات در طول زمان
library(ggplot2)
ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))
```

### تمرین

با استفاده از `table2` و `table4a + table4b`، محاسبات زیر را انجام دهید:

1. `rate` برای هر 10000 نفر را محاسبه کنید
2. موارد در هر سال را محاسبه کنید  
3. تغییرات در طول زمان را تصویرسازی کنید

چرا این کارها با `table1` آسان‌تر است؟

## مرتب کردن داده‌ها

اصول داده‌های مرتب ممکن است بدیهی به نظر برسند، اما در عمل اکثر داده‌ها مرتب نیستند. دو دلیل اصلی وجود دارد:

1. بیشتر افراد با اصول داده‌های مرتب آشنا نیستند، و حتی اگر باشند، مجبورند با داده‌هایی کار کنند که برای اهداف دیگری غیر از تحلیل سازماندهی شده‌اند.

2. داده‌ها اغلب برای آسان کردن ورود اطلاعات یا ارائه، نه تحلیل، سازماندهی می‌شوند.

این بدان معنی است که برای اکثر تحلیل‌های واقعی، باید کمی کار مرتب‌سازی انجام دهید. اولین قدم همیشه تشخیص متغیرها و مشاهدات است. گاهی اوقات این کار آسان است؛ گاهی اوقات باید با افراد تولیدکننده داده مشورت کنید. دومین قدم حل یکی از دو مشکل رایج است:

1. یک متغیر در چندین ستون پخش شده است.
2. یک مشاهده در چندین سطر پخش شده است.

معمولاً یک مجموعه داده فقط یکی از این مشکلات را خواهد داشت؛ هر دو داشتن ممکن است، اما معمول نیست. برای رفع این مشکلات، به دو تابع مهم در tidyr نیاز دارید:

- `pivot_longer()` طول داده را افزایش می‌دهد و عرض آن را کاهش می‌دهد.
- `pivot_wider()` عرض داده را افزایش می‌دهد و طول آن را کاهش می‌دهد.

### داده بلندتر کردن

مشکل رایج این است که نام‌های ستون‌ها نام متغیرها نیستند، بلکه **مقادیر** یک متغیر هستند. `table4a` را در نظر بگیرید: نام‌های ستون‌های `1999` و `2000` مقادیر متغیر `year` را نشان می‌دهند، هر سطر دو مشاهده (نه یکی) را نمایش می‌دهد، و هر ستون یک متغیر (نه دو) را نشان می‌دهد.

```{r}
table4a
```

برای مرتب کردن مجموعه داده‌ای مانند این، باید آن ستون‌ها را به یک جفت ستون جدید **محوری (pivot)** کنیم. برای توصیف این عملیات، به سه پارامتر نیاز داریم:

- مجموعه **ستون‌هایی** که نام‌هایشان در واقع مقادیر هستند، نه متغیرها. در این مثال، آن ستون‌ها `1999` و `2000` هستند.

- **نام متغیری** که مقادیر آن نام‌های ستون‌ها را تشکیل می‌دهند. من آن را `year` می‌نامم.

- **نام متغیری** که مقادیر آن در سلول‌ها پخش شده‌اند. من آن را `cases` می‌نامم.

با این سه پارامتر، می‌توانیم از `pivot_longer()` استفاده کنیم:

```{r}
table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
```

ستون‌هایی که محوری می‌شوند در آرگومان اول `pivot_longer()` مشخص می‌شوند. در اینجا، آن‌ها `1999` و `2000` هستند.

`names_to` نام متغیری را که در حال حاضر در نام‌های ستون‌ها ذخیره شده، نام‌گذاری می‌کند. ما آن را `"year"` نام‌گذاری کردیم.

`values_to` متغیری را که مقادیرش در حال حاضر در سلول‌ها پخش شده‌اند، نام‌گذاری می‌کند. ما آن را `"cases"` نام‌گذاری کردیم.

در نتیجه نهایی، ستون‌های محوری شده حذف می‌شوند، و دو ستون جدید اضافه می‌شوند. در غیر این صورت، روابط بین متغیرهای اصلی حفظ می‌شود.

`table4b` نیز مشکل مشابهی دارد:

```{r}
table4b %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")
```

برای ترکیب نسخه‌های مرتب شده `table4a` و `table4b` در یک tibble واحد، باید از `dplyr::left_join()` استفاده کنیم:

```{r}
tidy4a <- table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
tidy4b <- table4b %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")
left_join(tidy4a, tidy4b)
```

### داده پهن‌تر کردن

`pivot_wider()` برعکس `pivot_longer()` است. زمانی استفاده می‌شود که یک مشاهده در چندین سطر پخش شده باشد. برای مثال، `table2` را در نظر بگیرید: یک مشاهده یک کشور در یک سال است، اما هر مشاهده در دو سطر پخش شده است.

```{r}
table2
```

برای مرتب کردن این، ابتدا تحلیل می‌کنیم که مشابه `pivot_longer()` چه کار نیاز دارد. این بار تنها دو پارامتر نیاز داریم:

- **ستونی** که نام‌های متغیرها را شامل می‌شود، `type` column.

- **ستونی** که مقادیر از چندین متغیر را شامل می‌شود، `count` column.

با این اطلاعات می‌توانیم از `pivot_wider()` استفاده کنیم:

```{r}
table2 %>%
    pivot_wider(names_from = type, values_from = count)
```

همان‌طور که می‌بینید، `pivot_wider()` و `pivot_longer()` مکمل هم هستند. `pivot_longer()` مجموعه داده‌هایی را که بیش از حد پهن هستند، بلندتر می‌کند؛ `pivot_wider()` مجموعه داده‌هایی را که بیش از حد بلند هستند، پهن‌تر می‌کند.

## جداسازی و اتحاد

تا اینجا یاد گرفتید که چگونه زمانی که یک متغیر در چندین ستون پخش شده یا یک مشاهده در چندین سطر پخش شده، مشکل را حل کنید. اما گاهی دو متغیر در یک ستون ترکیب شده‌اند، یا یک متغیر در چندین ستون پخش شده است. در ادامه درباره `separate()` و `unite()` که این مشکلات را حل می‌کنند، بحث خواهیم کرد.

### جداسازی

`separate()` یک ستون را به چندین ستون تقسیم می‌کند، با جدا کردن هرجا که یک کاراکتر جداکننده ظاهر می‌شود. مثال زیر را در نظر بگیرید:

```{r}
table3
```

ستون `rate` شامل دو متغیر است: `cases` و `population`. می‌توانیم از `separate()` برای تقسیم آن به دو متغیر استفاده کنیم:

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"))
```

به طور پیش‌فرض، `separate()` هرجا که یک کاراکتر غیرعددی یا حرفی پیدا کند، جدا می‌کند. برای مثال، در کد بالا، `separate()` مقادیر `rate` را در کاراکتر forward slash جدا کرد.

اگر بخواهید یک کاراکتر خاص برای جدا کردن یک ستون استفاده کنید، می‌توانید کاراکتر را به آرگومان `sep` از `separate()` پاس کنید. برای مثال، می‌توانیم کد بالا را به صورت زیر بازنویسی کنیم:

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")
```

(رسمی‌تر، `sep` یک عبارت منظم است که در فصل بعد درباره آن بیشتر یاد خواهید گرفت.)

به انواع ستون‌های `cases` و `population` نگاه کنید: آنها ستون‌های کاراکتری هستند. این رفتار پیش‌فرض `separate()` است: ستون‌های جدا شده را به همان نوع ستون اصلی باقی می‌گذارد. اینجا، اما، مفید نیست زیرا آنها واقعاً اعداد هستند. می‌توانیم از `separate()` بخواهیم که سعی کند انواع بهتری تشخیص دهد با استفاده از `convert = TRUE`:

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE)
```

همچنین می‌توانید یک بردار از اعداد صحیح به `sep` پاس کنید. `separate()` نام‌های اعداد را به عنوان مکان‌هایی برای تقسیم تفسیر خواهد کرد. مقادیر مثبت شروع از ۱ در دورترین سمت چپ رشته‌ها؛ مقادیر منفی شروع از -۱ در دورترین سمت راست. هنگام استفاده از اعداد صحیح برای جدا کردن رشته‌ها، طول `sep` باید یکی کمتر از تعداد نام‌هایی باشد که در `into` مشخص کرده‌اید.

می‌توانید از این ترتیب برای جدا کردن دو رقم آخر هر سال استفاده کنید:

```{r}
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```

### اتحاد

`unite()` برعکس `separate()` است: چندین ستون را در یک ستون واحد ترکیب می‌کند. احتمالاً کمتر از `separate()` به آن نیاز خواهید داشت، اما هنوز ابزار مفیدی است که باید در جعبه ابزارتان داشته باشید.

می‌توانیم از `unite()` برای دوباره ترکیب کردن ستون‌های `century` و `year` که در مثال قبل ساختیم، استفاده کنیم:

```{r}
table5 %>% 
  unite(new, century, year)
```

در این حالت ما همچنین باید از آرگومان `sep` استفاده کنیم. جداکننده پیش‌فرض underscore (`_`) است، اما در اینجا ما جداکننده‌ای نمی‌خواهیم بنابراین از `""` استفاده می‌کنیم:

```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```

## مقادیر گم‌شده

تغییر نمایش یک مجموعه داده باعث آشکار شدن مقادیر گم‌شده می‌شود که قبلاً وجود داشتند اما صریح نبودند. متأسفانه، همه مقادیر گم‌شده صریح نیستند - یعنی می‌توانید یک سلول خالی ببینید، یا مقادیر گم‌شده ضمنی هستند - یعنی ساختار داده نشان‌دهنده وجود آنهاست.

بیایید این تمایز را با یک مثال ساده نشان دهیم:

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    4,    2,    3),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

این مجموعه داده دو مقدار گم‌شده دارد:

- بازدهی برای Q4 سال 2015 صراحتاً گم‌شده است، زیرا سلول آن شامل `NA` است.

- بازدهی برای Q1 سال 2016 ضمناً گم‌شده است، زیرا در مجموعه داده ظاهر نمی‌شود.

یکی از راه‌های فکر کردن در مورد این تمایز این است:

- مقدار صریحاً گم‌شده، عدم حضور مقدار است؛ یعنی `NA`.
- مقدار ضمناً گم‌شده، عدم حضور سطر کامل است.

راه تبدیل مقادیر ضمناً گم‌شده به صراحتاً گم‌شده، پهن‌تر کردن داده است:

```{r}
stocks %>% 
  pivot_wider(names_from = year, values_from = return)
```

چون این سلول‌ها در نمایش اصلی وجود نداشتند، در آنها به صراحت `NA` قرار می‌گیرد.

این ابزارها همچنین اجازه کنترل نحوه نمایش مقادیر گم‌شده در عملیات `pivot_longer` را نیز می‌دهند. آرگومان `values_drop_na = TRUE` در `pivot_longer()` صراحتاً مقادیر گم‌شده را ضمنی می‌کند:

```{r}
stocks %>% 
  pivot_wider(names_from = year, values_from = return) %>% 
  pivot_longer(
    cols = c(`2015`, `2016`), 
    names_to = "year", 
    values_to = "return", 
    values_drop_na = TRUE
  )
```

یکی دیگر از ابزارهای مهم برای آشکار کردن مقادیر ضمناً گم‌شده و تبدیل آنها به صراحتاً گم‌شده، `complete()` است:

```{r}
stocks %>% 
  complete(year, qtr)
```

`complete()` تمام ترکیبات منحصر به فرد ستون‌هایی که برایش مشخص کرده‌اید را می‌گیرد، و اطمینان حاصل می‌کند که جدول اصلی شامل همه آن مقادیر است، و هرجا که لازم باشد، `NA` را پر می‌کند.

هنگام کار با داده‌های گم‌شده، یک ابزار مفید دیگر نیز وجود دارد که باید از آن آگاه باشید: `fill()`. گاهی اوقات مقادیر گم‌شده نشان‌دهنده این است که مقدار قبلی باید "به پایین منتقل شود":

```{r}
treatment <- tribble(
  ~ person,           ~ treatment, ~response,
  "Derrick Whitmore", 1,           7,
  NA,                 2,           10,
  NA,                 3,           9,
  "Katherine Burke",  1,           4
)
```

می‌توانید مقادیر گم‌شده را با مقدار اخیر غیر-گم‌شده پر کنید. این چیزی است که `fill()` انجام می‌دهد:

```{r}
treatment %>% 
  fill(person)
```

## مطالعه موردی

برای به پایان رساندن این فصل، بیایید همه چیزهایی که یاد گرفته‌ایم را در یک مطالعه موردی واقعی به کار ببریم. مجموعه داده `tidyr::who` شامل موارد سل (TB) تقسیم‌بندی شده بر اساس سن، جنسیت و روش تشخیص است. این داده از گزارش بهداشت جهانی سال 2014 سازمان جهانی بهداشت می‌آید و در <http://www.who.int/tb/country/data/download/en/> در دسترس است.

ساختار این مجموعه داده بسیار عمومی است. سازمان جهانی بهداشت مجموعه داده‌هایی را در این قالب حفظ می‌کند و اگر با داده‌هایی از سازمان جهانی بهداشت کار کنید، احتمالاً داده‌هایی مشابه این را خواهید دید.

```{r}
who
```

این یک مجموعه داده بسیار عمومی است، و برای مرتب کردن آن، باید چندین مرحله انجام دهیم. مانند بسیاری از مجموعه داده‌های دنیای واقعی، مجموعه داده `who` شامل کدهای زائد ستون‌ها، بسیاری از مقادیر گم‌شده، و نام‌گذاری عجیب متغیرها است. به یک‌یک حل‌شان می‌کنیم.

به نظر می‌رسد که `country`، `iso2` و `iso3` سه متغیر هستند که کشوری واحد را به سه روش مختلف مشخص می‌کنند. باید این امر را تأیید کنیم:

```{r}
who %>% count(country) %>% print(n = Inf)
```

```{r}
who %>% count(iso2) %>% print(n = Inf)
```

```{r}
who %>% count(iso3) %>% print(n = Inf)
```

و در واقع اینطور است: `iso2` و `iso3` کدهای دو و سه حرفی کشور هستند. احتمالاً در این تحلیل ما نیاز به `iso2` و `iso3` نداریم، بنابراین آنها را حذف می‌کنیم. `drop_na()` سطرهایی را که مقادیر گم‌شده زیادی دارند، حذف می‌کند:

```{r}
who1 <- who %>% 
  select(-iso2, -iso3) %>% 
  drop_na(new_sp_m014:newrel_f65)
```

بعد، نیاز داریم که ستون‌هایی از `new_sp_m014` تا `newrel_f65` را جمع‌آوری کنیم. ما نمی‌دانیم که این ستون‌ها چه چیزی را نمایش می‌دهند، بنابراین برای اکنون آنها را `key` و `value` می‌نامیم:

```{r}
who2 <- who1 %>% 
  pivot_longer(
    cols = new_sp_m014:newrel_f65, 
    names_to = "key", 
    values_to = "cases", 
    values_drop_na = TRUE
  )
who2
```

می‌توانیم با شمارش مقادیر در ستون `key` ایده‌ای از ساختار مقادیر بگیریم:

```{r}
who2 %>% count(key)
```

ممکن است بتوانید الگویی در نام‌ها تشخیص دهید. نام‌ها ساختار کدگذاری ضخیمی دارند. متأسفانه، نام‌های ستون‌ها کمی ناسازگار هستند زیرا به جای `new_rel` ما `newrel` داریم (نکته نداری از دست رفته). شما می‌توانید این را در آنجا ببینید که کدها با `newrel` شروع می‌شوند، نه `new_rel`. ابتدا این مسئله را رفع می‌کنیم:

```{r}
who3 <- who2 %>% 
  mutate(key = stringr::str_replace(key, "newrel", "new_rel"))
who3
```

می‌توانیم مقادیر هر کد را با دو پاس `separate()` جدا کنیم. اولی در هر underscore تقسیم می‌کند:

```{r}
who4 <- who3 %>% 
  separate(key, c("new", "type", "sexage"), sep = "_")
who4
```

سپس ممکن است بخواهیم ستون `new` را بررسی کنیم:

```{r}
who4 %>% count(new)
```

این ستون ثابت است در این مجموعه داده، بنابراین می‌توانیم آن را حذف کنیم. همچنین `iso2` و `iso3` را نیز حذف می‌کنیم زیرا زائد هستند:

```{r}
who5 <- who4 %>% 
  select(-new, -iso2, -iso3)
```

بعد جنسیت و سن را جدا می‌کنیم که در ستون `sexage` درهم ترکیب شده‌اند:

```{r}
who6 <- who5 %>% 
  separate(sexage, c("sex", "age"), sep = 1)
who6
```

حالا مجموعه داده `who` مرتب است!

معمولاً ترجیح می‌دهیم این فرآیند را به صورت یک سری عملیات با pipe انجام دهید:

```{r}
who %>%
  select(-iso2, -iso3) %>% 
  drop_na(new_sp_m014:newrel_f65) %>% 
  pivot_longer(
    cols = new_sp_m014:newrel_f65, 
    names_to = "key", 
    values_to = "cases", 
    values_drop_na = TRUE
  ) %>% 
  mutate(
    key = stringr::str_replace(key, "newrel", "new_rel")
  ) %>%
  separate(key, c("new", "var", "sexage")) %>% 
  select(-new, -iso2, -iso3) %>% 
  separate(sexage, c("sex", "age"), sep = 1)
```

### تمرین‌ها

1. در این مطالعه موردی، من ادعا کردم که `iso2` و `iso3` زائد با `country` هستند. این ادعا را تأیید کنید.

2. برای هر کشور، سال و جنسیت کل تعداد موارد سل را محاسبه کنید. یک تصویرسازی اطلاعاتی بسازید.

## خلاصه

در این فصل، مفهوم داده‌های مرتب را یاد گرفتید: داده‌هایی که هر متغیر در یک ستون و هر مشاهده در یک سطر قرار دارند. داده‌های مرتب کار با tidyverse را آسان‌تر می‌کنند، زیرا یک ساختار ثابت برای ذخیره داده ارائه می‌دهند که بسته‌های مختلف می‌توانند از آن استفاده کنند.

همچنین با چهار تابع کلیدی آشنا شدید:

- `pivot_longer()` داده‌ها را از پهن به بلند تبدیل می‌کند
- `pivot_wider()` داده‌ها را از بلند به پهن تبدیل می‌کند  
- `separate()` یک ستون را به چندین ستون تقسیم می‌کند
- `unite()` چندین ستون را به یک ستون ترکیب می‌کند

این ابزارها اجازه مرتب کردن اکثر مجموعه داده‌های آشفته را می‌دهند. البته هنوز ابزارهای بیشتری وجود دارند که ممکن است برای موارد خاص نیاز داشته باشید - بسته tidyr را بررسی کنید تا ببینید آنها چی هستند.

در فصل بعد، روی داده‌های رابطه‌ای - چگونه چندین جدول مرتبط را ترکیب کنید - تمرکز خواهیم کرد.
