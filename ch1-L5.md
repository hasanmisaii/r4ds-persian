# 5 تمیز کردن داده‌ها
## 1.5 مقدمه
> «خانواده‌های خوشبخت همه مثل هم هستند؛ هر خانواده‌ی بدبختی به شیوه‌ی خودش بدبخت است.»
> 
> — لئو تولستوی

> «مجموعه داده‌های مرتب همه شبیه هم هستند، اما هر مجموعه داده‌ی نامرتب، به شیوه‌ی خودش نامرتب است.»
> 
> — هادلی ویکهام

در این فصل، شما یک روش ثابت برای سازماندهی داده‌های خود در R با استفاده از رویکردی به نام **داده‌های تمیز** (tidy data) خواهید آموخت. آماده‌سازی داده‌ها به این شکل و قالب نیاز به کمی تلاش از قبل دارد، اما این تلاش در درازمدت نتیجه می‌دهد. وقتی داده‌های مرتب و ابزارهای مرتب ارائه‌شده توسط بسته‌های tidyverse را داشته باشید، زمان بسیار کمتری را صرف تغییر شکل داده‌ها از یک نمایش به نمایش دیگر خواهید کرد و به شما این امکان را می‌دهد که زمان بیشتری را صرف سوالات مربوط به داده‌ها کنید.

در این فصل، ابتدا تعریف داده‌های تمیز را یاد خواهید گرفت و به‌کارگیری آن به یک مجموعه داده ساده را نیز خواهید دید. سپس، به ابزار اصلی که برای مرتب‌سازی داده‌ها استفاده خواهید کرد، خواهیم پرداخت: چرخش. چرخش، این امکان را به شما می‌دهد که بدون تغییر هر گونه مقداری، شکل داده‌ها را تغییر دهید.

### 1.1.5 پیش‌نیازها

در این فصل، روی بسته tidyr تمرکز خواهیم کرد، بسته‌ای که یک دسته ابزار برای کمک به تمیز کردن داده‌ها فراهم می‌کند. tidyr عضوی از هسته tidyverse است.

```{r}
library(tidyverse)
```
از این فصل به بعد، پیام بارگذاری از library(tidyverse) را متوقف خواهیم کرد.

## 2.5 تعریف داده‌های مرتب

می‌توانید داده‌های یکسان را به شیوه‌های مختلف نمایش دهید. مثال زیر نشان می‌دهد که داده‌های یکسان در سه شیوه مختلف سازمان‌دهی شده‌اند. هر مجموعه داده مقادیر یکسان از چهار متغیر را نشان می‌دهد: *کشور*، *سال*، *جمعیت* و تعداد موارد ثبت شده سل (توبرکلوز)، اما هر مجموعه داده مقادیر این متغیرها را به یک شیوه متفاوت سازمان‌دهی می‌کند.

```{r}
table1
#> # A tibble: 6 × 4
#>   country      year  cases population
#>   <chr>       <dbl>  <dbl>      <dbl>
#> 1 Afghanistan  1999    745   19987071
#> 2 Afghanistan  2000   2666   20595360
#> 3 Brazil       1999  37737  172006362
#> 4 Brazil       2000  80488  174504898
#> 5 China        1999 212258 1272915272
#> 6 China        2000 213766 1280428583

table2
#> # A tibble: 12 × 4
#>   country      year type           count
#>   <chr>       <dbl> <chr>          <dbl>
#> 1 Afghanistan  1999 cases            745
#> 2 Afghanistan  1999 population  19987071
#> 3 Afghanistan  2000 cases           2666
#> 4 Afghanistan  2000 population  20595360
#> 5 Brazil       1999 cases          37737
#> 6 Brazil       1999 population 172006362
#> # ℹ 6 more rows

table3
#> # A tibble: 6 × 3
#>   country      year rate             
#>   <chr>       <dbl> <chr>            
#> 1 Afghanistan  1999 745/19987071     
#> 2 Afghanistan  2000 2666/20595360    
#> 3 Brazil       1999 37737/172006362  
#> 4 Brazil       2000 80488/174504898  
#> 5 China        1999 212258/1272915272
#> 6 China        2000 213766/1280428583
```

همه این جداول همان داده اصلی را نشان می‌دهند، اما در راحتی استفاده یکسان نیستند. کار با یکی از آنها، `table1`، درون tidyverse بسیار آسان‌تر خواهد بود زیرا **تمیز** است.

سه قانون مرتبط با هم وجود دارد که یک مجموعه داده را مرتب می‌کند:

1. هر متغیر یک ستون است؛ هر ستون یک متغیر است.
2. هر مشاهده یک سطر است؛ هر سطر یک مشاهده است.
3. هر مقدار یک سلول است؛ هر سلول یک مقدار واحد است.

شکل 1.5 این قوانین را به صورت تصویری نشان می‌دهد:

![Alt text](Images/tidy-1.png)
*شکل 1.5: سه قانون یک مجموعه داده را مرتب می‌کند: متغیرها ستون‌ها، مشاهدات سطرها و مقادیر سلول‌ها هستند.*

چرا باید از مرتب بودن داده‌هایتان اطمینان حاصل کنید؟ دو مزیت اصلی وجود دارد:

1. انتخاب یک روش ثابت و یکسان برای ذخیره داده یک مزیت کلی دارد. اگر ساختار داده‌های شما یکسان باشند، ابزارهایی که با آن کار می‌کنند نیز یکسان خواهند بود.
2. مزیت خاص این است که قرار دادن متغیرها در ستون‌ها با ساختار R هماهنگ است. همانطور که در بخش 1.3.3 و بخش 2.5.3 آموختید، R یک زبان برداری (vectorized) است، و اکثر توابع R با بردارها کار می‌کنند. این باعث می‌شود تبدیل داده‌های مرتب طبیعی احساس شود.

بسته‌هایی مانند dplyr، ggplot2 و همه بسته‌های دیگر در tidyverse برای کار با داده‌های مرتب طراحی شده‌اند. در اینجا چند مثال کوچک وجود دارد که نشان می‌دهد چگونه می‌توانید با table1 کار کنید.

```{r}
# محاسبه نرخ مبتلا برای هر 10000 نفر
table1 |>
  mutate(rate = cases / population * 10000)
#> # A tibble: 6 × 5
#>   country      year  cases population  rate
#>   <chr>       <dbl>  <dbl>      <dbl> <dbl>
#> 1 Afghanistan  1999    745   19987071 0.373
#> 2 Afghanistan  2000   2666   20595360 1.29 
#> 3 Brazil       1999  37737  172006362 2.19 
#> 4 Brazil       2000  80488  174504898 4.61 
#> 5 China        1999 212258 1272915272 1.67 
#> 6 China        2000 213766 1280428583 1.67

# محاسبه تعداد موارد مبتلا برای هر سال
table1 |> 
  group_by(year) |> 
  summarize(total_cases = sum(cases))
#> # A tibble: 2 × 2
#>    year total_cases
#>   <dbl>       <dbl>
#> 1  1999      250740
#> 2  2000      296920

# تصویرسازی تغییرات در طول زمان
ggplot(table1, aes(x = year, y = cases)) +
  geom_line(aes(group = country), color = "grey50") +
  geom_point(aes(color = country, shape = country)) +
  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000
```
![Alt text](Images/unnamed-chunk-3-1.png)
### تمرین

1. برای هر یک از جداول نمونه در بالا، توضیح دهید که هر مشاهده و هر ستون چه چیزی را نشان می‌دهد.
2. فرآیندی را که برای محاسبه نرخ مبتلا به سل برای جدول ۲ و جدول ۳ استفاده خواهید کرد، ترسیم کنید. شما باید چهار عملیات انجام دهید:
   الف. تعداد موارد سل در هر کشور در هر سال را استخراج کنید.
   ب. برای هر کشور در هر سال جمعیت متناظر را استخراج کنید.
   ج. تعداد موارد مبتلا را بر جمعیت تقسیم و در 10000 ضرب کنید.
   د. نتیجه را در یک جای مناسب ذخیره کنید.

شما هنوز تمام توابعی را که برای انجام این عملیات نیاز دارید یاد نگرفته‌اید، اما هنوز باید بتوانید تبدیل‌های مورد نیاز را در نظر بگیرید.

## 3.5 داده بلندتر کردن

اصول داده‌های مرتب ممکن است آنقدر بدیهی به نظر برسند که از خود بپرسید آیا تا به حال با مجموعه داده‌ای مواجه شده‌اید که مرتب نباشد؟ اما متأسفانه، در عمل اکثر داده‌ها مرتب نیستند. دو دلیل اصلی وجود دارد:

1. داده‌ها اغلب برای تسهیل اهدافی به غیر از تحلیل سازمان‌دهی می‌شوند. برای مثال، داده‌ها اغلب برای آسان کردن ورود اطلاعات، نه تحلیل، ساختاربندی می‌شوند.
2. بیشتر افراد با اصول داده‌های مرتب آشنا نیستند، و استخراج آنها توسط خودتان دشوار است، مگر اینکه زمان زیادی را صرف کار با داده‌ها کنید.

این بدان معنی است که برای اکثر تحلیل‌های واقعی، باید کمی کار مرتب‌سازی انجام دهید. اولین قدم همیشه تشخیص متغیرها و مشاهدات است. گاهی اوقات این کار آسان است؛ گاهی اوقات باید با افراد تولیدکننده داده مشورت کنید. سپس، داده‌های خود را در قالب مرتب با قرار دادن متغیرها در ستون‌ها و مشاهدات در سطرها چرخش می‌دهید.

بسته tidyr دو تابع برای چرخش داده‌ها ارائه می‌دهد: ‍‍‍‍`()pivot_longer` و `()pivot_wider`. ابتدا با تابع `()pivot_longer` به دلیل متداول بودن بیشتر شروع می‌کنیم. بیایید به چند مثال بپردازیم.

### 1.3.5 داده‌ها در نام ستون‌ها
مجموعه داده‌های `billboard`، ثبت رتبه آهنگ‌ها در سال ۲۰۰۰ را نشان می‌دهد:
```{r}
billboard
#> # A tibble: 317 × 79
#>   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5
#>   <chr>        <chr>               <date>       <dbl> <dbl> <dbl> <dbl> <dbl>
#> 1 2 Pac        Baby Don't Cry (Ke… 2000-02-26      87    82    72    77    87
#> 2 2Ge+her      The Hardest Part O… 2000-09-02      91    87    92    NA    NA
#> 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66
#> 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67
#> 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17
#> 6 98^0         Give Me Just One N… 2000-08-19      51    39    34    26    26
#> # ℹ 311 more rows
#> # ℹ 71 more variables: wk6 <dbl>, wk7 <dbl>, wk8 <dbl>, wk9 <dbl>, …
```

در این مجموعه داده، هر مشاهده (سطر) یک آهنگ است. سه ستون نخست (`artist`، `track` و `date.entered`) متغیرهای توصیف‌کننده آهنگ هستند. سپس، ۷۶ ستون بعدی (`wk76`-`wk1`) رتبه آهنگ در هر هفته را توصیف می‌کنند. در اینجا، نام ستون‌ها یک متغیر (`week`) و مقادیر سلول‌ها متغیر دیگری (`rank`) هستند.

برای مرتب کردن این مجموعه داده از `()pivot_longer` استفاده می‌کنیم:

```{r}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank"
  )
#> # A tibble: 24,092 × 5
#>    artist track                   date.entered week   rank
#>    <chr>  <chr>                   <date>       <chr> <dbl>
#>  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87
#>  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82
#>  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72
#>  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77
#>  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87
#>  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94
#>  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99
#>  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA
#>  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA
#> 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA
#> # ℹ 24,082 more rows
```
پس از چرخش داده‌ها، سه استدلال کلیدی وجود دارد:
- آرگومان `cols` مشخص می‌کند که کدام ستون‌ها باید در سطر قرار بگیرند، به عبارتی کدام ستون‌ها متغیر نیستند. این آرگومان مقادیر یکسانی همانند `()select` اتخاذ می‌کند، پس می‌توانیم از `c(artist, track, date.entered)!` یا `starts_with("wk")` استفاده کنیم.
- آرگومان `names_to` متغیر ذخیره‌شده در `cols` را نام‌گذاری می‌کند که آن را `week` نام‌گذاری کردیم.
- آرگومان `values_to` متغیر ذخیره‌شده در مقادیر سلول‌ها را نام‌گذاری می‌کند که آن را `rank` نام‌گذاری کردیم.

توجه کنید که در کد بالا، `"week"` و `"rank"` در علامت نقل قول قرار گرفته‌اند، به این دلیل که متغیرهای جدیدی هستند و در حال ایجاد کردنشان هستیم، و هنوز در زمان فراخوانی `()pivot_longer` وجود ندارند.

حالا بیایید توجه خود را به چارچوب داده طولانی‌تر به‌دست‌آمده معطوف کنیم. چه اتفاقی می‌افتد اگر یک آهنگ کمتر از ۷۶ هفته در بین ۱۰۰ آهنگ برتر باشد؟ برای مثال آهنگ «Baby Don’t Cry» از گروه «2 pac» را در نظر بگیرید. خروجی بالا نشان می‌دهد که این آهنگ فقط به مدت ۷ هفته در بین ۱۰۰ آهنگ برتر بوده است و تمام هفته‌های باقی‌مانده با مقادیر گمشده پر شده‌اند. این `NA`ها واقعاً مشاهدات ناشناخته را نشان نمی‌دهند؛ آنها به واسطه ساختار مجموعه داده ایجاد شده‌اند، پس می‌توانیم با قرار دادن `values_drop_na = TRUE` در `()pivot_longer` آنها را حذف کنیم.

```{r}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  )
#> # A tibble: 5,307 × 5
#>   artist track                   date.entered week   rank
#>   <chr>  <chr>                   <date>       <chr> <dbl>
#> 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87
#> 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82
#> 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72
#> 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77
#> 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87
#> 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94
#> # ℹ 5,301 more rows
```
تعداد سطرها اکنون بسیار کمتر شده است که نشان می‌دهد بسیاری از سطرها با مقادیر `NA` از مجموعه داده حذف شده‌اند.

شاید برای شما هم این سوال پیش بیاید که اگر یک آهنگ بیش از ۷۶ هفته در بین ۱۰۰ آهنگ برتر باشد، چه اتفاقی می‌افتد؟ از این مجموعه داده نمی‌توان به این سوال پاسخ داد، اما می‌توانید حدس بزنید که ستون‌های اضافی `wk77`، `wk78` و ... به مجموعه داده اضافه می‌شوند.

این داده‌ها اکنون مرتب هستند، اما می‌توانیم محاسبات پیش رو را با تبدیل مقادیر `week` از رشته‌های کاراکتری به اعداد با استفاده از `()mutate` و `()readr::parse_number` کمی آسان‌تر کنیم. `()parse_number` یک تابع مفید است که اولین عدد از یک رشته را استخراج می‌کند و تمام کارکترهای دیگر را نادیده می‌گیرد.
```{r}
billboard_longer <- billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  ) |> 
  mutate(
    week = parse_number(week)
  )
billboard_longer
#> # A tibble: 5,307 × 5
#>   artist track                   date.entered  week  rank
#>   <chr>  <chr>                   <date>       <dbl> <dbl>
#> 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26       1    87
#> 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26       2    82
#> 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26       3    72
#> 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26       4    77
#> 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26       5    87
#> 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26       6    94
#> # ℹ 5,301 more rows
```
حالا که تمام شماره‌های هفته را در یک متغیر و تمام مقادیر رتبه را در متغیر دیگر داریم، در موقعیت خوبی هستیم تا چگونگی تغییر رتبه آهنگ‌ها در طول زمان را تصویرسازی کنیم. کد در زیر نشان داده شده است و خروجی نیز در شکل 2.5 است. می‌توانیم ببینیم که تعداد بسیار کمی از آهنگ‌ها بیش از ۲۰ هفته در بین ۱۰۰ آهنگ برتر باقی می‌مانند.
```{r}
billboard_longer |> 
  ggplot(aes(x = week, y = rank, group = track)) + 
  geom_line(alpha = 0.25) + 
  scale_y_reverse()
```

![Alt text](Images/fig-billboard-ranks-1.png)
*شکل 2.5: یک نمودار خطی که نشان می‌دهد چگونه رتبه یک آهنگ در طول زمان تغییر می‌کند.*

 ### 2.3.5 چرخش چگونه کار می‌کند؟
حالا که دیدید چطور می‌توانیم از چرخش برای تغییر شکل داده‌ها استفاده کنیم، بیایید با صرف کمی زمان در مورد کاری که چرخش با داده‌ها انجام می‌دهد، درک بهتری پیدا کنیم. بیایید با یک مجموعه داده بسیار ساده شروع کنیم تا راحت‌تر ببینیم چه اتفاقی می‌افتد. فرض کنید سه بیمار با شناسه‌های (`id`) A، B و C داریم و برای هر بیمار دو بار فشار خون اندازه‌گیری شده‌اند. داده‌ها را با `()tribble`، یک تابع مفید برای ساخت جدول‌های کوچک، ایجاد خواهیم کرد:
```{r}
df <- tribble(
  ~id,  ~bp1, ~bp2,
   "A",  100,  120,
   "B",  140,  115,
   "C",  120,  125
)
```
می‌خواهیم مجموعه داده جدید سه متغیر داشته باشد: `id` (هم اکنون در مجموعه داده موجود است)، `measurement` (نام ستون‌ها) و `value` (مقادیر سلول‌ها). برای رسیدن به این هدف، نیاز به چرخش `df` به صورت طولانی‌تر داریم:
```{r}
df |> 
  pivot_longer(
    cols = bp1:bp2,
    names_to = "measurement",
    values_to = "value"
  )
#> # A tibble: 6 × 3
#>   id    measurement value
#>   <chr> <chr>       <dbl>
#> 1 A     bp1           100
#> 2 A     bp2           120
#> 3 B     bp1           140
#> 4 B     bp2           115
#> 5 C     bp1           120
#> 6 C     bp2           125
```

تغییر شکل چگونه کار می‌کند؟ اگر به آن به صورت ستون به ستون فکر کنیم، درک آن آسان‌تر خواهد بود. همانند شکل 3.5، مقادیر در ستونی که هم اکنون در مجموعه داده اولیه یک متغیر بوده است (`id`) باید یک بار به ازای هر ستونی که چرخیده می‌شود، تکرار شوند.

![Alt text](Images/variables.png)
*شکل 3.5: ستون‌هایی که هم اکنون متغیر هستند باید یک بار به ازای هر ستونی که چرخیده می‌شوند، تکرار گردند.*

نام ستون‌ها به عنوان مقادیر در متغیر جدید تبدیل می‌شوند که نام‌گذاری آن با آرگومان `names_to` انجام می‌شود، همان طور که در شکل 4.5 نشان داده شده است. آنها باید به ازای هر سطر در مجموعه داده اولیه یک بار تکرار شوند.

![Alt text](Images/column-names.png)
*شکل 4.5: نام ستون‌ها از ستون‌های چرخیده‌شده به مقادیر ستون جدید تبدیل می‌شوند. برای هر سطر از مجموعه داده اولیه، مقادیر باید یک بار تکرار شوند.*

مقادیر سلول نیز به مقادیری در یک متغیر جدید تبدیل می‌شوند که نام آن با `values_to` تعریف می‌شود. آن‌ها سطر به سطر از هم جدا می‌شوند. شکل ۵.۵ این فرآیند را نشان می‌دهد.


![Alt text](Images/cell-values.png)
*شکل 5.5: تعداد مقادیر حفظ می‌شود (تکرار نمی‌شود)، اما سطر به سطر از هم جدا می‌شوند.*

### 3.3.5 متغیرهای زیاد در نام ستون‌ها
وضعیت چالش‌برانگیز دیگر زمانی است که چندین قطعه اطلاعات در نام ستون‌ها فشرده شده باشند و بخواهید آنها را در متغیرهای جدید جداگانه ذخیره کنید. برای مثال، مجموعه داده `who2` را در نظر بگیرید که منبع `table1` و جداول مشابهی که در بالا دیده‌اید، است.
```{r}
who2
#> # A tibble: 7,240 × 58
#>   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554
#>   <chr>       <dbl>    <dbl>     <dbl>     <dbl>     <dbl>     <dbl>
#> 1 Afghanistan  1980       NA        NA        NA        NA        NA
#> 2 Afghanistan  1981       NA        NA        NA        NA        NA
#> 3 Afghanistan  1982       NA        NA        NA        NA        NA
#> 4 Afghanistan  1983       NA        NA        NA        NA        NA
#> 5 Afghanistan  1984       NA        NA        NA        NA        NA
#> 6 Afghanistan  1985       NA        NA        NA        NA        NA
#> # ℹ 7,234 more rows
#> # ℹ 51 more variables: sp_m_5564 <dbl>, sp_m_65 <dbl>, sp_f_014 <dbl>, …
```

این مجموعه داده که توسط سازمان جهانی بهداشت گردآوری شده است، اطلاعاتی درباره تشخیص سل ثبت کرده است. دو ستون موجود است که هم اکنون متغیر هستند و به سادگی تفسیر می‌شوند. `country` و `year`. پس از آنها 56 ستون مانند `sp_m_014`، `ep_m_4554` ، `rel_m_3544` و قرار دارند. اگر به این ستون‌ها با دقت نگاه کنید، متوجه یک الگو خواهید شد. نام هر ستون از سه قسمت تشکیل شده است که با `_` از هم جدا شده‌اند. نخستین بخش،
`sp`\`rel`\`ep`، 
توصیف‌کننده روش استفاده‌شده برای تشخیص بیماری است، دومین بخش،
`m`\`f` 
جنسیت (gender) است (که به عنوان یک متغیر دودویی در این مجموعه داده کدگذاری شده است)، و بخش سوم
`014`\`1524`\`2534`\`3544`\`4554`\`5564`\`65` 
محدوده سنی (`age`) است (برای مثال، `014` محدوده سنی 0-14 را نشان می‌دهد).

بنابراین، در این مورد شش قطعه اطلاعات ثبت‌شده در `who2` داریم: کشور و سال (از قبل ستون‌ها وجود دارند)، روش تشخیص بیماری، دسته‌بندی جنسیت و دسته‌بندی محدوده سنی (که در نام ستون‌های دیگر وجود دارد)؛ و تعداد بیماران در آن دسته (مقادیر سلول). برای سازمان‌دهی این شش قطعه اطلاعات در شش ستون جداگانه، از `()pivot_longer` با بردار نام ستون‌ها برای `names_to`، جداسازی نام متغیرهای اولیه به قطعات جداگانه برای `names_sep` و همچنین یک نام ستون برای `values_to` استفاده می‌کنیم.
```{r}
who2 |> 
  pivot_longer(
    cols = !(country:year),
    names_to = c("diagnosis", "gender", "age"), 
    names_sep = "_",
    values_to = "count"
  )
#> # A tibble: 405,440 × 6
#>   country      year diagnosis gender age   count
#>   <chr>       <dbl> <chr>     <chr>  <chr> <dbl>
#> 1 Afghanistan  1980 sp        m      014      NA
#> 2 Afghanistan  1980 sp        m      1524     NA
#> 3 Afghanistan  1980 sp        m      2534     NA
#> 4 Afghanistan  1980 sp        m      3544     NA
#> 5 Afghanistan  1980 sp        m      4554     NA
#> 6 Afghanistan  1980 sp        m      5564     NA
#> # ℹ 405,434 more rows
```
یک جایگزین برای `names_sep`، روش `names_pattern` است که می‌توانید پس از یادگیری عبارات باقاعده در فصل ۱۵، از آن برای استخراج متغیرها از سناریوهای نامگذاری پیچیده‌تر استفاده کنید.

از نظر مفهومی، این تنها یک تغییر جزئی برای موارد ساده‌تری است که تاکنون دیده‌اید. شکل 6.5 ایده اولیه را نشان می‌دهد: اکنون، به جای اینکه نام ستون‌ها در یک ستون واحد قرار گیرند، در چندین ستون قرار می‌گیرند. می‌توانید تصور کنید که این عمل در دو گام انجام می‌پذیرد (ابتدا چرخش و سپس جداسازی) اما عملاً، در یک مرحله اتفاق می‌افتد زیرا این روش سریع‌تر است.

![Alt text](Images/multiple-names.png)
*شکل 6.5: چرخش ستون‌هایی که نام آنها شامل چندین قطعه اطلاعات است، به این معنی است که اکنون نام هر ستون، مقادیر موجود در چندین ستون خروجی را پر می‌کند.*

### 4.3.5 نام داده‌ها و متغیرها در سرستون‌ها
مرحله بعدی افزایش پیچیدگی زمانی است که نام ستون‌ها شامل ترکیبی از مقادیر متغیرها و نام متغیرها باشند. برای مثال، مجموعه داده‌های `household` را در نظر بگیرید:
```{r}
household
#> # A tibble: 5 × 5
#>   family dob_child1 dob_child2 name_child1 name_child2
#>    <int> <date>     <date>     <chr>       <chr>      
#> 1      1 1998-11-26 2000-01-29 Susan       Jose       
#> 2      2 1996-06-22 NA         Mark        <NA>       
#> 3      3 2002-07-11 2004-04-05 Sam         Seth       
#> 4      4 2004-10-10 2009-08-27 Craig       Khai       
#> 5      5 2000-12-05 2005-02-28 Parker      Gracie
```

این مجموعه داده شامل داده‌های مربوط به پنج خانواده، به همراه نام و تاریخ تولد حداکثر دو فرزند است. چالش جدید در این مجموعه داده نام ستون‌ها است که شامل نام دو متغیر (`dob` و `name`) و مقادیر متغیر دیگر (`child`، با مقادیر 1 یا 2) است. برای حل این مسأله دوباره باید یک بردار به `names_to` بدهیم اما این بار از مقدار خاص `"value."` استفاده می‌کنیم؛ این نام یک متغیر نیست، بلکه یک مقدار منحصر به فرد است که به `()pivot_longer` می‌گوید کار متفاوتی انجام دهد. این مقدار خاص، آرگومان معمول `values_to` را نادیده می‌گیرد تا اولین جزء از نام ستون چرخیده‌شده را به عنوان نام متغیر در خروجی استفاده کند.
```{r}
household |> 
  pivot_longer(
    cols = !family, 
    names_to = c(".value", "child"), 
    names_sep = "_", 
    values_drop_na = TRUE
  )
#> # A tibble: 9 × 4
#>   family child  dob        name 
#>    <int> <chr>  <date>     <chr>
#> 1      1 child1 1998-11-26 Susan
#> 2      1 child2 2000-01-29 Jose 
#> 3      2 child1 1996-06-22 Mark 
#> 4      3 child1 2002-07-11 Sam  
#> 5      3 child2 2004-04-05 Seth 
#> 6      4 child1 2004-10-10 Craig
#> # ℹ 3 more rows
```
دوباره از `values_drop_na = TRUE` استفاده می‌کنیم زیرا شکل داده‌های ورودی باعث ایجاد متغیرهای گمشده می‌شود (مثلاً برای خانواده‌هایی که فقط یک فرزند دارند).

شکل 7.5 ایده اولیه را با یک مثال ساده‌تر نشان می‌دهد. وقتی که از `"value."` در `names_to` استفاده می‌کنید، نام ستون‌ها در ورودی، هم در مقادیر و هم در نام متغیرها در خروجی نقش دارند.

![Alt text](Images/names-and-values.png.png)
*شکل 6.5: چرخش با استفاده از `names_to = c(".value", "num")` نام ستون‌ها را به دو جزء تقسیم می‌کند: بخش اول نام ستون خروجی (`x` یا `y`) را تعیین می‌کند و بخش دوم مقدار ستون `num` را تعیین می‌کند.*


### 4.5 داده پهن‌تر کردن

تاکنون برای حل دسته‌ی رایجی از مسائل که در آنها مقادیر در نام ستون‌ها قرار می‌گرفتند از `()pivot_longer` استفاده کرده‌ایم. در مرحله بعد، از `()pivot_wider` برای چرخش داده‌ها استفاده خواهیم کرد به طوری که مجموعه داده‌ها را با افزایش ستون‌ها و کاهش سطرها پهن‌تر می‌کند و این در زمانی که یک مشاهده در چندین سطر پخش شده است کمک‌کننده است. به نظر می‌رسد این مشکل کمتر در دنیای واقعی رخ می‌دهد، اما به نظر می‌رسد هنگام برخورد با داده‌های دولتی زیاد پیش می‌آید.

با بررسی داده‌های `cms_patient_experience` شروع می‌کنیم، مجموعه داده‌ای از مراکز پزشکی که داده‌هایی درباره تجربیات بیمار جمع‌آوری کرده است. 

```{r}
cms_patient_experience
#> # A tibble: 500 × 5
#>   org_pac_id org_nm                     measure_cd   measure_title   prf_rate
#>   <chr>      <chr>                      <chr>        <chr>              <dbl>
#> 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS…       63
#> 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS…       87
#> 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS…       86
#> 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS…       57
#> 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS…       85
#> 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS…       24
#> # ℹ 494 more rows
```
واحد اصلی مورد مطالعه یک سازمان است، اما هر سازمان در شش سطر پخش شده است و یک سطر برای هر اندازه‌گیری انجام‌شده در سازمان مورد بررسی در نظر گرفته شده است. می‌توانیم مجموعه کامل مقادیر برای `measure_cd` و `measure_title` را با استفاده از `()distinct` مشاهده کنیم:
```{r}
cms_patient_experience |> 
  distinct(measure_cd, measure_title)
#> # A tibble: 6 × 2
#>   measure_cd   measure_title                                                 
#>   <chr>        <chr>                                                         
#> 1 CAHPS_GRP_1  CAHPS for MIPS SSM: Getting Timely Care, Appointments, and In…
#> 2 CAHPS_GRP_2  CAHPS for MIPS SSM: How Well Providers Communicate            
#> 3 CAHPS_GRP_3  CAHPS for MIPS SSM: Patient's Rating of Provider              
#> 4 CAHPS_GRP_5  CAHPS for MIPS SSM: Health Promotion and Education            
#> 5 CAHPS_GRP_8  CAHPS for MIPS SSM: Courteous and Helpful Office Staff        
#> 6 CAHPS_GRP_12 CAHPS for MIPS SSM: Stewardship of Patient Resources
```

هیچ‌کدام از این ستون‌ها برای نام‌گذاری متغیرها مناسب نیستند: ‍‍`measure_cd` به معنای متغیر اشاره نمی‌کند و `measure_title` یک جمله طولانی است که شامل فاصله است. از `measure_cd` به عنوان منبع نام ستون‌های جدید استفاده خواهیم کرد، اما در تحلیل واقعی ممکن است که بخواهید از نام‌های متغیر خودتان استفاده کنید که هم کوتاه و هم معنادار باشند.

تابع `()pivot_wider` آرگومان‌های مخالف `()pivot_longer` دارد. به جای انتخاب نام ستون‌های جدید، باید ستون‌های موجودی که تعریف‌کننده مقادیر (`values_from`) و نام ستون (`names_from`) هستند را به تابع بدهیم.

```{r}
cms_patient_experience |> 
  pivot_wider(
    names_from = measure_cd,
    values_from = prf_rate
  )
#> # A tibble: 500 × 9
#>   org_pac_id org_nm                   measure_title   CAHPS_GRP_1 CAHPS_GRP_2
#>   <chr>      <chr>                    <chr>                 <dbl>       <dbl>
#> 1 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          63          NA
#> 2 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          87
#> 3 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA
#> 4 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA
#> 5 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA
#> 6 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA
#> # ℹ 494 more rows
#> # ℹ 4 more variables: CAHPS_GRP_3 <dbl>, CAHPS_GRP_5 <dbl>, …
```

خروجی کاملاً درست به نظر نمی‌رسد؛ به نظر می‌رسد که هنوز برای هر سازمان چندین سطر داریم. دلیلش آن است که همچنان نیاز داریم تا مقداری به `()pivot_wider` بدهیم که کدام ستون یا ستون‌ها دارای مقادیری هستند که به طور منحصر به فردی هر سطر را مشخص می‌کنند. در این مورد این ستون‌ها متغیرهایی هستند که نامشان با `"org"` شروع می‌شود.
```{r}
cms_patient_experience |> 
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  )
#> # A tibble: 95 × 8
#>   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5
#>   <chr>      <chr>                  <dbl>       <dbl>       <dbl>       <dbl>
#> 1 0446157747 USC CARE MEDICA…          63          87          86          57
#> 2 0446162697 ASSOCIATION OF …          59          85          83          63
#> 3 0547164295 BEAVER MEDICAL …          49          NA          75          44
#> 4 0749333730 CAPE PHYSICIANS…          67          84          85          65
#> 5 0840104360 ALLIANCE PHYSIC…          66          87          87          64
#> 6 0840109864 REX HOSPITAL INC          73          87          84          67
#> # ℹ 89 more rows
#> # ℹ 2 more variables: CAHPS_GRP_8 <dbl>, CAHPS_GRP_12 <dbl>
```
دستور بالا خروجی‌ای که به دنبالش هستیم را به ما می‌دهد.

### 1.4.5 تابع `()pivot_wider` چگونه کار می‌کند؟

برای درک کارکرد تابع `()pivot_wider` اجازه بدهید با یک محموعه داده بسیار ساده شروع کنیم. این بار دو بیمار با شناسه‌های (`id`) A و B داریم، سه اندازه‌گیری فشار خون برای بیمار A و دو اندازه‌گیری برای بیمار B داریم:
```{r}
df <- tribble(
  ~id, ~measurement, ~value,
  "A",        "bp1",    100,
  "B",        "bp1",    140,
  "B",        "bp2",    115, 
  "A",        "bp2",    120,
  "A",        "bp3",    105
)
```

مقادیر را از ستون `value` و نام‌ها را از ستون `measurement` می‌گیریم:
```{r}
df |> 
  pivot_wider(
    names_from = measurement,
    values_from = value
  )
#> # A tibble: 2 × 4
#>   id      bp1   bp2   bp3
#>   <chr> <dbl> <dbl> <dbl>
#> 1 A       100   120   105
#> 2 B       140   115    NA
```

برای شروع فرآیند، `()pivot_wider` ابتدا باید بفهمد که چه اطلاعاتی در سطرها و ستون‌ها قرار خواهد گرفت. نام ستون‌های جدید مقادیر منحصر به فرد `measurement` خواهند بود.
```{r}
df |> 
  distinct(measurement) |> 
  pull()
#> [1] "bp1" "bp2" "bp3"
```

به طور پیش‌فرض، سطرهای خروجی توسط تمام متغیرهایی که در نام‌ها یا مقادیر جدید قرار نمی‌گیرند، تعیین می‌شوند. این متغیرها `id_cols` نامیده می‌شوند. در اینجا تنها یک ستون وجود دارد، اما به طور کلی می‌تواند هر تعدادی باشد.
```{r}
df |> 
  select(-measurement, -value) |> 
  distinct()
#> # A tibble: 2 × 1
#>   id   
#>   <chr>
#> 1 A    
#> 2 B
```

سپس `()pivot_wider` این نتایج را با هم ترکیب می‌کند تا یک چارچوب داده خالی تولید کند:
```{r}
df |> 
  select(-measurement, -value) |> 
  distinct() |> 
  mutate(x = NA, y = NA, z = NA)
#> # A tibble: 2 × 4
#>   id    x     y     z    
#>   <chr> <lgl> <lgl> <lgl>
#> 1 A     NA    NA    NA   
#> 2 B     NA    NA    NA
```

سپس تمام مقادیر گمشده را با استفاده از داده‌های ورودی پر می‌کند. در این حالت، هر سلول در خروجی مقدار متناظری در ورودی ندارد زیرا اندازه‌گیری فشار خون سومی برای بیمار B وجود ندارد، بنابراین آن سلول همچنان مقدار گمشده باقی می‌ماند. در فصل 18 به این ایده که `()pivot_wider` می‌تواند مقادیر گمشده ایجاد کند، باز خواهیم گشت.

همچنین ممکن است از خود بپرسید که اگر چندین سطر در ورودی وجود داشته باشد که متناظر با یک سلول در خروجی باشند، چه اتفاقی می‌افتد. مثال زیر دو سطر دارد که مربوط به شناسه (`id`) "A" و اندازه‌گیری (`measurement`) "bp1" هستند:

```{r}
df <- tribble(
  ~id, ~measurement, ~value,
  "A",        "bp1",    100,
  "A",        "bp1",    102,
  "A",        "bp2",    120,
  "B",        "bp1",    140, 
  "B",        "bp2",    115
)
```

اگر سعی به چرخش این مجموعه داده کنیم، خروجی‌ای دریافت می‌کنیم که شامل ستون‌های لیست است، که در فصل ۲۳ درباره آنها بیشتر خواهید آموخت:
```{r}
df |>
  pivot_wider(
    names_from = measurement,
    values_from = value
  )
#> Warning: Values from `value` are not uniquely identified; output will contain
#> list-cols.
#> • Use `values_fn = list` to suppress this warning.
#> • Use `values_fn = {summary_fun}` to summarise duplicates.
#> • Use the following dplyr code to identify duplicates.
#>   {data} |>
#>   dplyr::summarise(n = dplyr::n(), .by = c(id, measurement)) |>
#>   dplyr::filter(n > 1L)
#> # A tibble: 2 × 3
#>   id    bp1       bp2      
#>   <chr> <list>    <list>   
#> 1 A     <dbl [2]> <dbl [1]>
#> 2 B     <dbl [1]> <dbl [1]>
```

از آنجایی که هنوز نمی‌دانید چگونه با این نوع داده‌ها کار کنید، بهتر است از راهنمایی موجود در خروجی استفاده کنید تا بفهمید مشکل چیست:
```{r}
df |> 
  group_by(id, measurement) |> 
  summarize(n = n(), .groups = "drop") |> 
  filter(n > 1)
#> # A tibble: 1 × 3
#>   id    measurement     n
#>   <chr> <chr>       <int>
#> 1 A     bp1             2
```

این به شما بستگی دارد که بفهمید چه مشکلی در داده‌های شما وجود دارد و یا مشکلات اساسی را برطرف کنید و یا با استفاده از مهارت‌های گروه‌بندی و خلاصه‌سازی اطمینان حاصل کنید که هر ترکیبی از مقادیر سطر و ستون فقط یک سطر دارد.


## 5.5 خلاصه

در این فصل، مفهوم داده‌های مرتب را یاد گرفتید: داده‌هایی که هر متغیر در یک ستون و هر مشاهده در یک سطر قرار دارند. داده‌های مرتب کار با tidyverse را آسان‌تر می‌کنند، زیرا ساختار ثابتی دارند که توسط اکثر توابع قابل درک است، چالش اصلی، تبدیل داده‌ها از هر ساختاری که دریافت می‌کنید به یک قالب مرتب است. برای این منظور، توابع `()pivot_longer` و `()pivot_wider` را یاد گرفته‌اید که به شما امکان می‌دهند بسیاری از مجموعه داده‌های نامرتب را مرتب کنید. مثال‌هایی که در اینجا ارائه دادیم، گزیده‌ای از مثال‌های `vignette("pivot", package = "tidyr")` هستند، بنابراین اگر با مشکلی مواجه شدید که این فصل به شما کمکی نمی‌کند، این راهنما جای خوبی برای امتحان کردن در مرحله بعد است.

چالش دیگر این است که برای یک مجموعه داده مشخص، برچسب‌گذاری نسخه طولانی‌تر یا پهن‌تر به عنوان نسخه «مرتب» می‌تواند غیرممکن باشد. این تا حدودی بازتابی از تعریف ما از داده‌های مرتب است، که در آن گفتیم داده‌های مرتب در هر ستون یک متغیر دارند، اما در واقع تعریف نکردیم که یک متغیر چیست (و انجام این کار به طرز شگفت‌آوری دشوار است). کاملاً خوب است که عمل‌گرا باشیم و بگوییم متغیر هر چیزی است که تجزیه و تحلیل شما را آسان‌تر می‌کند. بنابراین اگر در فهمیدن نحوه انجام برخی محاسبات گیر کرده‌اید، تغییر سازماندهی داده‌های خود را در نظر بگیرید؛ از مرتب کردن، تبدیل و مرتب کردن مجدد در صورت نیاز نترسید!

اگر از این فصل لذت بردید و می‌خواهید درباره نظریه زیربنایی آن بیشتر بدانید، می‌توانید در مقاله
[ داده‌های مرتب](https://www.jstatsoft.org/article/view/v059i10)
 که در مجله نرم‌افزار آماری منتشر شده است، درباره تاریخچه و مبانی نظری آن بیشتر بیاموزید.

اکنون شما کدهای بسیار زیادی از R می نویسید، از این رو زمان آن است تا در مورد سازمان‌دهی کدهایتان به فایل‌ها و دایرکتوری‌ها بیشتر بدانید. در فصل بعد، درباره مزیت‌های اسکریپت‌ها و پروژه‌ها و نیز برخی از ابزارهای بسیار فراوانی که کارها را آسان‌تر می‌کنند بیشتر خواهید آموخت.
