# ۱۶ فاکتورها

## ۱.۱۶ مقدمه

فاکتورها در R برای کار با متغیرهای طبقه‌ای استفاده می‌شوند، یعنی متغیرهایی که مجموعه‌ای ثابت و شناخته‌شده از مقادیر ممکن دارند. همچنین برای نمایش داده‌های غیرعددی به‌ترتیب خاصی مفید هستند. فاکتورها در تحلیل داده مدل‌سازی آماری، و تجسم بسیار مهم هستند.

از لحاظ تاریخی، فاکتورها کار با داده‌های متنی را بسیار آسان‌تر می‌کردند. در نتیجه، بسیاری از توابع R پایه به‌طور خودکار رشته‌ها را به فاکتور تبدیل می‌کنند. این به این معنی است که فاکتورها اغلب در جاهایی ظاهر می‌شوند که واقعاً مفید نیستند. خوشبختانه، شما مجبور نیستید نگران این موضوع در tidyverse باشید و می‌توانید تمرکز خود را روی موقعیت‌هایی بگذارید که فاکتورها واقعاً اطلاعات مفید دارند.

### ۱.۱.۱۶ پیش‌نیازها

فاکتورها توسط بسته forcats مدیریت می‌شوند، که بخشی از tidyverse اصلی است. ما با استفاده از ggplot2 برای تجسم و dplyr برای دستکاری داده‌ها شروع خواهیم کرد.

```{r}
#| label: setup
#| message: false
library(tidyverse)
```

## ۲.۱۶ مبانی فاکتور

تصور کنید متغیری دارید که ماه‌ها را ثبت می‌کند:

```{r}
x1 <- c("Dec", "Apr", "Jan", "Mar")
```

استفاده از یک رشته برای ثبت این متغیر دو مشکل دارد:

1. فقط دوازده مقدار ممکن وجود دارد و هیچ چیزی شما را از غلط املایی متوقف نمی‌کند:

```{r}
x2 <- c("Dec", "Apr", "Jam", "Mar")
```

2. مرتب‌سازی به شکل مفیدی انجام نمی‌شود:

```{r}
sort(x1)
#> [1] "Apr" "Dec" "Jan" "Mar"
```

می‌توانید هر دو این مشکل را با یک فاکتور برطرف کنید. برای ایجاد یک فاکتور باید با ایجاد لیستی از سطوح (levels) معتبر شروع کنید:

```{r}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
```

حالا می‌توانید یک فاکتور ایجاد کنید:

```{r}
y1 <- factor(x1, levels = month_levels)
y1
#> [1] Dec Apr Jan Mar
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec

sort(y1)
#> [1] Jan Mar Apr Dec
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
```

و هر مقداری که در مجموعه سطوح نباشد به‌طور خاموش به NA تبدیل می‌شود:

```{r}
y2 <- factor(x2, levels = month_levels)
y2
#> [1] Dec  Apr  <NA> Mar 
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
```

اگر سطوح را حذف کنید، از داده‌های موجود به‌طور الفبایی اخذ می‌شوند:

```{r}
factor(x1)
#> [1] Dec Apr Jan Mar
#> Levels: Apr Dec Jan Mar
```

گاهی اوقات ترجیح می‌دهید که ترتیب سطوح با ترتیب اولین ظهور در داده‌ها همخوانی داشته باشد. می‌توانید این کار را هنگام ایجاد فاکتور با تنظیم سطوح به `unique(x)` انجام دهید، یا پس از واقعیت با `fct_inorder()`:

```{r}
f1 <- factor(x1, levels = unique(x1))
f1
#> [1] Dec Apr Jan Mar
#> Levels: Dec Apr Jan Mar

f2 <- x1 |> factor() |> fct_inorder()
f2
#> [1] Dec Apr Jan Mar
#> Levels: Dec Apr Jan Mar
```

اگر نیاز دارید که مستقیماً به مجموعه سطوح معتبر دسترسی داشته باشید، می‌توانید این کار را با `levels()` انجام دهید:

```{r}
levels(f2)
#> [1] "Dec" "Apr" "Jan" "Mar"
```

## ۳.۱۶ نظرسنجی اجتماعی عمومی

برای بقیه این فصل، از `forcats::gss_cat` تمرکز خواهیم کرد. این نمونه‌ای از داده از نظرسنجی اجتماعی عمومی است، یک نظرسنجی بلندمدت در ایالات متحده که توسط سازمان مستقل تحقیقاتی NORC در دانشگاه شیکاگو انجام می‌شود. نظرسنجی هزاران سوال دارد، بنابراین در `gss_cat`، ما تعداد کمی را انتخاب کرده‌ایم که برخی از چالش‌های رایج را نشان می‌دهند که هنگام کار با فاکتورها با آن‌ها مواجه خواهید شد.

```{r}
gss_cat
#> # A tibble: 21,483 × 9
#>    year marital         age race  rincome        partyid      relig denom tvhours
#>   <int> <fct>         <int> <fct> <fct>          <fct>        <fct> <fct>   <int>
#> 1  2000 Never married    26 White $8000 to 9999  Ind,near re… Prot… Sout…      12
#> 2  2000 Divorced         48 White $8000 to 9999  Not str rep… Prot… Bapt…      NA
#> 3  2000 Widowed          67 White Not applicable Independent  Prot… No d…       2
#> 4  2000 Never married    39 White Not applicable Ind,near re… Orth… Not …       4
#> 5  2000 Divorced         25 White Not applicable Not str dem… None  Not …       1
#> 6  2000 Married          25 White $20000 - 24999 Strong demo… Prot… Sout…      NA
#> # ℹ 21,477 more rows
```

از آنجایی که این داده‌ها توسط بسته ارائه شده‌اند، می‌توانید اطلاعات بیشتری در مورد متغیرها را با `?gss_cat` دریافت کنید.

وقتی فاکتورها در یک tibble ذخیره می‌شوند، نمی‌توانید سطوح آن‌ها را به راحتی ببینید. یک راه برای دیدن آن‌ها `count()` است:

```{r}
gss_cat |>
  count(race)
#> # A tibble: 3 × 2
#>   race      n
#>   <fct> <int>
#> 1 Other  1959
#> 2 Black  3129
#> 3 White 16395
```

یا با یک نمودار میله‌ای:

```{r}
#| fig-alt: |
#>   یک نمودار میله‌ای که نژاد را در محور x نشان می‌دهد. سفید
#>   بیشترین تعداد را دارد، سیاه دومین و سایر موارد کمتر است.
ggplot(gss_cat, aes(x = race)) +
  geom_bar()
```

به‌طور پیش‌فرض، ggplot2 سطوح بدون هیچ مقداری را حذف می‌کند. می‌توانید آن‌ها را با مقیاس نمایش دهید:

```{r}
#| fig-alt: |
#>   نمودار میله‌ای مشابه قبلی اما این بار با یک محور x که
#>   همه سطوح نژاد را نشان می‌دهد.
ggplot(gss_cat, aes(x = race)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)
```

هنگام کار با فاکتورها، دو عملیات رایج تغییر ترتیب سطوح و تغییر مقادیر سطوح است. این عملیات در بخش‌های بعدی توضیح داده می‌شوند.

### ۱.۳.۱۶ تمرین‌ها

1. فاکتورهای `rincome` (درآمد گزارش‌شده) را بررسی کنید. مشکل پیش‌فرض count چیست؟ چگونه می‌توانید آن را بهبود بخشید؟

2. رایج‌ترین `relig` در این نظرسنجی چیست؟ رایج‌ترین `partyid` چیست؟

3. کدام `relig` به کدام `denom` (فرقه) تعلق دارد؟ چگونه می‌توانید این را با یک جدول کشف کنید؟ چگونه می‌توانید این را با یک تجسم کشف کنید؟

## ۴.۱۶ تغییر ترتیب سطوح فاکتور

اغلب مفید است تا ترتیب سطوح فاکتور را در یک تجسم تغییر دهید. به عنوان مثال، تصور کنید می‌خواهید متوسط تعداد ساعات تماشای تلویزیون را در هر روز در مذاهب مختلف کشف کنید:

```{r}
relig_summary <- gss_cat |>
  group_by(relig) |>
  summarize(
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(relig_summary, aes(x = tvhours, y = relig)) + 
  geom_point()
```

خواندن این نمودار دشوار است زیرا هیچ الگوی کلی وجود ندارد. می‌توانیم آن را خواناتر کنیم با ترتیب مجدد سطوح `relig` با استفاده از `fct_reorder()`. `fct_reorder()` سه آرگومان می‌گیرد:

- `.f`، فاکتوری که سطوح آن را می‌خواهید تغییر دهید.
- `.x`، یک بردار عددی که می‌خواهید از آن برای ترتیب مجدد سطوح استفاده کنید.
- به‌طور اختیاری، `.fun`، تابعی که وقتی چندین مقدار از `.x` برای هر مقدار `.f` وجود دارد، استفاده می‌شود. پیش‌فرض median است.

```{r}
#| fig-alt: |
#>   نقطه‌ای ساده که میانگین ساعات تماشای تلویزیون در روز را در
#>   مذاهب مختلف نشان می‌دهد. مذاهب به ترتیب افزایشی میانگین
#>   ساعات تماشای تلویزیون مرتب شده‌اند.
ggplot(relig_summary, aes(x = tvhours, y = fct_reorder(relig, tvhours))) +
  geom_point()
```

ترتیب مجدد مذهب منطقی است زیرا به یک نمودار خوانا تبدیل می‌شود که فوراً این نکته را واضح می‌کند که افرادی در گروه "Don't know" بیشترین میانگین ساعات تماشای تلویزیون را دارند، در حالی که افراد Hinduism کمترین را دارند.

همان‌طور که شروع به ایجاد تبدیلات پیچیده‌تر می‌کنید، توصیه می‌کنیم آن‌ها را از `aes()` خارج کنید و به یک مرحله جداگانه `mutate()` منتقل کنید. به عنوان مثال، می‌توانید کد بالا را به این شکل بازنویسی کنید:

```{r}
#| eval: false
relig_summary |>
  mutate(
    relig = fct_reorder(relig, tvhours)
  ) |>
  ggplot(aes(x = tvhours, y = relig)) +
  geom_point()
```

اگر بخواهید میانگین سن را بر اساس سطح درآمد گزارش‌شده ترسیم کنید چه می‌شود؟

```{r}
rincome_summary <- gss_cat |>
  group_by(rincome) |>
  summarize(
    age = mean(age, na.rm = TRUE),
    n = n()
  )

ggplot(rincome_summary, aes(x = age, y = fct_reorder(rincome, age))) + 
  geom_point()
```

در اینجا، ترتیب مجدد دلخواه سطوح یک ایده خوب نیست! این به این دلیل است که `rincome` از قبل یک ترتیب اصولی دارد که نباید با آن بازی کنیم. برای این نوع فاکتورها از `fct_reorder()` استفاده نکنید زیرا سطوح آن‌ها دارای ترتیب ذاتی هستند.

با این حال، منطقی است که سطوحی مانند "Not applicable" را به جلو بیاوریم با بقیه سطوح خاص. می‌توانید از `fct_relevel()` استفاده کنید. این یک فاکتور، `.f`، و سپس هر تعداد سطح که می‌خواهید به جلوی خط منتقل کنید را می‌گیرد.

```{r}
#| fig-alt: |
#>   همان نمودار نقطه‌ای اما حالا "Not applicable" اول است.
ggplot(rincome_summary, aes(x = age, y = fct_relevel(rincome, "Not applicable"))) +
  geom_point()
```

یک نوع دیگر از ترتیب مجدد مفید است وقتی رنگ خطوط در یک نمودار را تنظیم می‌کنید. `fct_reorder2(.f, .x, .y)` سطوح `.f` را با مقادیر `.y` مرتبط با بزرگترین مقادیر `.x` ترتیب مجدد می‌کند. این باعث می‌شود نمودار با افسانه همخوانی داشته باشد زیرا رنگ‌های خط با ترتیب در افسانه منطبق می‌شود:

```{r}
#| fig-alt: |
#>   نمودار خطی با سن در محور x و نسبت در محور y. در
#>   نمودار سه خط وجود دارد: متاهل، بیوه، طلاق. این خطوط منطقی
#>   طبق ترتیب افسانه مرتب شده‌اند.
by_age <- gss_cat |>
  filter(!is.na(age)) |> 
  count(age, marital) |>
  group_by(age) |>
  mutate(
    prop = n / sum(n)
  )

ggplot(by_age, aes(x = age, y = prop, color = fct_reorder2(marital, age, prop))) +
  geom_line() +
  labs(color = "marital")
```

در نهایت، برای نمودارهای میله‌ای، می‌توانید از `fct_infreq()` برای ترتیب سطوح در ترتیب فزاینده فراوانی استفاده کنید: این ساده‌ترین نوع ترتیب مجدد است زیرا به هیچ متغیر اضافی نیازی ندارد. ممکن است بخواهید آن را با `fct_rev()` ترکیب کنید.

```{r}
#| fig-alt: |
#>   نمودار میله‌ای وضعیت تاهل با میله‌ها به ترتیب نزولی
#>   فراوانی: متاهل، هرگز متاهل نشده، طلاق، جدا شده، بیوه.
gss_cat |>
  mutate(marital = marital |> fct_infreq() |> fct_rev()) |>
  ggplot(aes(x = marital)) +
  geom_bar()
```

### ۱.۴.۱۶ تمرین‌ها

1. چندین نکته جالب در مورد متوسط ساعات تماشای تلویزیون در طول روز در `tvhours` وجود دارد. آیا می‌توانید آن‌ها را بهبود بخشید؟

2. برای هر فاکتور در `gss_cat`، سطوح را شناسایی کنید و آیا ترتیب سطوح دلخواه یا اصولی است؟

3. چرا انتقال "Not applicable" به جلوی سطوح آن نمودار را منتقل کرد؟

## ۵.۱۶ تغییر سطوح فاکتور

قدرتمندتر از تغییر ترتیب سطوح، تغییر مقادیر آن‌هاست. این به شما اجازه می‌دهد سطوح را برای انتشار روشن کنید و سطوح را برای نمایش سطح بالا جمع کنید. ابزار عمومی و قدرتمندترین `fct_recode()` است. این به شما اجازه می‌دهد هر سطح را به‌صورت دستی تغییر دهید یا دوباره نام‌گذاری کنید. به عنوان مثال، `gss_cat$partyid` را در نظر بگیرید:

```{r}
gss_cat |> count(partyid)
#> # A tibble: 10 × 2
#>   partyid                n
#>   <fct>              <int>
#> 1 No answer            154
#> 2 Don't know             1
#> 3 Other party          393
#> 4 Strong republican   2314
#> 5 Not str republican  3032
#> 6 Ind,near rep        1791
#> # ℹ 4 more rows
```

سطوح مختصر و ناهماهنگ هستند. بیایید آن‌ها را طولانی‌تر و از ساختار موازی استفاده کنیم. مانند بیشتر توابع rename و recode در tidyverse، نام جدید در سمت چپ و مقدار قدیمی در سمت راست قرار می‌گیرد:

```{r}
gss_cat |>
  mutate(
    partyid = fct_recode(partyid,
      "Republican, strong"    = "Strong republican",
      "Republican, weak"      = "Not str republican",
      "Independent, near rep" = "Ind,near rep",
      "Independent, near dem" = "Ind,near dem",
      "Democrat, weak"        = "Not str democrat",
      "Democrat, strong"      = "Strong democrat"
    )
  ) |>
  count(partyid)
#> # A tibble: 10 × 2
#>   partyid                   n
#>   <fct>                 <int>
#> 1 No answer               154
#> 2 Don't know                1
#> 3 Other party             393
#> 4 Republican, strong     2314
#> 5 Republican, weak       3032
#> 6 Independent, near rep  1791
#> # ℹ 4 more rows
```

`fct_recode()` سطوحی را که به‌طور صریح ذکر نشده‌اند، دست نخورده باقی می‌گذارد و در صورتی که به‌طور تصادفی به یک سطح موجود اشاره کنید، به شما هشدار خواهد داد.

برای ترکیب گروه‌ها، می‌توانید چندین سطح قدیمی را به یک سطح جدید اختصاص دهید:

```{r}
gss_cat |>
  mutate(
    partyid = fct_recode(partyid,
      "Republican, strong"    = "Strong republican",
      "Republican, weak"      = "Not str republican",
      "Independent, near rep" = "Ind,near rep",
      "Independent, near dem" = "Ind,near dem",
      "Democrat, weak"        = "Not str democrat",
      "Democrat, strong"      = "Strong democrat",
      "Other"                 = "No answer",
      "Other"                 = "Don't know",
      "Other"                 = "Other party"
    )
  ) |>
  count(partyid)
#> # A tibble: 7 × 2
#>   partyid                   n
#>   <fct>                 <int>
#> 1 Other                   548
#> 2 Republican, strong     2314
#> 3 Republican, weak       3032
#> 4 Independent, near rep  1791
#> 5 Independent, near dem  2499
#> 6 Democrat, weak         3690
#> # ℹ 1 more row
```

از این تکنیک با احتیاط استفاده کنید: اگر دسته‌ها را به‌طور بیش از حد گروه‌بندی کنید، ممکن است درنهایت داده‌های گمراه‌کننده‌ای داشته باشید.

اگر می‌خواهید تعداد زیادی از سطوح را جمع کنید، `fct_collapse()` یک تغییر مفید از `fct_recode()` است. برای هر گروه جدید متغیر، می‌توانید یک بردار از سطوح قدیمی ارائه دهید:

```{r}
gss_cat |>
  mutate(
    partyid = fct_collapse(partyid,
      "other" = c("No answer", "Don't know", "Other party"),
      "rep" = c("Strong republican", "Not str republican"),
      "ind" = c("Ind,near rep", "Independent", "Ind,near dem"),
      "dem" = c("Not str democrat", "Strong democrat")
    )
  ) |>
  count(partyid)
#> # A tibble: 4 × 2
#>   partyid     n
#>   <fct>   <int>
#> 1 other     548
#> 2 rep      5346
#> 3 ind      8409
#> 4 dem      7180
```

گاهی اوقات فقط می‌خواهید تمام گروه‌های کوچک را به هم بپیوندید تا نمودار یا جدول ساده‌تر شود. این کار `fct_lump_*()` است. خانواده توابع:

- `fct_lump_lowfreq()` به‌طور تدریجی کوچکترین گروه‌ها را به هم می‌پیوندد و اطمینان حاصل می‌کند که دسته "Other" هنوز کوچکترین گروه است.
- `fct_lump_min()` تمام گروه‌هایی را که کمتر از حداقل تعداد ظهور دارند جمع می‌کند.
- `fct_lump_n()` n گروه را به هم می‌پیوندد که به‌طور کلی بزرگترین اند.

در مثال زیر، از `fct_lump_lowfreq()` برای جمع کردن مذاهب کوچک‌تر استفاده می‌کنیم:

```{r}
gss_cat |>
  mutate(relig = fct_lump_lowfreq(relig)) |>
  count(relig)
#> # A tibble: 2 × 2
#>   relig          n
#>   <fct>      <int>
#> 1 Protestant 10846
#> 2 Other      10637
```

در این مورد، این اصلاً مفید نیست! شما باید از `fct_lump_n()` برای تعیین اینکه می‌خواهید چند گروه (به غیر از Other) را حفظ کنید استفاده کنید:

```{r}
gss_cat |>
  mutate(relig = fct_lump_n(relig, n = 10)) |>
  count(relig, sort = TRUE)
#> # A tibble: 11 × 2
#>   relig                       n
#>   <fct>                   <int>
#> 1 Protestant              10846
#> 2 Catholic                 5124
#> 3 None                     3523
#> 4 Christian                 689
#> 5 Other                     458
#> 6 Jewish                    388
#> # ℹ 5 more rows
```

### ۱.۵.۱۶ تمرین‌ها

1. چگونه توزیع `rincome` در طول `partyid` تغییر کرده است؟ برای سادگی، کنترل `rincome` را به سطوح کم و زیاد کاهش دهید و `partyid` را به گروه‌های عمده‌ای که فکر می‌کنید معقول هستند کاهش دهید.

2. چگونه می‌توانید سطوح `fct_collapse()` را برای `fct_lump()` سفارش کنید تا مطمئن شوید که "Other" در آخر قرار می‌گیرد؟

## ۶.۱۶ فاکتورهای مرتب‌شده

قبل از اینکه به پایان این فصل برسیم، نوع ویژه‌ای از فاکتور وجود دارد که باید در مورد آن صحبت کنیم: فاکتورهای مرتب‌شده. فاکتورهای مرتب‌شده با `ordered()` ایجاد می‌شوند، یک تنوع از `factor()` که به‌طور ضمنی یک ترتیب اصولی را برای سطوح اضافه می‌کند:

```{r}
ordered(c("a", "b", "c"))
#> [1] a b c
#> Levels: a < b < c
```

در عمل، فاکتورهای `ordered()` مانند فاکتورهای معمولی رفتار می‌کنند. تنها تفاوت این است که در برخی تحلیل‌های آماری و در صورت نگاشت به اندازه (size) یا شکل (shape)، ترتیب سطوح اطلاع‌رسانی می‌شود.

با توجه به تغییر رفتار متداول، بیشتر مردم از فاکتورهای مرتب‌شده استفاده نمی‌کنند زیرا تفاوت بین `ordered()` و فاکتور معمولی در کد شما بسیار مشهود نیست. بنابراین توصیه می‌کنیم که به‌طور کلی از آن‌ها اجتناب کنید.

## ۷.۱۶ خلاصه

این فصل به شما معرفی کرد اینکه چگونه با فاکتورها کار کنید، ابزار R برای متغیرهای طبقه‌ای، متغیرهایی که مقادیر ممکن شناخته‌شده و محدودی دارند. فاکتورها کمی سخت برای شروع هستند اما وقتی با آن‌ها راحت شدید، بسیار مفید می‌شوند. در کل، مهم‌ترین توابع دستکاری فاکتور از forcats عبارتند از:

- `fct_reorder()` - برای ترتیب مجدد سطوح بر اساس متغیر دیگری
- `fct_relevel()` - برای انتقال سطوح خاص به موقعیت‌های خاص
- `fct_infreq()` - برای ترتیب سطوح بر اساس فراوانی
- `fct_rev()` - برای معکوس کردن ترتیب سطوح
- `fct_recode()` - برای تغییر نام سطوح به‌صورت دستی
- `fct_collapse()` - برای جمع کردن چندین سطح قدیمی به سطوح جدید
- `fct_lump_*()` - برای جمع کردن سطوح کوچک به یک دسته "Other"

در فصل بعدی درباره تاریخ‌ها و زمان‌ها صحبت خواهیم کرد، نوع دیگری از داده که در ابتدا پیچیده به نظر می‌رسد اما با پیشرفت شما ساده‌تر می‌شود!
