# درس ۱: توابع (Functions)

## ۱.۲۵ مقدمه

یکی از بهترین راه‌ها برای بهبود دسترسی شما به عنوان یک دانشمند داده، نوشتن توابع است. توابع به شما امکان می‌دهند وظایف رایج را به روشی قدرتمندتر و کلی‌تر از کپی و چسباندن خودکار کنید. نوشتن یک تابع چهار مزیت بزرگ نسبت به استفاده از کپی و پیست دارد:

- می‌توانید به تابع یک نام توصیفی بدهید که کد شما را قابل فهم‌تر می‌کند.
- همانطور که نیازمندی‌ها تغییر می‌کنند، فقط نیاز دارید کد را در یک مکان به‌روزرسانی کنید، به جای مکان‌های متعدد.
- شانس ایجاد اشتباهات تصادفی را که هنگام کپی و پیست رخ می‌دهد حذف می‌کنید (یعنی به‌روزرسانی نام یک متغیر در یک مکان، اما نه در مکان دیگر).
- استفاده مجدد از کار را از پروژه‌ای به پروژه دیگر آسان‌تر می‌کند و در طول زمان بهره‌وری شما را افزایش می‌دهد.

یک قاعده سرانگشتی خوب این است که نوشتن تابع را هر زمان که بیش از دو بار یک بلوک کد را کپی و پیست کرده‌اید (یعنی اکنون سه نسخه از همان کد دارید) در نظر بگیرید. در این فصل، شما درباره سه نوع مفید از توابع یاد خواهید گرفت:

- **توابع برداری (Vector functions)**: توابعی که یک یا چند بردار را می‌گیرند و یک بردار را برمی‌گردانند، و به طور معمول در `mutate()` و `filter()` استفاده می‌شوند.
- **توابع دیتافریم (Data frame functions)**: توابعی که یک دیتافریم را می‌گیرند و یک دیتافریم را برمی‌گردانند، و به طور معمول در pipeline‌های دیتافریم استفاده می‌شوند.
- **توابع رسم نمودار (Plot functions)**: توابعی که یک نمودار را می‌سازند.

هر یک از این بخش‌ها شامل مثال‌های متعددی برای کمک به شما برای تعمیم الگوهایی که می‌بینید است. این مثال‌ها بدون کمک افراد در توییتر ممکن نبود، و ما شما را تشویق می‌کنیم که لینک‌های موجود در نظرات را دنبال کنید تا الهام‌بخش‌های اصلی را ببینید.

### ۱.۱.۲۵ پیش‌نیازها

ما مجموعه‌ای از توابع از اطراف tidyverse را جمع‌بندی خواهیم کرد. همچنین از nycflights13 به عنوان منبعی از داده‌های آشنا برای استفاده با توابع خود استفاده خواهیم کرد.

```{r}
library(tidyverse)
library(nycflights13)
```

## ۲.۲۵ توابع برداری

ما با توابع برداری شروع می‌کنیم: توابعی که یک یا چند بردار را می‌گیرند و یک نتیجه برداری برمی‌گردانند. به عنوان مثال، به این کد نگاه کنید. این چه کاری انجام می‌دهد؟

```{r}
df <- tibble(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5),
  d = rnorm(5),
)

df |> mutate(
  a = (a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),
  b = (b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE)),
  c = (c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),
  d = (d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),
)
```

ممکن است بتوانید حدس بزنید که این هر ستون را مجدداً مقیاس‌بندی می‌کند تا دامنه‌ای از 0 تا 1 داشته باشد. اما آیا اشتباه را متوجه شدید؟ وقتی هدلی این کد را نوشت، هنگام کپی و پیست اشتباهی مرتکب شد و فراموش کرد که یک `a` را به `b` تغییر دهد. جلوگیری از این نوع اشتباه یک دلیل بسیار خوب برای یادگیری نوشتن توابع است.

### ۱.۲.۲۵ نوشتن یک تابع

برای نوشتن یک تابع، ابتدا باید کد را تجزیه و تحلیل کنید. چند ورودی داریم؟

```{r}
(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))
```

این کد فقط یک ورودی دارد: `a`. برای تبدیل آن به یک تابع، دو مرحله انجام می‌دهیم. ابتدا، کد را ساده می‌کنیم با استفاده از متغیرهای موقت. اینجا فقط یک متغیر موقت داریم؛ اگر ورودی‌های بیشتری داشتیم، برای هر یک متغیر موقتی می‌ساختیم.

```{r}
x <- a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

در اینجا مزیت آشکاری نسبت به کد اصلی وجود ندارد، اما دو مزیت دارد:

- می‌توانیم ببینیم که متغیر واقعی را درست استفاده می‌کنیم - اگر `a` را به `x` تغییر دهیم و فراموش کنیم یکی را تغییر دهیم، خطایی دریافت خواهیم کرد.
- تعمیم این الگو به طور کلی ساده‌تر است.

حالا توابع را با استفاده از `function()` می‌سازیم:

```{r}
rescale01 <- function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}
```

در این مرحله شما ممکن است کد را آزمایش کنید و بررسی کنید که به درستی کار می‌کند:

```{r}
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
```

سپس تعریف تابع را با توجه به مشکلات اصلی تعمیم می‌دهید:

```{r}
df |> mutate(
  a = rescale01(a),
  b = rescale01(b),
  c = rescale01(c),
  d = rescale01(d),
)
```

### ۲.۲.۲۵ بهبود تابع ما

ممکن است متوجه شوید که تابع `rescale01()` کار غیرضروری انجام می‌دهد - به جای محاسبه `min()` دو بار و `max()` یک بار می‌توانیم هر دو حداقل و حداکثر را در یک مرحله با `range()` محاسبه کنیم:

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

یا ممکن است این تابع را روی برداری که شامل یک مقدار بی‌نهایت است امتحان کنید:

```{r}
x <- c(1:10, Inf)
rescale01(x)
#> [1]   0   0   0   0   0   0   0   0   0   0 NaN
```

این نتیجه به دلیل این واقعیت است که `min()` و `max()` برای `Inf`، `Inf` و `-Inf` برمی‌گردانند. می‌توانیم آن را با استفاده از `finite = TRUE` در `range()` برطرف کنیم:

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

rescale01(x)
#> [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667
#> [8] 0.7777778 0.8888889 1.0000000       Inf
```

این تغییرات نسبتاً ساده است، اما نشان می‌دهند فرآیند مهمی: شروع با یک پیاده‌سازی ساده که کار می‌کند و سپس تدریجی بهبود بخشیدن به آن.

### ۳.۲.۲۵ توابع Mutate

حالا که ایده اساسی توابع را دارید، بیایید به تعدادی مثال نگاه کنیم. با توابع "mutate" شروع می‌کنیم، یعنی توابعی که در `mutate()` و `filter()` به خوبی کار می‌کنند زیرا خروجی به همان طول ورودی برمی‌گردانند.

بیایید با یک تنوع ساده از `rescale01()` شروع کنیم. شاید می‌خواهید Z-score را محاسبه کنید، مجدداً مقیاس‌بندی یک بردار به طوری که میانگین صفر و انحراف معیار یک داشته باشد:

```{r}
z_score <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
```

یا شاید می‌خواهید مقادیری که بیرون از یک محدوده مشخص هستند را در یک مقدار ثابت قرار دهید. چند روش برای برخورد با مقادیر خارجی وجود دارد، اما یک روش محبوب این است که آنها را در یک حد خاص بگیرید:

```{r}
clamp <- function(x, min, max) {
  case_when(
    x < min ~ min,
    x > max ~ max,
    .default = x
  )
}

clamp(1:10, min = 3, max = 7)
#> [1] 3 3 3 4 5 6 7 7 7 7
```

البته توابع لازم نیست فقط کار عددی انجام دهند. ممکن است یک تابع زیادی کوچک بخواهید که هر چیزی مانند یک پیام خطا یا مقدار از دست رفته را از یک بردار حذف کند:

```{r}
first_upper <- function(x) {
  str_sub(x, 1, 1) <- str_to_upper(str_sub(x, 1, 1))
  x
}

first_upper("hello")
#> [1] "Hello"
```

یا شاید می‌خواهید سوالات معمولی را برای مجموعه داده خود بپرسید:

```{r}
# https://twitter.com/sharlagelfand/status/1571606158863044609
fix_na <- function(x) {
  if_else(x %in% c(997, 998, 999), NA, x)
}
```

### ۴.۲.۲۵ توابع خلاصه

خانواده مهم دیگری از توابع برداری، توابع خلاصه هستند، توابعی که یک مقدار تکی برای استفاده در `summarize()` برمی‌گردانند. گاهی اوقات این می‌تواند فقط یک موضوع تنظیم یک یا دو آرگومان پیش‌فرض باشد:

```{r}
commas <- function(x) {
  str_flatten(x, collapse = ", ", last = " and ")
}

commas(c("cat", "dog", "pigeon"))
#> [1] "cat, dog and pigeon"
```

یا ممکن است یک محاسبه ساده را بسته‌بندی کنید، مانند ضریب تغییرات، که انحراف معیار را بر میانگین تقسیم می‌کند:

```{r}
cv <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}

cv(runif(100, min = 0, max = 50))
#> [1] 0.5298797
cv(runif(100, min = 0, max = 500))
#> [1] 0.4559223
```

یا شاید فقط می‌خواهید هدف محاسبه را واضح‌تر کنید:

```{r}
# https://twitter.com/gbganalyst/status/1571619641390252033
n_missing <- function(x) {
  sum(is.na(x))
}
```

همچنین می‌توانید از این الگو برای پوشش دادن توابع عادی با یک API متفاوت استفاده کنید. برای مثال، ممکن است همیشه آرگومان `na.rm` را فراموش کنید، بنابراین توابع کمکی‌ای ایجاد کنید که آن را همیشه تنظیم کند:

```{r}
# https://twitter.com/DavisVaughan/status/1571613626441510918
mape <- function(actual, predicted) {
  sum(abs((actual - predicted) / actual)) / length(actual)
}
```

### ۶.۲.۲۵ تمرین‌ها

1. تمرین تبدیل قطعه کدهای زیر به توابع. به این فکر کنید که هر تابع چه کاری انجام می‌دهد. آن را چه می‌نامید؟ چند آرگومان نیاز دارد؟

```{r}
mean(is.na(x))
mean(is.na(y))
mean(is.na(z))
```

```{r}
x / sum(x, na.rm = TRUE)
y / sum(y, na.rm = TRUE)
z / sum(z, na.rm = TRUE)
```

```{r}
round(x / sum(x, na.rm = TRUE) * 100, 1)
round(y / sum(y, na.rm = TRUE) * 100, 1)
round(z / sum(z, na.rm = TRUE) * 100, 1)
```

2. در نسخه دوم `rescale01()`، مقادیر بی‌نهایت بدون تغییر باقی می‌مانند. آیا می‌توانید `rescale01()` را دوباره بنویسید به طوری که `-Inf` به 0 و `Inf` به 1 نگاشت شود؟

3. با توجه به بردار تولدها، تابعی بنویسید که سن را در سال‌ها محاسبه کند.

4. تابعی بنویسید که خود مقدار `mean` و `median` را محاسبه کرده و یک بردار نامگذاری شده از طول 2 برگرداند.

5. تابعی بنویسید که هر دو مقدار `sd()` و `mad()` را محاسبه کند. `mad()` چیست؟

## ۷.۲۵ توابع دیتافریم

توابع برداری مفید هستند زیرا بیشتر توابع dplyr از بردارها استفاده می‌کنند. اما توابع برداری یک مشکل دارند: آنها می‌توانند نام ستون‌ها را دریافت نمی‌کنند، که باعث می‌شود تکرار احتمالی وجود داشته باشد. به عنوان مثال، تصور کنید که چندین ستون عددی داشتید و می‌خواستید همه آنها را با `rescale01()` تبدیل کنید. شما نمی‌توانید چیزی شبیه به این بنویسید:

```{r}
df |> mutate(rescale01(a, b, c, d))
```

زیرا `rescale01()` یک بردار را می‌گیرد، نه چندین ستون. به جای آن، ما باید کد را تکرار کنیم:

```{r}
df |> mutate(
  a = rescale01(a),
  b = rescale01(b),
  c = rescale01(c),
  d = rescale01(d)
)
```

برای کاهش تکرار، می‌توانید از توابع خود استفاده کنید که با dplyr verbs کار می‌کنند. این توابع دیتافریم نامیده می‌شوند و آنها یک دیتافریم را می‌گیرند و یک دیتافریم را برمی‌گردانند.

### ۸.۲.۲۵ پذیرفتن (Embracing) با `{{ }}`

بیایید نحوه نوشتن تابعی را که به ما امکان می‌دهد به نام ستون‌های تعداد دلخواه اشاره کنیم و سپس `rescale01()` را برای هر یک اعمال کنیم، یاد بگیریم:

```{r}
rescale_cols <- function(df, ...) {
  df |> 
    mutate(
      across(c(...), rescale01)
    )
}

df |> rescale_cols(a, b, c, d)
```

این تابع از یک تکنیک خاص استفاده می‌کند که **data masking** نامیده می‌شود. Data masking یک ویژگی است که به tidyverse اجازه می‌دهد شما را نوشتن کد تمیزتر و کوتاه‌تر کند. این به شما این امکان را می‌دهد که به متغیرها در دیتافریم اشاره کنید گویی که آنها متغیرهای موجود در محیط شما هستند.

کلیدی‌ترین ابزار برای data masking عملگر `{{ }}` است، که نام ستون را "در آغوش می‌گیرد". آرگومان `...` همچنین به طور خودکار در آغوش گرفته می‌شود. برای درک این موضوع، بیایید به یک مثال ساده نگاه کنیم:

```{r}
summary_stats <- function(df, var) {
  df |> 
    summarize(
      mean = mean({{ var }}, na.rm = TRUE),
      median = median({{ var }}, na.rm = TRUE),
      sd = sd({{ var }}, na.rm = TRUE),
      n = n()
    )
}

diamonds |> summary_stats(carat)
diamonds |> group_by(cut) |> summary_stats(carat)
```

### ۹.۲.۲۵ موارد استفاده رایج

نگاه کردن به چند مورد استفاده رایج از این توابع مفید است:

```{r}
# https://twitter.com/yutannihilation/status/1574387230384730118
count_prop <- function(df, var, sort = FALSE) {
  df |>
    count({{ var }}, sort = sort) |>
    mutate(prop = n / sum(n))
}

diamonds |> count_prop(clarity)
```

یا شاید می‌خواهید در یک دیتافریم تعیین کنید که کدام مقادیر منحصربه‌فرد رایج‌ترین هستند:

```{r}
# https://twitter.com/pollicipes/status/1571606508944719876
unique_where <- function(df, condition, var) {
  df |> 
    filter({{ condition }}) |> 
    distinct({{ var }}) |> 
    arrange({{ var }})
}

flights |> unique_where(month == 12, dest)
```

یا شاید می‌خواهید گروه‌بندی و خلاصه‌سازی را در یک تابع واحد ترکیب کنید:

```{r}
# https://twitter.com/yutannihilation/status/1574387230384730118
grouped_mean <- function(df, group_var, mean_var) {
  df |> 
    group_by({{ group_var }}) |> 
    summarize(mean_val = mean({{ mean_var }}, na.rm = TRUE))
}

diamonds |> grouped_mean(cut, carat)
```

### ۱۰.۲.۲۵ Data masking در مقابل tidy-selection

گاهی اوقات می‌خواهید یک توابع بنویسید که هم data masking و هم tidy-selection را ترکیب کند. به عنوان مثال، تصور کنید که می‌خواهید تابعی بنویسید که یک چارک از یک متغیر را در مقابل یک متغیر گروه‌بندی رسم کند. چگونه آن را بنویسیم؟

```{r}
# https://twitter.com/sharlagelfand/status/1574376332821204993
summarize_by <- function(df, summary_vars, group_var) {
  df |> 
    group_by(pick({{ group_var }})) |> 
    summarize(across({{ summary_vars }}, \(x) mean(x, na.rm = TRUE)), .groups = "drop")
}

diamonds |> summarize_by(starts_with("c"), cut)
```

توجه کنید که برای انتقال `group_var` به `group_by()` از `pick()` استفاده کردیم، زیرا `group_by()` از data masking استفاده می‌کند، نه tidy-selection.

### ۱۱.۲.۲۵ تمرین‌ها

1. ساختن یک فایل گزارش که شامل میانگین هر متغیر عددی باشد. شما ممکن است بخواهید از `across()` و `where(is.numeric)` استفاده کنید.

2. می‌توانیم به یک شکل متفاوت `count_prop()` را دوباره نویسی کنیم که در آن مقدار `n` در یک ستون اضافی بگذاریم. کدام را ترجیح می‌دهید؟

3. ابهامی در تعریف `count_prop()` وجود دارد. اگر یک متغیر به نام `n` را به آن بدهید، کد شکست خواهد خورد. چرا؟ چگونه می‌توانید آن را برطرف کنید؟

## ۱۲.۲۵ توابع رسم نمودار

به جای برگرداندن دیتافریم، ممکن است بخواهید یک نمودار برگردانید. خوشبختانه، می‌توانید از همان تکنیک‌ها برای رسم نمودار استفاده کنید. فقط به یاد داشته باشید که `+` ggplot2 چیزی شبیه به pipe نیست، بنابراین باید آن را خارج از پایپ استفاده کنید.

```{r}
# https://twitter.com/sharlagelfand/status/1574376332821204993
histogram <- function(df, var, binwidth) {
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth)
}

diamonds |> histogram(carat, 0.1)
```

توجه داشته باشید که توابع رسم نمودار نباید فقط به ggplot2 محدود شوند. شما همچنین می‌توانید آنها را برای پیکربندی ggplot با یک تم خاص، اضافه کردن برچسب‌های استاندارد، و غیره استفاده کنید. به عنوان مثال:

```{r}
# https://twitter.com/tylermorganwall/status/1574377284343828480
linearity_check <- function(df, x, y) {
  df |>
    ggplot(aes(x = {{ x }}, y = {{ y }})) +
    geom_point() +
    geom_smooth(method = "loess", formula = y ~ x, color = "red", se = FALSE) +
    geom_smooth(method = "lm", formula = y ~ x, color = "blue", se = FALSE) 
}

starwars |> 
  filter(mass < 1000) |> 
  linearity_check(mass, height)
```

### ۱۳.۲.۲۵ ترکیب با سایر tidyverse

بسیاری از توابع tidyverse از data masking استفاده می‌کنند و `{{ }}` با همه آنها کار می‌کند. اینجا چند مثال وجود دارد:

```{r}
# https://twitter.com/mcnees/status/1574380137514536960
sorted_bars <- function(df, var) {
  df |> 
    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |>
    ggplot(aes(y = {{ var }})) +
    geom_bar()
}

diamonds |> sorted_bars(clarity)
```

همچنین می‌توانید توابعی بنویسید که از توابع stringr یا lubridate استفاده می‌کنند:

```{r}
# https://twitter.com/DrMowinckels/status/1574370645736185858
conditional_bars <- function(df, condition, var) {
  df |> 
    filter({{ condition }}) |> 
    ggplot(aes(x = {{ var }})) + 
    geom_bar()
}

diamonds |> conditional_bars(cut == "Good", clarity)
```

### ۱۴.۲.۲۵ برچسب‌گذاری

یکی از چالش‌های رسم نمودار در توابع این است که عناوین محورها اغلب خوب نیستند. می‌توانید آنها را با `labs()` بهبود ببخشید:

```{r}
histogram <- function(df, var, binwidth = NULL) {
  label <- rlang::englue("A histogram of {{ var }}")
  
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth) + 
    labs(title = label)
}

diamonds |> histogram(carat, 0.1)
```

توجه کنید که به جای `str_glue()` از `rlang::englue()` استفاده می‌کنیم. `englue()` مانند `str_glue()` کار می‌کند، اما `{{ }}` را برای data masking می‌فهمد.

### ۱۵.۲.۲۵ تمرین‌ها

1. یک تابع `density_plot()` بنویسید که مانند `histogram()` کار کند اما به جای آن از `geom_density()` استفاده کند.

2. تابعی بنویسید که یک نمودار پراکنش با یک خط روند ایجاد کند.

3. چگونه `sorted_bars()` را تعمیم دهید به طوری که بتوانید ترتیب را انتخاب کنید؟

## ۱۶.۲۵ سبک

R هیچ نظر رسمی در مورد نحوه قرار دادن توابع شما ندارد، اما از یک سبک استاندارد پیروی کردن خوب است. در اینجا سبکی که ما توصیه می‌کنیم آمده است:

- شروع هر تابع باید با یک توضیح مختصر از آنچه که تابع انجام می‌دهد باشد.
- از نام‌های توصیفی استفاده کنید. اگر نام تابع شما بیش از یک کلمه است، از snake_case استفاده کنید.
- اگر یک تابع دارای آرگومان‌های زیادی است، آنها را در چند خط قرار دهید.
- خط‌های خالی را برای جدا کردن بخش‌های مختلف تابع استفاده کنید.
- اگر یک مقدار محاسبه شده چندین بار استفاده می‌شود، آن را در یک متغیر موقت با نامی توصیفی ذخیره کنید.
- از بازگشت صریح استفاده کنید. هرچند R به طور خودکار آخرین بیانیه را برمی‌گرداند، بهتر است صریح باشید.

```{r}
# Good
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

# Bad
f <- function(x) { (x - min(x, na.rm = TRUE, finite = TRUE)) / 
  (max(x, na.rm = TRUE, finite = TRUE) - min(x, na.rm = TRUE, finite = TRUE)) }
```

## ۱۷.۲.۵ خلاصه

در این فصل، یاد گرفتید چگونه توابع بنویسید که وظایف رایج را خودکار می‌کنند. توابع به شما کمک می‌کنند:

- کد قابل خواندن‌تر بنویسید با استفاده از نام‌های توصیفی
- وقتی نیازمندی‌ها تغییر می‌کنند، تنها در یک مکان کد را به‌روزرسانی کنید
- از اشتباهات کپی و پیست جلوگیری کنید
- کار را بین پروژه‌ها به اشتراک بگذارید

شما سه نوع مهم تابع یاد گرفتید:

- **توابع برداری** که یک یا چند بردار می‌گیرند و یک بردار برمی‌گردانند.
- **توابع دیتافریم** که یک دیتافریم می‌گیرند و یک دیتافریم برمی‌گردانند.
- **توابع رسم نمودار** که یک نمودار ایجاد می‌کنند.

اکنون که پایه‌های توابع را دارید، می‌توانید شروع به نوشتن توابع خاص خود برای ساده‌تر کردن تحلیل‌های خود کنید. توابع یکی از ابزارهای قدرتمند در R هستند و تسلط بر آنها شما را به یک برنامه‌نویس بهتر تبدیل می‌کند.

در فصل بعدی، درباره تکرار (iteration) یاد خواهید گرفت، که به شما کمک می‌کند همان عملیات را روی چندین ورودی اعمال کنید.
