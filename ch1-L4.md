# درس 4: سبک کدنویسی 

سبک خوب کدنویسی مانند علائم نگارشی درست است: می‌توان بدون آن کار کرد، اما واقعاً آن را آسان‌تر می‌کند که بخوانید.
حتی به عنوان یک برنامه‌نویس بسیار مبتدی، کار روی سبک کدتان ایده خوبی است.
استفاده از یک سبک سازگار باعث می‌شود دیگران (از جمله آینده شما!) آسان‌تر کارتان را بخوانند و این به خصوص اگر نیاز به کمک از کس دیگری داشته باشید مهم است.
این فصل مهم‌ترین نکات [راهنمای سبک tidyverse](https://style.tidyverse.org) را معرفی خواهد کرد که در سراسر این کتاب استفاده می‌شود.

سبک دادن به کدتان در ابتدا کمی خسته‌کننده خواهد بود، اما اگر آن را تمرین کنید، به زودی طبیعت دوم خواهد شد.
علاوه بر این، ابزارهای عالی برای تغییر سبک سریع کد موجود وجود دارد، مانند بسته [**styler**](https://styler.r-lib.org) توسط لورنتز والترت.
پس از نصب آن با `install.packages("styler")`، راه آسان برای استفاده از آن از طریق **پالت فرمان** RStudio است.
پالت فرمان به شما اجازه استفاده از هر فرمان داخلی RStudio و بسیاری از افزونه‌های ارائه شده توسط بسته‌ها را می‌دهد.
پالت را با فشردن Cmd/Ctrl + Shift + P باز کنید، سپس "styler" را تایپ کنید تا تمام میانبرهای ارائه شده توسط styler را ببینید.

برای مثال‌های کد در این فصل از بسته‌های tidyverse و nycflights13 استفاده خواهیم کرد.

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(nycflights13)
```

## نام‌ها

به طور خلاصه در مورد نام‌ها صحبت کردیم.
به یاد داشته باشید که نام متغیرها (آنهایی که با `<-` ایجاد می‌شوند و آنهایی که با `mutate()` ایجاد می‌شوند) باید فقط از حروف کوچک، اعداد و `_` استفاده کنند.
از `_` برای جدا کردن کلمات در یک نام استفاده کنید.

```{r}
#| eval: false
# تلاش کنید برای:
short_flights <- flights |> filter(air_time < 60)

# اجتناب کنید:
SHORTFLIGHTS <- flights |> filter(air_time < 60)
```

به عنوان یک قاعده کلی، بهتر است نام‌های طولانی و توصیفی که آسان فهم هستند را به نام‌های مختصر که سریع تایپ می‌شوند ترجیح دهید.
نام‌های کوتاه در هنگام نوشتن کد زمان نسبتاً کمی صرفه‌جویی می‌کنند (به خصوص از آنجا که تکمیل خودکار به شما کمک می‌کند آنها را کامل کنید)، اما زمانی که به کد قدیمی بازمی‌گردید و مجبور به حل یک مخفف رمزآلود هستید، می‌تواند زمان‌بر باشد.

اگر مجموعه‌ای از نام‌ها برای چیزهای مرتبط دارید، بهترین تلاشتان را برای سازگار بودن انجام دهید.
آسان است که ناسازگاری‌ها زمانی که قرارداد قبلی را فراموش می‌کنید پدید بیایند، پس اگر مجبور به برگشتن و تغییر نام چیزها هستید احساس بدی نداشته باشید.
به طور کلی، اگر مجموعه‌ای از متغیرها دارید که تنوعی از یک موضوع هستند، بهتر است پیشوند مشترک به آنها بدهید تا پسوند مشترک چون تکمیل خودکار بر روی ابتدای یک متغیر بهتر کار می‌کند.

## فاصله‌ها

فاصله در دو طرف عملگرهای ریاضی به جز `^` (یعنی `+`، `-`، `==`، `<`، ...) و اطراف عملگر تخصیص (`<-`) قرار دهید.

```{r}
#| eval: false
# تلاش کنید برای
z <- (a + b)^2 / d

# اجتناب کنید
z<-( a + b ) ^ 2/d
```

فاصله داخل یا خارج پرانتز برای تماس‌های عادی تابع قرار ندهید.
همیشه بعد از کاما فاصله قرار دهید، درست مانند انگلیسی استاندارد.

```{r}
#| eval: false
# تلاش کنید برای
mean(x, na.rm = TRUE)

# اجتناب کنید
mean (x ,na.rm=TRUE)
```

اگر تراز بندی را بهبود می‌بخشد، اضافه کردن فاصله‌های اضافی مشکلی ندارد.
برای مثال، اگر متغیرهای متعددی در `mutate()` ایجاد می‌کنید، ممکن است بخواهید فاصله‌ها را اضافه کنید تا همه `=` در یک خط قرار بگیرند.
این خواندن کد را آسان‌تر می‌کند.

```{r}
#| eval: false
flights |> 
  mutate(
    speed      = distance / air_time,
    dep_hour   = dep_time %/% 100,
    dep_minute = dep_time %%  100
  )
```

## پایپ‌ها {#sec-pipes}

`|>` همیشه باید فاصله‌ای قبل از خود داشته باشد و معمولاً آخرین چیز در یک خط باشد.
این اضافه کردن مراحل جدید، تنظیم مجدد مراحل موجود، اصلاح عناصر درون یک مرحله، و دیدن کلی با مرور کردن فعل‌ها در سمت چپ را آسان‌تر می‌کند.

```{r}
#| eval: false
# تلاش کنید برای 
flights |>  
  filter(!is.na(arr_delay), !is.na(tailnum)) |> 
  count(dest)

# اجتناب کنید
flights|>filter(!is.na(arr_delay), !is.na(tailnum))|>count(dest)
```

اگر تابعی که به آن پایپ می‌کنید آرگومان‌های نام‌دار دارد (مانند `mutate()` یا `summarize()`)، هر آرگومان را در خط جدید قرار دهید.
اگر تابع آرگومان‌های نام‌دار ندارد (مانند `select()` یا `filter()`)، همه چیز را در یک خط نگه دارید مگر اینکه جا نشود، در این صورت باید هر آرگومان را در خط جداگانه‌اش قرار دهید.

```{r}
#| eval: false
# تلاش کنید برای
flights |>  
  group_by(tailnum) |> 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

# اجتناب کنید
flights |>
  group_by(
    tailnum
  ) |> 
  summarize(delay = mean(arr_delay, na.rm = TRUE), n = n())
```

بعد از مرحله اول pipeline، هر خط را دو فاصله تورفتگی کنید.
RStudio به طور خودکار فاصله‌ها را بعد از شکست خط به دنبال `|>` برایتان قرار می‌دهد.
اگر هر آرگومان را در خط جداگانه‌اش قرار می‌دهید، دو فاصله اضافی تورفتگی کنید.
مطمئن شوید `)` در خط جداگانه‌اش است، و برای تطبیق با موقعیت افقی نام تابع تورفتگی نشده است.

```{r}
#| eval: false
# تلاش کنید برای 
flights |>  
  group_by(tailnum) |> 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

# اجتناب کنید
flights|>
  group_by(tailnum) |> 
  summarize(
             delay = mean(arr_delay, na.rm = TRUE), 
             n = n()
           )

# اجتناب کنید
flights|>
  group_by(tailnum) |> 
  summarize(
  delay = mean(arr_delay, na.rm = TRUE), 
  n = n()
  )
```

اگر pipeline شما به راحتی در یک خط جا می‌شود، نقض برخی از این قوانین مشکلی ندارد.
اما در تجربه جمعی ما، معمول است که قطعات کوتاه طولانی‌تر شوند، پس معمولاً با شروع با تمام فضای عمودی که نیاز دارید در درازمدت زمان صرفه‌جویی خواهید کرد.

```{r}
#| eval: false
# این به طور فشرده در یک خط جا می‌شود
df |> mutate(y = x + 1)

# در حالی که این 4 برابر خط بیشتر می‌گیرد، آسان به 
# متغیرهای بیشتر و مراحل بیشتر در آینده قابل گسترش است
df |> 
  mutate(
    y = x + 1
  )
```

در نهایت، مراقب نوشتن pipeline‌های بسیار طولانی باشید، مثلاً طولانی‌تر از 10-15 خط.
سعی کنید آنها را به کارهای فرعی کوچک‌تر تقسیم کنید، به هر کار نام اطلاع‌رسان بدهید.
نام‌ها به خواننده کمک می‌کنند تا بفهمد چه اتفاقی می‌افتد و بررسی اینکه نتایج میانی طبق انتظار هستند را آسان‌تر می‌کند.
هر زمان که می‌توانید چیزی را نام اطلاع‌رسان بدهید، باید نام اطلاع‌رسان بدهید، برای مثال زمانی که ساختار داده را اساساً تغییر می‌دهید، مثلاً بعد از pivoting یا خلاصه‌سازی.
انتظار نداشته باشید که از اولین بار درست شود!
این یعنی تقسیم pipeline‌های طولانی اگر حالت‌های میانی باشند که می‌توانند نام‌های خوب بگیرند.

## ggplot2

همان قوانین اساسی که برای pipe اعمال می‌شود برای ggplot2 نیز اعمال می‌شود؛ فقط `+` را مانند `|>` رفتار کنید.

```{r}
#| eval: false
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE)
  ) |> 
  ggplot(aes(x = month, y = delay)) +
  geom_point() + 
  geom_line()
```

دوباره، اگر نمی‌توانید همه آرگومان‌های یک تابع را در یک خط قرار دهید، هر آرگومان را در خط جداگانه‌اش قرار دهید:

```{r}
#| eval: false
flights |> 
  group_by(dest) |> 
  summarize(
    distance = mean(distance),
    speed = mean(distance / air_time, na.rm = TRUE)
  ) |> 
  ggplot(aes(x = distance, y = speed)) +
  geom_smooth(
    method = "loess",
    span = 0.5,
    se = FALSE, 
    color = "white", 
    linewidth = 4
  ) +
  geom_point()
```

مراقب انتقال از `|>` به `+` باشید.
آرزو می‌کنیم این انتقال لازم نبود، اما متأسفانه ggplot2 قبل از کشف pipe نوشته شده بود.

## نظرات بخش‌بندی

همانطور که اسکریپت‌هایتان طولانی‌تر می‌شوند، می‌توانید از نظرات **بخش‌بندی** برای تقسیم فایلتان به قطعات قابل مدیریت استفاده کنید:

```{r}
#| eval: false
# بارگذاری داده --------------------------------------

# رسم داده --------------------------------------
```

RStudio میانبر صفحه کلید برای ایجاد این سرتیترها فراهم می‌کند (Cmd/Ctrl + Shift + R)، و آنها را در منوی کشویی ناوبری کد در پایین-چپ ویرایشگر نمایش می‌دهد.

## تمرین‌ها

1. pipeline‌های زیر را دنبال کردن راهنماهای بالا تغییر سبک دهید.

    ```{r}
    #| eval: false
    flights|>filter(dest=="IAH")|>group_by(year,month,day)|>summarize(n=n(),
    delay=mean(arr_delay,na.rm=TRUE))|>filter(n>10)

    flights|>filter(carrier=="UA",dest%in%c("IAH","HOU"),sched_dep_time>
    0900,sched_arr_time<2000)|>group_by(flight)|>summarize(delay=mean(
    arr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|>filter(n>10)
    ```

## خلاصه

در این فصل، مهم‌ترین اصول سبک کدنویسی را یاد گرفته‌اید.
اینها ممکن است در ابتدا مانند مجموعه‌ای از قوانین دلبخواهی به نظر برسند (چون هستند!) اما با گذشت زمان، همانطور که کد بیشتری می‌نویسید و کد را با افراد بیشتری به اشتراک می‌گذارید، خواهید دید که سبک سازگار چقدر مهم است.
و بسته styler را فراموش نکنید: راه عالی برای بهبود سریع کیفیت کد با سبک ضعیف است.

در فصل بعدی، به ابزارهای علم داده برمی‌گردیم و درباره داده‌های مرتب یاد می‌گیریم.
داده مرتب روش سازگاری از سازماندهی data frame‌هایتان است که در سراسر tidyverse استفاده می‌شود.
این سازگاری زندگی شما را آسان‌تر می‌کند چون وقتی داده مرتب دارید، فقط با اکثریت قریب به اتفاق توابع tidyverse کار می‌کند.
البته، زندگی هرگز آسان نیست، و اکثر مجموعه داده‌هایی که در طبیعت با آنها روبه‌رو می‌شوید از قبل مرتب نخواهند بود.
پس ما همچنین یاد خواهیم داد که چگونه از بسته tidyr برای مرتب کردن داده‌های نامرتبتان استفاده کنید.
