# درس ۳: راهنمای جامع Base R

## ۳.۲۵ مقدمه

برای پایان دادن به بخش برنامه‌نویسی، قصد داریم یک تور سریع از مهم‌ترین توابع base R که در جاهای دیگر این کتاب به آن‌ها نپرداخته‌ایم، به شما نشان دهیم. این ابزارها به‌ویژه هنگامی که برنامه‌نویسی بیشتری انجام می‌دهید مفید هستند و به شما کمک می‌کنند کدهایی را که در محیط‌های واقعی با آن‌ها روبرو می‌شوید بخوانید.

این مکان خوبی است برای یادآوری این نکته که tidyverse تنها راه برای حل مسائل علم داده نیست. ما tidyverse را در این کتاب آموزش می‌دهیم زیرا بسته‌های tidyverse یک فلسفه طراحی مشترک دارند که سازگاری بین توابع را افزایش می‌دهد و یادگیری و استفاده از هر تابع یا بسته جدید را کمی آسان‌تر می‌کند. استفاده از tidyverse بدون استفاده از base R امکان‌پذیر نیست، بنابراین ما در واقع **بسیاری** از توابع base R را به شما آموزش داده‌ایم: از `library()` برای بارگذاری بسته‌ها، تا `sum()` و `mean()` برای خلاصه‌های عددی، تا انواع داده factor، date و POSIXct، و البته تمام عملگرهای پایه مانند `+`، `-`، `/`، `*`، `|`، `&` و `!`. آنچه تاکنون بر آن تمرکز نکرده‌ایم، جریان‌های کاری base R است، بنابراین در این فصل به برخی از آن‌ها اشاره خواهیم کرد.

پس از خواندن این کتاب، رویکردهای دیگری را برای همان مسائل با استفاده از base R، data.table و سایر بسته‌ها یاد خواهید گرفت. بدون شک هنگام خواندن کدهای R نوشته شده توسط دیگران، به‌ویژه اگر از StackOverflow استفاده می‌کنید، با این رویکردهای دیگر روبرو خواهید شد. نوشتن کدی که از ترکیبی از رویکردها استفاده می‌کند کاملاً قابل قبول است، و نگذارید کسی به شما چیز دیگری بگوید!

در این فصل، بر چهار موضوع بزرگ تمرکز خواهیم کرد: زیرمجموعه‌سازی با `[`، زیرمجموعه‌سازی با `[[` و `$`، خانواده توابع apply، و حلقه‌های `for`. در پایان، به طور خلاصه به دو تابع ضروری رسم نمودار خواهیم پرداخت.

### ۱.۳.۲۵ پیش‌نیازها

این بسته بر base R تمرکز دارد بنابراین پیش‌نیازهای واقعی ندارد، اما tidyverse را بارگذاری خواهیم کرد تا برخی از تفاوت‌ها را توضیح دهیم.

```{r}
library(tidyverse)
```

## ۲.۲۵ انتخاب چندین عنصر با `[`

`[` برای استخراج اجزای فرعی از بردارها و دیتافریم‌ها استفاده می‌شود و مانند `x[i]` یا `x[i, j]` فراخوانی می‌شود. در این بخش، شما را با قدرت `[` آشنا خواهیم کرد، ابتدا نشان می‌دهیم چگونه می‌توانید از آن با بردارها استفاده کنید، سپس اینکه چگونه همان اصول به روشی ساده به ساختارهای دوبعدی (2d) مانند دیتافریم‌ها گسترش می‌یابند. سپس به شما کمک خواهیم کرد این دانش را با نشان دادن اینکه چگونه افعال مختلف dplyr حالت‌های خاص `[` هستند، تثبیت کنید.

### ۱.۲.۲۵ زیرمجموعه‌سازی بردارها

پنج نوع اصلی از چیزهایی وجود دارد که می‌توانید یک بردار را با آن‌ها زیرمجموعه کنید، یعنی می‌توانند `i` در `x[i]` باشند:

۱. **یک بردار از اعداد صحیح مثبت**. زیرمجموعه‌سازی با اعداد صحیح مثبت، عناصر را در آن موقعیت‌ها نگه می‌دارد:

```{r}
x <- c("one", "two", "three", "four", "five")
x[c(3, 2, 5)]
#> [1] "three" "two"   "five"
```

با تکرار یک موقعیت، در واقع می‌توانید خروجی طولانی‌تر از ورودی ایجاد کنید که اصطلاح "زیرمجموعه‌سازی" را کمی نامناسب می‌کند.

```{r}
x[c(1, 1, 5, 5, 5, 2)]
#> [1] "one"  "one"  "five" "five" "five" "two"
```

۲. **یک بردار از اعداد صحیح منفی**. مقادیر منفی عناصر را در موقعیت‌های مشخص شده حذف می‌کنند:

```{r}
x[c(-1, -3, -5)]
#> [1] "two"  "four"
```

۳. **یک بردار منطقی**. زیرمجموعه‌سازی با یک بردار منطقی تمام مقادیری را که با مقدار `TRUE` مطابقت دارند نگه می‌دارد. این اغلب در ترکیب با توابع مقایسه‌ای مفید است.

```{r}
x <- c(10, 3, NA, 5, 8, 1, NA)

# همه مقادیر غیرگمشده x
x[!is.na(x)]
#> [1] 10  3  5  8  1

# همه مقادیر زوج (یا گمشده!) x
x[x %% 2 == 0]
#> [1] 10 NA  8 NA
```

بر خلاف `filter()`، شاخص‌های `NA` به عنوان `NA` در خروجی گنجانده خواهند شد.

۴. **یک بردار کاراکتری**. اگر یک بردار نام‌گذاری شده دارید، می‌توانید آن را با یک بردار کاراکتری زیرمجموعه کنید:

```{r}
x <- c(abc = 1, def = 2, xyz = 5)
x[c("xyz", "def")]
#> xyz def 
#>   5   2
```

مانند زیرمجموعه‌سازی با اعداد صحیح مثبت، می‌توانید از یک بردار کاراکتری برای تکرار ورودی‌های جداگانه استفاده کنید.

۵. **هیچ‌چیز**. نوع نهایی زیرمجموعه‌سازی، هیچ‌چیز است، `x[]`، که کامل `x` را برمی‌گرداند. این برای زیرمجموعه‌سازی بردارها مفید نیست، اما همانطور که به زودی خواهیم دید، هنگام زیرمجموعه‌سازی ساختارهای 2d مانند tibble‌ها مفید است.

### ۲.۲.۲۵ زیرمجموعه‌سازی دیتافریم‌ها

روش‌های متفاوت زیادی وجود دارد که می‌توانید `[` را با یک دیتافریم استفاده کنید، اما مهم‌ترین روش انتخاب سطرها و ستون‌ها به طور مستقل با `df[rows, cols]` است. در اینجا `rows` و `cols` بردارهایی هستند که در بالا توضیح داده شد. به عنوان مثال، `df[rows, ]` و `df[, cols]` فقط سطرها یا فقط ستون‌ها را انتخاب می‌کنند و از زیرمجموعه خالی برای حفظ بعد دیگر استفاده می‌کنند.

در اینجا چند مثال از استفاده از `df[rows, cols]` برای انتخاب سطرها و ستون‌ها از tibble `diamonds` که از ggplot2 می‌آید، آورده شده است. برای راحتی بصری، یک دیتافریم کوچک با 10 سطر و 3 ستون ایجاد می‌کنیم:

```{r}
df <- tibble(
  x = 1:3, 
  y = c("a", "e", "f"), 
  z = runif(3)
)

# انتخاب دو سطر اول و همه ستون‌ها
df[1:2, ]

# انتخاب همه سطرها و ستون‌های x و y
df[, c("x" , "y")]

# انتخاب سطرهای 1 و 3 و ستون‌های x و y
df[c(1, 3), c("x", "y")]
```

ما در مورد `[` در فصل‌های زیادی از این کتاب صحبت خواهیم کرد:

- @sec-logicals برخی از جزئیات `[` با بردارهای منطقی را پوشش می‌دهد، مانند اینکه چگونه می‌توانید مقادیر `TRUE` و `FALSE` را ایجاد کنید و چگونه می‌توانید با مقادیر گمشده در آن‌ها کار کنید.

- @sec-strings معرفی می‌کند `str_subset()` که به شما امکان می‌دهد رشته‌هایی را که با یک الگو مطابقت دارند انتخاب کنید.

- @sec-numbers از `[` برای استخراج عناصر یک بردار استفاده می‌کند.

- @sec-group-by نشان می‌دهد چگونه می‌توانید از `[` برای انتخاب ستون‌ها در یک دیتافریم استفاده کنید.

ما در مورد هر کدام از این موارد در فصول آینده بیشتر صحبت خواهیم کرد.

### ۳.۲.۲۵ افعال dplyr

چندین فعل dplyr به طور خاص به عنوان "میانبر" برای اشکال رایج `[` طراحی شده‌اند. مزایای استفاده از این افعال این است که آن‌ها معنای عملیات را بسیار واضح‌تر می‌کنند (تفاوت بین انتخاب سطرها و ستون‌ها واضح نیست تا زمانی که با دقت به `[` نگاه کنید) و آن‌ها بسیاری از موارد لبه را برای شما بررسی می‌کنند.

- `filter()` معادل زیرمجموعه‌سازی سطرها با یک بردار منطقی است، مراقب نگه داشتن فقط سطرهایی که `TRUE` هستند:

```{r}
df <- tibble(
  x = c(2, 3, 1, 1, NA), 
  y = letters[1:5], 
  z = runif(5)
)
df |> filter(x > 1)

# معادل base R
df[!is.na(df$x) & df$x > 1, ]
```

یک جزئیات مهم دیگر از `filter()` این است که شما می‌توانید معادل `&` را با عبور دادن چندین عبارت به `filter()` تحقق دهید:

```{r}
df |> filter(!is.na(x), x > 1)
```

- `arrange()` معادل زیرمجموعه‌سازی سطرها با یک بردار صحیح است، معمولاً ایجاد شده با `order()`:

```{r}
df |> arrange(x, y)

# معادل base R
df[order(df$x, df$y), ]
```

توجه داشته باشید که عبارت base R از یک `,` اضافی استفاده می‌کند. اگر آن را فراموش کنید، سطرها را به جای ستون‌ها انتخاب می‌کنید:

```{r}
df[order(df$x, df$y)]
```

- هم `select()` و هم `relocate()` معادل زیرمجموعه‌سازی ستون‌ها با یک بردار کاراکتری هستند:

```{r}
df |> select(x, z)

# معادل base R
df[, c("x", "z")]
```

توابع انتخابگر base R برای استفاده تعاملی وجود ندارند، اما می‌توانید از `grep()` برای انتخاب ستون‌هایی با یک الگو استفاده کنید:

```{r}
df |> select(starts_with("x"))

# معادل base R
df[, grepl("^x", names(df))]
```

- `mutate()` معادل ایجاد یک ستون جدید و سپس (اختیاری) حذف ستون قدیمی است:

```{r}
df |> mutate(z = x + y)

# معادل base R
df$z <- df$x + df$y
df
```

- `summarise()` با `[` معادلی ندارد زیرا شکل خروجی را تغییر می‌دهد.

### ۴.۲.۲۵ تمرین‌ها

۱. با یک tibble شروع کنید و به تعداد روش‌های ممکنی که می‌توانید به یک ستون واحد دیگر استخراج کنید فکر کنید. چگونه می‌توانید یک ستون واحد به عنوان یک بردار استخراج کنید؟ به عنوان یک لیست تک عنصری؟

۲. تمرین تبدیل یک عبارت dplyr را به معادل base R انجام دهید. چه زمانی ارزش دارد از base R استفاده کنید؟

۳. لیستی از مقادیر تهیه کنید و با آن‌ها تمرین کنید.

## ۳.۲۵ انتخاب یک عنصر واحد با `$` و `[[`

`[`، که هر تعداد عنصر را انتخاب می‌کند، با `[[` و `$` جفت می‌شود، که هر یک یک عنصر واحد را استخراج می‌کنند. در این بخش، نحوه استفاده از `[[` و `$` را برای درآوردن ستون‌ها از دیتافریم‌ها، چگونگی استفاده از آن‌ها برای عناصر لیست، و چگونگی کمک آن‌ها برای کار با ستون‌های لیستی در tibble‌ها به شما نشان خواهیم داد.

### ۱.۳.۲۵ دیتافریم‌ها

`[[` و `$` می‌توانند برای استخراج ستون‌ها از یک دیتافریم استفاده شوند. `[[` می‌تواند با موقعیت یا نام دسترسی داشته باشد، و `$` به طور خاص برای دسترسی با نام است:

```{r}
tb <- tibble(
  x = 1:4,
  y = c(10, 4, 1, 21)
)

# با موقعیت
tb[[1]]

# با نام
tb[["x"]]
tb$x
```

همچنین می‌توانند برای ایجاد ستون‌های جدید استفاده شوند، معادل `mutate()`:

```{r}
tb$z <- tb$x + tb$y
tb
```

استفاده از `$` روشی رایج در توابع base R است که مانند `lm()` از tidy evaluation استفاده نمی‌کنند، بنابراین شما نمی‌توانید مستقیماً به نام ستون‌ها مراجعه کنید. در عوض، باید از `$` استفاده کنید:

```{r}
max(diamonds$carat)

lm(price ~ carat, data = diamonds)
```

### ۲.۳.۲۵ لیست‌ها

`[[` و `$` برای استخراج عناصر از لیست‌ها بسیار مهم هستند و ما به طور کامل در @sec-lists و @sec-rectangling به آن‌ها خواهیم پرداخت. برای اکنون، می‌خواهم بر تفاوت بین `[` و `[[` هنگام کار با یک لیست تمرکز کنم. بیایید یک لیست ساده ایجاد کنیم:

```{r}
l <- list(
  a = 1:3, 
  b = "a string", 
  c = pi, 
  d = list(-1, -5)
)
```

- `[` یک زیرلیست استخراج می‌کند. نتیجه همیشه یک لیست است.

```{r}
str(l[1:2])

str(l[1])

str(l[4])
```

مانند بردارها، می‌توانید با یک بردار منطقی، صحیح یا کاراکتری زیرمجموعه کنید.

- `[[` و `$` یک عنصر واحد از لیست استخراج می‌کنند. آن‌ها یک سطح از سلسله مراتب را حذف می‌کنند.

```{r}
str(l[[1]])

str(l[[4]])

str(l$a)
```

تفاوت بین `[` و `[[` بسیار مهم است، اما به راحتی درک نمی‌شود زیرا بیشتر بردارهایی که با آن‌ها کار می‌کنید همگن هستند (یعنی همه عناصر از نوع یکسانی هستند). برای دادن یک تصویر ذهنی بهتر، می‌توانید از یک مثال غیرعادی استفاده کنید: یک لیست کوکاکولا یا فلفل. اگر `x` یک لیست کوکاکولا است، آنگاه `x[1]` یک لیست کوکاکولای یک عنصری است، و `x[1:2]` یک لیست کوکاکولای دو عنصری است. `x[[1]]` خود کوکاکولا است. اگر می‌خواهید کمی از نوشیدنی داخل را بخورید، نیازی به حذف سطر آخر `[[` و `$` را با `x[[1]][[1]]` ندارید.

### ۳.۳.۲۵ ستون‌های لیستی

`[[` و `$` همچنین برای کار با ستون‌های لیستی بسیار مهم هستند. ستون‌های لیستی زمانی ایجاد می‌شوند که یک تابع tibble یک لیست در خروجی برمی‌گرداند:

```{r}
df <- tibble(
  x = 1:2, 
  y = c("a", "b"),
  z = list(list(1, 2), list(3, 4, 5))
)
df
```

به ستون `z` نگاه کنید: می‌بینید که در زیر آن `<list>` قرار دارد. به این معنی که این ستون یک لیست است، نه یک بردار اتمی:

```{r}
df |> 
  filter(x == 1)
```

این به این معنی است که عملیات معمول tibble هنوز کار می‌کنند اما به داده‌های درون لیست دسترسی ندارند. برای دسترسی به آن داده، باید از `unnest()` (که در @sec-rectangling پوشش داده می‌شود) یا یکی از توابع map (که در @sec-iteration پوشش داده می‌شود) استفاده کنید. اما می‌توانید از `[[` و `$` برای استخراج عناصر استفاده کنید:

```{r}
# اولین عنصر ستون لیستی z
df$z[[1]]

# اولین عنصر از اولین عنصر ستون لیستی z  
df$z[[1]][[1]]
```

### ۴.۳.۲۵ تمرین‌ها

۱. معادل `$` در base R چیست؟

۲. هنگامی که می‌خواهید به یک لیست دسترسی داشته باشید چه کاری انجام می‌دهید؟

۳. `mtcars[mtcars$cyl == 4, ]` و `mtcars[mtcars$cyl = 4, ]` چه کاری انجام می‌دهند؟ چرا آن‌ها متفاوت هستند؟

## ۴.۲۵ خانواده Apply

در @sec-iteration، شما یاد گرفتید که چگونه از purrr استفاده کنید تا انواع مختلفی از محاسبات را برای هر عنصر یک لیست اعمال کنید. purrr یک بسته به نسبت اخیر است (ابتدا در سال 2015 منتشر شد) و از base R الهام گرفته که شامل مجموعه‌ای از توابع است که ما آن را **خانواده apply** می‌نامیم زیرا همه نام‌ها با "apply" پایان می‌یابند. در این بخش، خلاصه‌ای از این توابع را ارائه خواهیم داد.

### ۱.۴.۲۵ مبانی

این خانواده شامل توابع `lapply()`، `sapply()`، `vapply()`، `tapply()`، `mapply()` و سایر موارد می‌شود. حرف قبل از apply نشان می‌دهد خروجی چیست:

- `lapply()` یک **l**ist برمی‌گرداند.
- `sapply()` یک **s**implified vector برمی‌گرداند.
- `vapply()` یک **v**ector با نوع مشخص برمی‌گرداند.
- `tapply()` یک **t**able array برمی‌گرداند.
- `mapply()` یک تابع **m**ultivariate است.

در اینجا چند مثال از `lapply()` و `sapply()` آورده شده است:

```{r}
# lapply یک لیست برمی‌گرداند
lapply(1:3, sqrt)

# sapply سعی می‌کند خروجی را ساده کند
sapply(1:3, sqrt)
```

نزدیک‌ترین معادل `lapply()` در purrr، `map()` است. مزیت اصلی `map()` در نحو کوتاه‌تر است: می‌توانید `.x` را برای اشاره به عنصر فعلی استفاده کنید:

```{r}
# در purrr
map(1:3, \(x) x^2)

# در lapply
lapply(1:3, function(x) x^2)
```

### ۲.۴.۲۵ `vapply()`

خانواده اصلی توابع apply، `lapply()` است. هم `sapply()` و هم `vapply()` تلاش می‌کنند خروجی `lapply()` را ساده کنند. `sapply()` خودکار حدس می‌زند چه نوع خروجی ساده‌ای باید ایجاد کند در حالی که `vapply()` به شما امکان می‌دهد آن را مشخص کنید. `vapply()` به طور کلی بهتر از `sapply()` است زیرا می‌تواند خطا بیشتری را کشف کند، اما طولانی‌تر برای نوشتن است. `vapply()` معادل `map_*()` در purrr است:

```{r}
# purrr
map_dbl(1:3, sqrt)

# base
vapply(1:3, sqrt, FUN.VALUE = double(1))
```

مزیت `vapply()` این است که می‌تواند نوع خروجی را صحیح‌تر بررسی کند، اما نویسنده پراکنده‌تر است زیرا شما باید یک "قالب" از نوع مورد انتظار ارائه دهید.

### ۳.۴.۲۵ سایر موارد

سه تابع دیگر در خانواده apply وجود دارد که کمتر به طور منظم استفاده می‌شوند:

- `tapply()` برای محاسبه یک تابع برای هر گروه در یک بردار.

- `mapply()` نسخه چندمتغیره `lapply()` است؛ مشابه `map2()` و `pmap()` در purrr.

- `apply()` برای کار با ماتریس‌ها و آرایه‌ها. به طور خاص، مراقب باشید که `apply(df, 2, something)` را استفاده نکنید که معادل base R `df |> summarise(across(everything(), something))` است. به دلیل استفاده از `apply()` از ماتریس‌ها، دیتافریم شما تبدیل به ماتریس می‌شود که به معنای تبدیل همه ستون‌ها به نوع یکسان است.

## ۵.۲۵ حلقه‌های `for`

حلقه‌های `for` معادل base R در purrr و tidy iteration هستند. آن‌ها بسیار انعطاف‌پذیر هستند و می‌توانند برای انواع مختلفی از مشکلات استفاده شوند. با این حال، آن‌ها به طور معمول کمی طولانی‌تر از معادل‌های purrr خود هستند.

### ۱.۵.۲۵ ساختار پایه

اشکال مختلفی از حلقه‌های `for` وجود دارد، اما ساده‌ترین و رایج‌ترین آن‌ها این است:

```{r}
for (element in vector) {
  # کدی که می‌خواهید برای هر عنصر اجرا شود
}
```

در اینجا یک مثال ساده آورده شده است که هر عنصر از یک بردار را چاپ می‌کند:

```{r}
for (i in 1:3) {
  print(i)
}
```

مهم‌ترین چیزی که باید در مورد حلقه‌های `for` بدانید این است که آن‌ها هیچ چیزی برنمی‌گردانند. آن‌ها برای اثرات جانبی خود فراخوانی می‌شوند، مانند نمودارسازی یا ذخیره فایل‌ها. اگر می‌خواهید خروجی را ذخیره کنید، باید آن را به صورت دستی در یک ساختار داده ذخیره کنید.

```{r}
# بد - چیزی ذخیره نمی‌شود
for (i in 1:3) {
  i^2
}

# خوب - خروجی در یک بردار ذخیره می‌شود
output <- vector("double", 3)
for (i in 1:3) {
  output[[i]] <- i^2
}
output
```

### ۲.۵.۲۵ حلقه در مقابل functionals

توابع مانند `lapply()` و `map()` را **functional** می‌نامیم زیرا آن‌ها تابعی را می‌گیرند و آن را روی هر عنصر یک بردار اعمال می‌کنند. هر جایی که می‌توانید از یک functional استفاده کنید، می‌توانید همان کار را با یک حلقه `for` انجام دهید. با این حال، functionals مزایایی نسبت به حلقه‌های `for` دارند:

- آن‌ها کوتاه‌تر و خواناتر هستند.
- آن‌ها واضح‌تر هستند که یک عملیات یکسان را روی هر عنصر اعمال می‌کنند.
- آن‌ها از بسیاری از مشکلات رایج که در حلقه‌های `for` رخ می‌دهد جلوگیری می‌کنند.

در نتیجه، من معمولاً توصیه می‌کنم که در صورت امکان از functional استفاده کنید. با این حال، حلقه‌های `for` هنوز مفید هستند، به ویژه هنگامی که:

- شما در حال کار بر روی یک عملیات پیچیده هستید که استفاده از functional را دشوار می‌کند.
- شما می‌خواهید کنترل بیشتری بر جریان اجرا داشته باشید.
- شما می‌خواهید کد را برای خودتان یا دیگران قابل فهم‌تر کنید.

### ۳.۵.۲۵ حلقه‌های تو در تو

گاهی اوقات نیاز دارید حلقه‌هایی را داشته باشید که در داخل حلقه‌های دیگر قرار دارند:

```{r}
for (i in 1:3) {
  for (j in 1:3) {
    print(paste(i, j))
  }
}
```

برای حلقه‌های تو در تو، مهم است که ساختار داده‌های خروجی را از قبل آماده کنید:

```{r}
output <- matrix(nrow = 3, ncol = 3)
for (i in 1:3) {
  for (j in 1:3) {
    output[i, j] <- i * j
  }
}
output
```

### ۴.۵.۲۵ دستورات کنترل جریان

در داخل حلقه‌های `for`، دو دستور کنترل جریان مفید وجود دارد:

- `next` تکرار فعلی را پرش می‌کند و به تکرار بعدی می‌رود.
- `break` از حلقه خارج می‌شود.

```{r}
for (i in 1:10) {
  if (i %% 2 == 0) {
    next
  }
  if (i > 7) {
    break
  }
  print(i)
}
```

### ۵.۵.۲۵ تمرین‌ها

۱. یک حلقه `for` بنویسید که هر عنصر از یک بردار را در ۲ ضرب کند.

۲. یک حلقه `for` تو در تو بنویسید که یک جدول ضرب ۱۰×۱۰ ایجاد کند.

۳. یک حلقه بنویسید که فقط اعداد اول بین ۱ تا ۱۰۰ را چاپ کند.

## ۶.۲۵ نمودارها

ما بیشتر از ggplot2 در این کتاب استفاده کرده‌ایم، اما سیستم نمودارسازی base R هم مفید است. در حالی که ggplot2 از یک سیستم دستور زبانی گرافیکی لایه‌ای استفاده می‌کند، توابع نمودارسازی base R روشی متفاوت دارند. آن‌ها بر اساس یک "مدل نقاش" هستند: شما نمودار را یک لایه در یک زمان ایجاد می‌کنید.

### ۱.۶.۲۵ نمودارها در base R

دو تابع اصلی برای ایجاد نمودارهای base R وجود دارد:

- `plot()`: تابع عمومی برای ایجاد نمودارها. بسته به نوع داده‌های ورودی، نمودار متفاوتی ایجاد می‌کند.
- `hist()`: برای ایجاد هیستوگرام.

```{r}
# نمودار پراکندگی
plot(mtcars$wt, mtcars$mpg)

# هیستوگرام
hist(mtcars$mpg)
```

### ۲.۶.۲۵ سفارشی‌سازی نمودارها

می‌توانید نمودارهای base R را با افزودن عناصر اضافی سفارشی کنید:

```{r}
# ایجاد یک نمودار پایه
plot(mtcars$wt, mtcars$mpg, 
     main = "وزن در مقابل مصرف سوخت",
     xlab = "وزن (1000 پوند)",
     ylab = "مایل به ازای گالن",
     pch = 19,
     col = "blue")

# افزودن یک خط
abline(lm(mpg ~ wt, data = mtcars), col = "red")

# افزودن متن
text(5, 30, "خط رگرسیون")
```

توابع دیگری که برای افزودن به نمودارها مفید هستند عبارتند از:

- `points()`: افزودن نقاط
- `lines()`: افزودن خطوط
- `abline()`: افزودن خطوط مستقیم
- `text()`: افزودن متن
- `legend()`: افزودن راهنما

### ۳.۶.۲۵ پارامترهای گرافیکی

می‌توانید پارامترهای گرافیکی را با استفاده از تابع `par()` تنظیم کنید. این به شما اجازه می‌دهد جنبه‌های مختلف نمودارها را کنترل کنید:

```{r}
# ذخیره تنظیمات فعلی
old_par <- par(no.readonly = TRUE)

# تنظیم پارامترها
par(mfrow = c(2, 2))  # ۲×۲ نمودار

# ایجاد چند نمودار
plot(mtcars$wt, mtcars$mpg)
plot(mtcars$hp, mtcars$mpg)
hist(mtcars$mpg)
hist(mtcars$wt)

# بازگرداندن تنظیمات قدیمی
par(old_par)
```

برخی از پارامترهای مفید `par()`:

- `mfrow` و `mfcol`: تنظیم چیدمان چند نمودار
- `mar`: تنظیم حاشیه‌ها
- `col`: تنظیم رنگ
- `pch`: تنظیم شکل نقطه
- `lty`: تنظیم نوع خط

### ۴.۶.۲۵ مقایسه با ggplot2

هر سیستم نمودارسازی مزایا و معایب خود را دارد:

**مزایای base R:**
- سریع‌تر برای نمودارهای ساده
- بخشی از R است، بنابراین نیاز به بسته اضافی ندارد
- مفید برای افزودن نمودارها به توابع

**مزایای ggplot2:**
- نحو سازگارتر و قابل پیش‌بینی‌تر
- نمودارهای پیچیده آسان‌تر ایجاد می‌شوند
- زیباتر به صورت پیش‌فرض
- بهتر با tidyverse یکپارچه می‌شود

به طور کلی، ما ggplot2 را برای بیشتر نیازهای نمودارسازی توصیه می‌کنیم، اما base R برای نمودارهای سریع و ساده یا هنگام کار با کد base R مفید است.

## ۷.۲۵ خلاصه

در این فصل، مروری بر برخی از ابزارهای اساسی base R داشتیم:

- **`[`** برای زیرمجموعه‌سازی بردارها و دیتافریم‌ها، که پایه بسیاری از عملیات tidyverse است.

- **`[[` و `$`** برای استخراج عناصر واحد از لیست‌ها و دیتافریم‌ها، که برای کار با داده‌های سلسله‌مراتبی ضروری هستند.

- **خانواده apply** که شامل `lapply()`، `sapply()` و `vapply()` است، که الهام‌بخش توابع `map()` در purrr بودند.

- **حلقه‌های `for`** که یک راه انعطاف‌پذیر برای تکرار هستند، اگرچه معمولاً functionals واضح‌تر هستند.

- **توابع نمودارسازی base R** مانند `plot()` و `hist()` که جایگزین سریع‌تر ggplot2 هستند.

دانستن این ابزارهای base R به شما کمک می‌کند کد R نوشته شده توسط دیگران را بخوانید و درک کنید، و همچنین به شما مجموعه ابزارهای بیشتری برای حل مسائل می‌دهد. با این حال، برای بیشتر کارها، ما همچنان توصیه می‌کنیم از tidyverse استفاده کنید زیرا نحو سازگارتر و قابل پیش‌بینی‌تری دارد.

در فصل بعدی، به بخش جدیدی از کتاب می‌رویم: ارتباط. شما یاد خواهید گرفت چگونه نتایج تحلیل خود را با استفاده از R Markdown و Quarto به طور مؤثر منتقل کنید.
