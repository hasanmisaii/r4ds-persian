# ۷ وارد کردن داده‌ها

## مقدمه

کار با داده‌هایی که در خود R آماده شده‌اند، روش عالی برای یادگیری ابزارهای علم داده است، اما در نهایت می‌خواهید کار تحلیل خودتان را متوقف کرده و شروع به کار با داده‌های خودتان کنید. در این فصل، نحوه خواندن فایل‌های متنی ساده به R را خواهید آموخت. این فصل تنها سطح واردکردن داده‌ها را در نظر می‌گیرد، اما بسیاری از اصول مورد بحث برای سایر اشکال داده نیز اعمال می‌شود.

### پیش‌نیازها

در این فصل، با readr کار خواهید کرد که بخشی از tidyverse اصلی است.

```{r}
#| label: setup
#| message: false
library(tidyverse)
```

## خواندن داده‌ها از یک فایل

برای شروع، بیایید بر روی رایج‌ترین شکل ذخیره‌سازی داده مستطیلی: csv متمرکز شویم. در اینجا یک فایل csv ساده است. سطر اول، که معمولاً header نامیده می‌شود، نام ستون‌ها را ارائه می‌دهد، و شش سطر بعدی داده‌ها را ارائه می‌دهند. ستون‌ها با کاما از هم جدا شده‌اند.

```
a,b,c
1,2,3
4,5,6
```

می‌توانید این فایل را با `read_csv()` بخوانید. اولین آرگومان مهم‌ترین آرگومان است: مسیر فایل.

```{r}
#| eval: false
students <- read_csv("students.csv")
```

هنگامی که `read_csv()` را اجرا می‌کنید، ستونی از اطلاعات در مورد ستون spec چاپ می‌کند: نام هر ستون و نوعش. این یک بخش مهم از readr است که بعداً به آن برمی‌گردیم.

همچنین می‌توانید مستقیماً یک رشته csv را با `read_csv()` عرضه کنید. این برای آزمایش کردن و ایجاد نمونه‌های قابل تکرار برای به اشتراک گذاری با دیگران مفید است:

```{r}
read_csv(
  "a,b,c
  1,2,3
  4,5,6"
)
```

## مثال‌های عملی

دو فایل csv که در adv-r موجود هستند:

```{r}
students <- read_csv("data/students.csv")
students
```

توجه کنید که `read_csv()` از ستون اول به عنوان نام ستون استفاده می‌کند، که در این مورد `Student ID` است. این مطلوب نیست زیرا فضا در نام متغیر باعث کار با آن مشکل می‌شود. می‌توانیم آن را با `janitor::clean_names()` تمیز کنیم تا نام‌های ستون‌ها را به snake_case تبدیل کنیم:

```{r}
students |> janitor::clean_names()
```

یک مشکل دیگر این است که وظیفه `Favourite Food` ستون `AGE` را نادیده گرفته است. این به این دلیل است که اگر یک مقدار موجود نباشد، readr با `NA` جایگزین می‌کند:

```{r}
students <- read_csv("data/students.csv", na = c("N/A", ""))
students
```

اکنون مقادیر گمشده در بین داده‌ها به درستی کدگذاری شده‌اند.

## انواع ستون‌ها

readr از هیوریستیک برای تشخیص نوع هر ستون استفاده می‌کند: اولین ۱۰۰۰ سطر را می‌خواند و از نتایج برای تخمین نوع هر ستون استفاده می‌کند. می‌توانید با `spec()` نوع ستون‌ها را شبیه‌سازی کنید:

```{r}
read_csv("data/students.csv") |> spec()
```

## شناسایی مشکلات

انواع ستون‌های تخمین زده شده همیشه درست نیستند. یکی از دلایل رایج که readr نوع ستون را اشتباه تشخیص می‌دهد، وجود یک مقدار غیرمنتظره است که باعث می‌شود readr یک نوع کلی‌تر را انتخاب کند. برای نشان دادن این مشکل، در اینجا فایل csv ساده‌ای است که یک مقدار غیرمنتظره در آخرین سطر دارد:

```{r}
simple_csv <- "
  x
  10
  .
  20
  30"
```

```{r}
df <- read_csv(simple_csv)
```

اینجا readr نوع `x` را character تشخیص می‌دهد زیرا تنها مقدار non-numeric "." است. می‌توانید مشکل را با `problems()` بیابید:

```{r}
problems(df)
```

(این البته داده‌های تولیدی هستند اما می‌توانید همین نوع مشکل را با داده‌های واقعی ببینید.)

## تنظیم انواع ستون‌ها

می‌توانید نوع ستون‌ها را با آرگومان `col_types` لغو کنید. مثلاً:

```{r}
df <- read_csv(simple_csv, col_types = list(x = col_double()))
```

اکنون مقدار "." با `NA` جایگزین می‌شود:

```{r}
df
```

اگر مقادیر زیادی با مشکل مواجه شده‌اند، بهتر است آن‌ها را character بخوانید و سپس از dplyr برای تمیز کردن آن‌ها استفاده کنید.

## سایر فرمت‌های فایل

هنگامی که بتوانید به راحتی CSV را بخوانید، استفاده از سایر توابع readr آسان است زیرا همگی کار می‌کنند. عمومی‌ترین فرمت‌ها:

* `read_csv2()`: فایل‌هایی را می‌خواند که از نقطه‌ویرگول برای جدا کردن فیلدها استفاده می‌کنند. اینها در کشورهایی که از `,` به عنوان نشانگر اعشار استفاده می‌کنند رایج هستند.

* `read_tsv()`: فایل‌هایی را می‌خواند که از tab برای جدا کردن فیلدها استفاده می‌کنند.

* `read_delim()`: فایل‌هایی را می‌خواند که از هر delimiter استفاده می‌کنند.

* `read_fwf()`: فایل‌های با عرض ثابت را می‌خواند.

* `read_table()`: متغیری از `read_fwf()` که می‌تواند فایل‌هایی را بخواند که از white space برای جدا کردن ستون‌ها استفاده می‌کنند.

* `read_log()`: فایل‌های log Apache style را می‌خواند.

## نوشتن در فایل

readr همچنین با دو تابع مفید برای نوشتن داده‌ها به دیسک آمده است: `write_csv()` و `write_tsv()`. این دو تابع آرگومان‌های مشابهی دارند: `x` (data frame برای ذخیره) و `path` (مکان ذخیره).

```{r}
#| eval: false
write_csv(students, "students-2.csv")
```

حالا بیایید اطلاعات نوع ستون را بازیابی کنیم:

```{r}
#| eval: false
students
read_csv("students-2.csv")
```

این انگیزه‌ای است که ممکن است بخواهید از `write_rds()` و `read_rds()` استفاده کنید. اینها wrapperهایی برای توابع base `readRDS()` و `saveRDS()` هستند. این‌ها داده‌ها را در فرمت باینری RDS ذخیره می‌کنند:

```{r}
#| eval: false
write_rds(students, "students.rds")
read_rds("students.rds")
```

## فرمت‌های دیگر

برای شروع کار با فرمت‌های دیگر، ما بسته‌های زیر را توصیه می‌کنیم:

* **haven**: فایل‌های SPSS، Stata و SAS را می‌خواند.

* **DBI**: همراه با پایگاه داده‌های مخصوص بسته (مثل **RMySQL**، **RSQLite**، **RPostgreSQL** و غیره) به شما اجازه اجرای queries SQL روی پایگاه داده و بازگشت data frame می‌دهد.

برای داده‌های سلسله مراتبی: از **jsonlite** (توسط Jeroen Ooms) برای JSON، و **xml2** برای XML استفاده کنید. Jenny Bryan چند نمونه عالی از استفاده از jsonlite برای کار با JSON APIs در <https://github.com/jennybc/repurrrsive> ارائه داده است.

* برای فایل‌های Excel: **readxl**.

* برای Google Sheets: **googlesheets4**.

برای سایر انواع فایل، سعی کنید [R data import/export manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html) و بسته [**rio**](https://github.com/leeper/rio) را بررسی کنید.

## خلاصه

در این فصل، مبانی واردکردن داده‌ها به R را یاد گرفتید. شروع با فایل‌های CSV ساده کردید، سپس نحوه حل مشکلات رایج parsing، نحوه شناسایی مشکلات، و نحوه تنظیم دستی انواع ستون‌ها را یاد گرفتید. در نهایت، یک نمای کلی از برخی دیگر از فرمت‌های داده‌ای که ممکن است با آن‌ها مواجه شوید و بسته‌هایی که برای بارگذاری آن‌ها مفید هستند، بدست آوردید.

دادیدن داده‌ها تنها اولین قدم است. هنگامی که داده‌هایتان را داخل R آوردید، اکثراً نیاز به تمیز کردن آن‌ها خواهید داشت تا آن‌ها را برای تجزیه و تحلیل آماده کنید. در فصل بعد، نحوه استفاده از tidyr برای تمیز کردن داده‌ها را خواهید آموخت.
