# درس ۲: تکرار (Iteration)

## ۱.۲۶ مقدمه

در فصل توابع، با یک مثال برای کاهش تکرار کد شروع کردیم:

```{r}
df |> mutate(
  a = (a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),
  b = (b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE)),
  c = (c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),
  d = (d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),
)
```

شما یاد گرفتید که چگونه با استفاده از یک تابع این تکرار را کاهش دهید:

```{r}
rescale01 <- function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}

df |> mutate(
  a = rescale01(a),
  b = rescale01(b),
  c = rescale01(c),
  d = rescale01(d),
)
```

توابع به شما اجازه می‌دهند تا منطق خود را ساده کنید، اما هنوز تکرار زیادی وجود دارد. شما چهار بار `rescale01()` را فراخوانی می‌کنید. تکرار عالی است زیرا به شما امکان می‌دهد هدف خود را واضح کنید: ما می‌خواهیم همان عملیات را روی `a`، `b`، `c` و `d` انجام دهیم. با این حال، تکرار هنوز هم مشکل دارد: اگر می‌خواهیم تعداد زیادی ستون را مجدداً مقیاس‌بندی کنیم، چه؟ یا اگر بخواهیم عملیات متفاوتی انجام دهیم؟

در این فصل، یاد خواهید گرفت که از ابزارهای تکرار استفاده کنید که در tidyverse وجود دارند: ابزارهایی که به شما امکان می‌دهند تا همان عملیات را روی چندین ستون انجام دهید. ما با توابعی شروع می‌کنیم که عملیات متداول برای گروه‌بندی داده‌ها را انجام می‌دهند: `across()` که اجازه می‌دهد همان تحول را روی چندین ستون انجام دهید، و `pick()` که به شما امکان می‌دهد چندین ستون را برای استفاده در یک تابع انتخاب کنید. سپس به تابع `map()` می‌پردازیم که به شما اجازه می‌دهد تا یک تابع را برای هر عنصر از یک بردار اعمال کنید.

### ۱.۱.۲۶ پیش‌نیازها

در این فصل، ما به توابعی تمرکز خواهیم کرد که از پکیج purrr هستند، که بخشی از tidyverse است.

```{r}
library(tidyverse)
```

## ۲.۲۶ ستون‌های چندگانه را با `across()` تغییر دهید

تصور کنید که داده‌های پروازهای nycflights13 را داریم و می‌خواهیم میانگین تأخیر را برای هر ماه محاسبه کنیم. می‌توانید این کد را بنویسید:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    dep_delay = mean(dep_delay, na.rm = TRUE),
    arr_delay = mean(arr_delay, na.rm = TRUE),
    .groups = "drop"
  )
```

اما این کد تکراری است زیرا `mean()` را دو بار فراخوانی می‌کند. ممکن است فکر کنید که می‌توانید از `c()` استفاده کنید تا همانطور که در `select()` استفاده می‌کنید ستون‌ها را گروه‌بندی کنید:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    mean(c(dep_delay, arr_delay), na.rm = TRUE),
    .groups = "drop"
  )
```

اما این کار نمی‌کند! چون در اینجا `c(dep_delay, arr_delay)` همه مقادیر را به یک بردار بلند ترکیب می‌کند و میانگین آن را محاسبه می‌کند.

به جای آن، نیاز به ابزار جدیدی داریم: `across()`. `across()` سه آرگومان اصلی دارد:

1. `.cols` مشخص می‌کند که کدام ستون‌ها را می‌خواهید روی آنها عمل کنید. از همان مشخصات مانند `select()` استفاده می‌کند.
2. `.fns` تعریف می‌کند که با هر ستون چه کاری انجام دهید. این تابعی است که روی هر ستون اعمال می‌شود.
3. `.names` نحوه نام‌گذاری ستون‌های خروجی را کنترل می‌کند. ما به این موضوع در یک لحظه خواهیم پرداخت.

می‌توانیم از `across()` برای محاسبه میانگین هر دو متغیر تأخیر استفاده کنیم:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    across(c(dep_delay, arr_delay), mean, na.rm = TRUE),
    .groups = "drop"
  )
```

`across()` به ویژه زمانی مفید است که می‌خواهید همان عملیات را روی چندین ستون انجام دهید. به عنوان مثال، ما می‌توانیم `across()` را با `where()` ترکیب کنیم تا میانگین هر ستون عددی را محاسبه کنیم:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    across(where(is.numeric), mean, na.rm = TRUE),
    .groups = "drop"
  )
```

### ۱.۲.۲۶ انتخاب ستون‌ها با `.cols`

آرگومان اول `across()`، `.cols`، مشخص می‌کند که کدام ستون‌ها را می‌خواهید تبدیل کنید. این از همان مینی-زبانی استفاده می‌کند که `select()` استفاده می‌کند، بنابراین می‌توانید از توابع مانند `starts_with()` و `ends_with()` برای انتخاب ستون‌ها بر اساس نام آنها استفاده کنید.

دو تکنیک انتخاب مهم وجود دارد که بخصوص با `across()` مفید هستند:

- `everything()`: هر ستون را انتخاب می‌کند.
- `where()`: ستون‌هایی را انتخاب می‌کند که تابع پیش‌گویی برای آنها `TRUE` برمی‌گرداند. برای مثال، `where(is.numeric)` تمام ستون‌های عددی را انتخاب می‌کند.

همچنین می‌توانید از `-` برای حذف متغیرها استفاده کنید. به عنوان مثال، ما می‌توانیم میانگین همه ستون‌های عددی را محاسبه کنیم به جز سال، ماه و روز:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    across(where(is.numeric) & !c(year, month, day), mean, na.rm = TRUE),
    .groups = "drop"
  )
```

### ۲.۲.۲۶ فراخوانی یک تابع با `.fns`

آرگومان دوم `across()` تابعی است که می‌خواهید روی هر ستون اعمال کنید. این تابع به بدون پرانتز نوشته می‌شود. به عنوان مثال:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    across(c(dep_delay, arr_delay), mean, na.rm = TRUE),
    .groups = "drop"
  )
```

توجه کنید که نمی‌نویسیم `mean()` - می‌نویسیم فقط `mean`. این به این دلیل است که `across()` تابع را برای ما فراخوانی می‌کند. هر آرگومان اضافی که به `across()` می‌دهید، به تابع منتقل می‌شود. در مثال بالا، `na.rm = TRUE` به `mean()` منتقل می‌شود.

گاهی اوقات ممکن است بخواهید عملیات پیچیده‌تری انجام دهید که به یک تابع ساده نمی‌توان خلاصه کرد. در آن صورت، می‌توانید از تابع ناشناس استفاده کنید:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    across(c(dep_delay, arr_delay), \(x) mean(x, na.rm = TRUE)),
    .groups = "drop"
  )
```

یا اگر می‌خواهید چندین تابع اعمال کنید، می‌توانید یک لیست نامگذاری شده ارائه دهید:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    across(
      c(dep_delay, arr_delay), 
      list(mean = \(x) mean(x, na.rm = TRUE), 
           median = \(x) median(x, na.rm = TRUE))
    ),
    .groups = "drop"
  )
```

### ۳.۲.۲۶ نام‌های ستون با `.names`

خروجی `across()` نام‌گذاری شده به همان نام ستون‌های ورودی است. این می‌تواند برای `mutate()` خوب باشد، اما برای `summarize()` مشکل‌ساز است، زیرا ما می‌خواهیم نام‌های متفاوتی داشته باشیم. به عنوان مثال، اگر از `list()` برای اعمال چندین تابع استفاده می‌کنید، نام ستون‌های خروجی به شکل `ستون_نام_تابع` خواهد بود:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    across(
      c(dep_delay, arr_delay), 
      list(mean = \(x) mean(x, na.rm = TRUE), 
           median = \(x) median(x, na.rm = TRUE)),
      .names = "{.col}_{.fn}"
    ),
    .groups = "drop"
  )
```

`{.col}` با نام ستون جایگزین می‌شود و `{.fn}` با نام تابع جایگزین می‌شود.

### ۴.۲.۲۶ فیلتر کردن

`across()` در `filter()` نیز بسیار مفید است. به عنوان مثال، برای یافتن تمام پروازهایی که برای آنها هیچ تاخیری ثبت نشده است، می‌توانیم بنویسیم:

```{r}
flights |> 
  filter(across(c(dep_delay, arr_delay), \(x) !is.na(x)))
```

یا برای یافتن تمام مسیرهایی که در ژانویه پرواز کرده‌اند:

```{r}
flights |> 
  filter(across(starts_with("arr_"), \(x) !is.na(x))) |> 
  select(starts_with("arr_"))
```

### ۵.۲.۲۶ استفاده از `across()` در توابع

`across()` می‌تواند در توابع کمک‌کننده‌ای که می‌نویسید نیز مفید باشد. به عنوان مثال، تصور کنید که می‌خواهیم تابعی بنویسید که میانگین یک مجموعه از ستون‌ها را محاسبه کند:

```{r}
summarize_means <- function(df, vars) {
  df |> 
    summarize(across({{ vars }}, \(x) mean(x, na.rm = TRUE)))
}

flights |> 
  group_by(year, month, day) |> 
  summarize_means(c(dep_delay, arr_delay))
```

### ۶.۲.۲۶ در مقابل `pivot_longer()`

ممکن است تعجب کنید که `across()` چگونه با `pivot_longer()` مرتبط است. آنها مشابه هستند اما کاربردهای مختلفی دارند:

- استفاده از `across()` زمانی است که می‌خواهید همان محاسبات را روی چندین ستون انجام دهید اما نتایج را در ستون‌های جداگانه نگه دارید.
- استفاده از `pivot_longer()` زمانی است که می‌خواهید چندین ستون را به یک ستون بلند تبدیل کنید، که به شما امکان می‌دهد در آینده ستون را گروه‌بندی یا فیلتر کنید.

### ۷.۲.۲۶ تمرین‌ها

1. چگونه می‌توانید از `across()` برای محاسبه تعداد مقادیر گمشده در هر ستون عددی استفاده کنید؟

2. چگونه می‌توانید برای محاسبه میانگین و انحراف معیار برای هر ستون عددی استفاده کنید؟

## ۳.۲۶ خواندن چندین فایل

در بخش قبلی، یاد گرفتید چگونه از `across()` برای تکرار روی ستون‌های یک دیتافریم استفاده کنید. در این بخش، خواهید دید چگونه از `map()` از پکیج purrr برای انجام عملیات روی چندین فایل استفاده کنید.

مشکل رایج این است که چندین فایل دارید که می‌خواهید آنها را بخوانید و در یک دیتافریم واحد ترکیب کنید. برای مثال، ممکن است پوشه‌ای داشته باشید که حاوی فایل‌های CSV برای هر ماه است:

```
data/
  sales-01.csv
  sales-02.csv
  sales-03.csv
  ...
  sales-12.csv
```

می‌خواهیم آنها را بخوانیم و در یک دیتافریم واحد ترکیب کنیم. بیایید با ساخت این پوشه و فایل‌ها شروع کنیم:

```{r}
paths <- list.files("data", pattern = "[.]csv$", full.names = TRUE)
paths
```

حالا می‌توانیم از `map()` برای خواندن هر یک از این فایل‌ها به یک لیست استفاده کنیم:

```{r}
files <- map(paths, read_csv)
```

سپس می‌توانیم از `list_rbind()` برای ترکیب آن لیست از دیتافریم‌ها به یک دیتافریم واحد استفاده کنیم:

```{r}
list_rbind(files)
```

یا می‌توانیم این دو مرحله را در یک خط pipe ترکیب کنیم:

```{r}
paths |> 
  map(read_csv) |> 
  list_rbind()
```

این الگو بسیار قدرتمند است! اگر می‌توانید برای یک فایل کاری انجام دهید، می‌توانید با `map()` و `list_rbind()` برای هر فایل انجام دهید.

### ۱.۳.۲۶ لیست‌ها

قبل از اینکه بیشتر درباره `map()` یاد بگیریم، باید کمی در مورد لیست‌ها صحبت کنیم. لیست‌ها ساختار داده‌ای در R هستند که می‌توانند هر نوع دیگری از داده را در خود داشته باشند، از جمله لیست‌های دیگر!

لیست‌ها را با `list()` می‌سازید:

```{r}
x <- list(1, 2, 3)
x
```

می‌توانید عناصر لیست را نام‌گذاری کنید:

```{r}
x <- list(a = 1, b = 2, c = 3)
x
```

برای استخراج عناصر از یک لیست، می‌توانید از `[[` استفاده کنید:

```{r}
x[[1]]
x[["a"]]
```

همچنین می‌توانید از `$` برای استخراج عناصر نامگذاری شده استفاده کنید:

```{r}
x$a
```

### ۲.۳.۲۶ پایه‌های `map()`

`map()` تابعی است که یک لیست (یا بردار) و یک تابع را می‌گیرد، و تابع را برای هر عنصر از لیست اعمال می‌کند:

```{r}
map(x, \(x) x * 2)
```

`map()` همیشه یک لیست را برمی‌گرداند، حتی اگر همه عناصر خروجی از نوع یکسانی باشند. اگر می‌دانید خروجی از نوع خاصی است، می‌توانید از یکی از انواع `map()` استفاده کنید که بردار برمی‌گرداند:

- `map_int()` یک بردار عدد صحیح برمی‌گرداند.
- `map_dbl()` یک بردار اعشاری برمی‌گرداند.
- `map_chr()` یک بردار کاراکتری برمی‌گرداند.
- `map_lgl()` یک بردار منطقی برمی‌گرداند.

برای مثال:

```{r}
map_dbl(x, \(x) x * 2)
```

### ۳.۳.۲۶ نام گذاری

اگر لیست شما نامگذاری شده است، `map()` اسامی را حفظ می‌کند:

```{r}
map_dbl(x, \(x) x * 2)
```

این ویژگی بخصوص زمانی مفید است که با چندین فایل کار می‌کنید - می‌توانید از `set_names()` برای نام‌گذاری عناصر بر اساس نام فایل استفاده کنید:

```{r}
paths |> 
  set_names(basename) |> 
  map(read_csv) |> 
  list_rbind(names_to = "file")
```

### ۴.۳.۲۶ آرگومان‌های اضافی

گاهی اوقات، می‌خواهید آرگومان‌های اضافی را به تابع منتقل کنید. برای مثال، اگر می‌خواهید به `read_csv()` بگویید که ستون‌ها را چگونه تجزیه کند:

```{r}
paths |> 
  map(read_csv, col_types = cols(.default = "c")) |> 
  list_rbind()
```

همه آرگومان‌هایی که به `map()` بعد از تابع می‌دهید، به آن تابع منتقل می‌شوند.

### ۵.۳.۲۶ تکرار روی دو ورودی با `map2()`

گاهی اوقات می‌خواهید روی دو ورودی به طور موازی تکرار کنید. برای مثال، تصور کنید که می‌خواهید چندین شبیه‌سازی انجام دهید، و نمونه‌های مختلف ایجاد کنید. می‌توانید از `map2()` استفاده کنید:

```{r}
means <- c(1, 2, 3)
sds <- c(0.1, 0.2, 0.3)

map2(means, sds, rnorm, n = 10)
```

`map2()` مانند `map()` است، اما دو لیست می‌گیرد و تابع را با عناصر متناظر از هر لیست فراخوانی می‌کند.

### ۶.۳.۲۶ تکرار بدون خروجی با `walk()`

گاهی اوقات، می‌خواهید یک تابع را برای اثرات جانبی آن فراخوانی کنید (مانند ذخیره فایل یا رسم نمودار)، نه برای مقدار بازگشتی آن. در این موارد، استفاده از `walk()` بهتر از `map()` است، زیرا ورودی اصلی را برمی‌گرداند (به طور نامرئی)، که pipe را بهتر می‌کند:

```{r}
paths |> 
  map(read_csv) |> 
  walk(write_csv, file = "combined.csv")
```

همچنین `walk2()` وجود دارد که مشابه `map2()` است.

### ۷.۳.۲۶ پیش‌گویی‌ها

تابع‌های متعدد در purrr از پیش‌گویی‌ها استفاده می‌کنند: توابعی که `TRUE` یا `FALSE` برمی‌گردانند. به عنوان مثال:

- `keep()` عناصری را حفظ می‌کند که پیش‌گویی `TRUE` است.
- `discard()` عناصری را حذف می‌کند که پیش‌گویی `TRUE` است.
- `some()` بررسی می‌کند که آیا حداقل یک عنصر پیش‌گویی را برآورده می‌کند.
- `every()` بررسی می‌کند که آیا همه عناصر پیش‌گویی را برآورده می‌کنند.

برای مثال:

```{r}
x <- list(1, "a", 3, "b", 5)
keep(x, is.numeric)
discard(x, is.numeric)
```

### ۸.۳.۲۶ تمرین‌ها

1. چگونه می‌توانید از `map()` برای محاسبه میانگین هر ستون در یک دیتافریم استفاده کنید؟

2. چگونه می‌توانید از `map2()` برای ساخت چندین نمودار استفاده کنید؟

## ۴.۲۶ حلقه‌های for

توابع `map()` به زبان R تعلق دارند و شیوه تابعی برنامه‌نویسی را ترویج می‌دهند. با این حال، R همچنین از حلقه‌های `for` پشتیبانی می‌کند، که رایج‌ترین راه برای تکرار در بسیاری از زبان‌های برنامه‌نویسی هستند.

ساختار کلی یک حلقه `for` این است:

```{r}
for (item in vector) {
  # کد برای اجرا
}
```

برای مثال:

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

output <- vector("double", ncol(df))
for (i in seq_along(df)) {
  output[[i]] <- mean(df[[i]])
}
output
```

چهار جزء برای هر حلقه `for` وجود دارد:

1. **خروجی**: قبل از شروع حلقه، باید فضایی برای خروجی اختصاص دهید. این امر برای عملکرد مهم است.

2. **توالی**: `i in seq_along(df)` تعیین می‌کند که روی چه چیزی حلقه بزنیم.

3. **بدنه**: `output[[i]] <- mean(df[[i]])` این کاری است که می‌خواهیم برای هر عنصر انجام دهیم.

### ۱.۴.۲۶ چه زمانی از حلقه‌های `for` استفاده کنیم

حلقه‌های `for` کمتر رایج در R نسبت به برخی زبان‌های دیگر هستند زیرا R یک زبان برنامه‌نویسی تابعی است و توابع `map()` اغلب راه‌حل واضح‌تر و مختصرتری را ارائه می‌دهند.

با این حال، حلقه‌های `for` هنوز مواقعی مفید هستند:

- زمانی که نمی‌توانید مسئله را به راحتی به صورت تابعی بیان کنید.
- زمانی که کد پیچیده‌تر و خواندن آن سخت‌تر است.
- زمانی که هر تکرار به نتیجه تکرار قبلی بستگی دارد.

### ۲.۴.۲۶ مقایسه با `map()`

بیایید مثال بالا را با استفاده از `map()` مقایسه کنیم:

```{r}
df |> 
  map_dbl(mean)
```

این بسیار مختصرتر است! علاوه بر آن، `map_dbl()` خطاهای بهتری ارائه می‌دهد - اگر خروجی تابع اعداد اعشاری نباشد، خطایی دریافت می‌کنید.

### ۳.۴.۲۶ تمرین‌ها

1. یک حلقه `for` بنویسید که میانگین هر ستون عددی در `flights` را محاسبه کند.

2. همان کار را با `map()` انجام دهید.

## ۵.۲۶ خلاصه

در این فصل، یاد گرفتید درباره ابزارهای تکرار در R. شما یاد گرفتید:

- چگونه از `across()` برای تکرار روی ستون‌ها در یک دیتافریم استفاده کنید.
- چگونه از `map()` برای تکرار روی عناصر یک لیست استفاده کنید.
- چگونه چندین فایل را بخوانید و آنها را ترکیب کنید.
- چه زمانی از حلقه‌های `for` استفاده کنید.

این ابزارها به شما کمک می‌کنند تا کد تکراری را کاهش دهید و تحلیل‌های خود را قابل نگهداری‌تر کنید. همیشه به دنبال الگوها در کد خود باشید - اگر چیزی را بیش از دو بار کپی و پیست می‌کنید، احتمالاً زمان آن است که یک تابع بنویسید یا از ابزار تکرار استفاده کنید!

در فصل بعدی، درباره یک موضوع مرتبط خواهید آموخت: چگونه بردارها و لیست‌ها در R کار می‌کنند، و چگونه می‌توانید آنها را به طور مؤثرتر استفاده کنید.
