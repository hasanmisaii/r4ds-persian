# ۱۳ اعداد

## ۱.۱۳ مقدمه

بردارهای عددی ستون فقرات علم داده هستند و شما قبلاً در فصل‌های قبلی کتاب چندین بار از آن‌ها استفاده کرده‌اید. حالا وقت آن است که به طور سیستماتیک بررسی کنیم که چه کارهایی می‌توانید با آن‌ها در R انجام دهید، تا مطمئن شوید که برای رویارویی با هر مسئله آینده‌ای که شامل بردارهای عددی است، آماده هستید.

ما با ارائه چند ابزار برای ساخت اعداد شروع می‌کنیم، در صورتی که رشته‌ها داشته باشید، و سپس به جزئیات بیشتری از `count()` می‌پردازیم. سپس به تبدیلات عددی مختلفی می‌پردازیم که با `mutate()` به خوبی کار می‌کنند، از جمله تبدیلات کلی‌تر که می‌توانند به انواع دیگر بردارها اعمال شوند، اما اغلب با بردارهای عددی استفاده می‌شوند. در پایان، توابع خلاصه‌سازی را پوشش می‌دهیم که با `summarize()` به خوبی کار می‌کنند و نشان می‌دهیم که چگونه می‌توانند با `mutate()` نیز استفاده شوند.

### ۱.۱.۱۳ پیش‌نیازها

این فصل عمدتاً از توابع R پایه استفاده می‌کند که بدون بارگذاری هیچ بسته‌ای در دسترس هستند. اما ما هنوز به tidyverse نیاز داریم زیرا از این توابع R پایه در داخل توابع tidyverse مانند `mutate()` و `filter()` استفاده خواهیم کرد. مانند فصل قبل، از نمونه‌های واقعی nycflights13، و همچنین مثال‌های ساختگی ساخته شده با `c()` و `tribble()` استفاده خواهیم کرد.

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(nycflights13)
```

## ۲.۱۳ ساخت اعداد

در بیشتر موارد، اعداد را از قبل در یکی از انواع عددی R ثبت شده دریافت خواهید کرد: integer یا double. با این حال، در برخی موارد، ممکن است با آن‌ها به عنوان رشته مواجه شوید، احتمالاً به این دلیل که آن‌ها را با چرخاندن از سرستون‌ها ایجاد کرده‌اید یا به دلیل مشکلی در فرآیند واردکردن داده‌هایتان.

readr دو تابع مفید برای تجزیه رشته‌ها به اعداد ارائه می‌دهد: `parse_double()` و `parse_number()`. از `parse_double()` زمانی استفاده کنید که اعدادی دارید که به عنوان رشته نوشته شده‌اند:

```{r}
x <- c("1.2", "5.6", "1e3")
parse_double(x)
#> [1]    1.2    5.6 1000.0
```

از `parse_number()` زمانی استفاده کنید که رشته حاوی متن غیرعددی است که می‌خواهید نادیده بگیرید. این به ویژه برای داده‌های ارزی و درصدها مفید است:

```{r}
x <- c("$1,234", "USD 3,513", "59%")
parse_number(x)
#> [1] 1234 3513   59
```

## ۳.۱۳ شمارش‌ها

شگفت‌آور است که چقدر علم داده می‌توانید فقط با شمارش‌ها و کمی حساب ساده انجام دهید، بنابراین dplyr تلاش می‌کند شمارش را تا حد امکان با `count()` آسان کند. این تابع برای اکتشاف سریع و بررسی‌های حین تحلیل عالی است:

```{r}
flights |> 
  count(dest)
#> # A tibble: 105 × 2
#>   dest      n
#>   <chr> <int>
#> 1 ABQ     254
#> 2 ACK     265
#> 3 ALB     439
#> 4 ANC       8
#> 5 ATL   17215
#> 6 AUS    2439
#> # ℹ 99 more rows
```

(علی‌رغم توصیه در فصل ۴، ما معمولاً `count()` را در یک خط قرار می‌دهیم زیرا معمولاً در کنسول برای بررسی سریع اینکه آیا یک محاسبه همان‌طور که انتظار می‌رود کار می‌کند، استفاده می‌شود.)

اگر می‌خواهید رایج‌ترین مقادیر را ببینید، `sort = TRUE` اضافه کنید:

```{r}
flights |> 
  count(dest, sort = TRUE)
#> # A tibble: 105 × 2
#>   dest      n
#>   <chr> <int>
#> 1 ORD   17283
#> 2 ATL   17215
#> 3 LAX   16174
#> 4 BOS   15508
#> 5 MCO   14082
#> 6 CLT   14064
#> # ℹ 99 more rows
```

و به یاد داشته باشید که اگر می‌خواهید تمام مقادیر را ببینید، می‌توانید از `|> View()` یا `|> print(n = Inf)` استفاده کنید.

می‌توانید همین محاسبه را "به صورت دستی" با `group_by()`، `summarize()` و `n()` انجام دهید. این کار مفید است زیرا به شما اجازه می‌دهد در همان زمان خلاصه‌های دیگری را نیز محاسبه کنید:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(
    n = n(),
    delay = mean(arr_delay, na.rm = TRUE)
  )
#> # A tibble: 105 × 3
#>   dest      n delay
#>   <chr> <int> <dbl>
#> 1 ABQ     254  4.38
#> 2 ACK     265  4.85
#> 3 ALB     439 14.4 
#> 4 ANC       8 -2.5 
#> 5 ATL   17215 11.3 
#> 6 AUS    2439  6.02
#> # ℹ 99 more rows
```

`n()` یک تابع خلاصه‌ساز ویژه است که هیچ آرگومانی نمی‌گیرد و در عوض به اطلاعاتی درباره گروه "جاری" دسترسی دارد. این بدان معناست که فقط در داخل فعل‌های dplyr کار می‌کند:

```{r}
n()
#> Error in `n()`:
#> ! Must only be used inside data-masking verbs like `mutate()`,
#>   `filter()`, and `group_by()`.
```

چند نسخه از `n()` و `count()` وجود دارند که ممکن است مفید بیابید:

- `n_distinct(x)` تعداد مقادیر متمایز (منحصر به فرد) یک یا چند متغیر را می‌شمارد. به عنوان مثال، می‌توانیم بفهمیم کدام مقاصد توسط بیشترین شرکت‌های هواپیمایی سرویس داده می‌شوند:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(carriers = n_distinct(carrier)) |> 
  arrange(desc(carriers))
#> # A tibble: 105 × 2
#>   dest  carriers
#>   <chr>    <int>
#> 1 ATL          7
#> 2 BOS          7
#> 3 CLT          7
#> 4 ORD          7
#> 5 TPA          7
#> 6 AUS          6
#> # ℹ 99 more rows
```

- شمارش وزنی یک جمع است. به عنوان مثال می‌توانید تعداد مایل‌هایی که هر هواپیما پرواز کرده را "بشمارید":

```{r}
flights |> 
  group_by(tailnum) |> 
  summarize(miles = sum(distance))
#> # A tibble: 4,044 × 2
#>   tailnum  miles
#>   <chr>    <dbl>
#> 1 D942DN    3418
#> 2 N0EGMQ  250866
#> 3 N10156  115966
#> 4 N102UW   25722
#> 5 N103US   24619
#> 6 N104UW   25157
#> # ℹ 4,038 more rows
```

شمارش‌های وزنی یک مسئله رایج هستند بنابراین `count()` یک آرگومان `wt` دارد که همان کار را انجام می‌دهد:

```{r}
flights |> 
  count(tailnum, wt = distance)
```

- می‌توانید مقادیر گمشده را با ترکیب `sum()` و `is.na()` بشمارید. در مجموعه داده پروازها، این نشان می‌دهد که چند پرواز لغو شده‌اند:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(n_cancelled = sum(is.na(dep_time)))
#> # A tibble: 105 × 2
#>   dest  n_cancelled
#>   <chr>       <int>
#> 1 ABQ             0
#> 2 ACK             0
#> 3 ALB            20
#> 4 ANC             0
#> 5 ATL           317
#> 6 AUS            21
#> # ℹ 99 more rows
```

### ۱.۳.۱۳ تمرینات

۱. چگونه می‌توانید از `count()` برای شمارش تعداد سطرهایی با یک مقدار گمشده برای یک متغیر معین استفاده کنید؟

۲. `prod()` را با `sum()` و `n()` گسترش دهید. `prod()` چه کاری انجام می‌دهد؟

## ۴.۱۳ تبدیلات عددی

توابع تبدیل زیادی برای کار با اعداد وجود دارند که بیشتر آن‌ها در R پایه موجودند. در اینجا نمونه‌ای از رایج‌ترین و مفیدترین آن‌ها آورده شده است.

### ۱.۴.۱۳ حساب و قوانین بازیافت

ما در فصل ۱ معرفی کوتاهی از عملگرهای حسابی داشتیم: `+`، `-`، `*`، `/` و `^`. این‌ها توسط R به عنوان توابع شناخته می‌شوند که به آن‌ها عملگرهای infix گفته می‌شود زیرا عملگر بین آرگومان‌ها قرار می‌گیرد. بیشتر توابع دیگر عملگرهای prefix هستند که نام تابع قبل از آرگومان‌ها می‌آید مثل `sum(1, 2)`. این دو شکل به خوبی از هم قابل تبدیل هستند و R به شما اجازه می‌دهد عملگرهای infix را به صورت توابع prefix بنویسید:

```{r}
1 + 2
#> [1] 3
`+`(1, 2)
#> [1] 3
```

### ۲.۴.۱۳ حداقل و حداکثر

توابع حساب عملیات اسکالر هستند: با دو اسکالر کار می‌کنند. این بدان معنی است که اگر بخواهید (به عنوان مثال) حداقل دو متغیر را بیابید، باید از تابع `pmin()` موازی استفاده کنید:

```{r}
df <- tribble(
  ~x, ~y,
  1,  3,
  5,  2,
  7, NA
)

df |> 
  mutate(
    min = pmin(x, y, na.rm = TRUE),
    max = pmax(x, y, na.rm = TRUE)
  )
#> # A tibble: 3 × 4
#>       x     y   min   max
#>   <dbl> <dbl> <dbl> <dbl>
#> 1     1     3     1     3
#> 2     5     2     2     5
#> 3     7    NA     7     7
```

توجه داشته باشید که اگر تنها یک رشته را جستجو می‌کنید، می‌توانید از توابع خلاصه `min()` و `max()` استفاده کنید.

### ۳.۴.۱۳ حساب مدولار

حساب مدولار نام رسمی ریاضیات صحیح است که در آن اعداد می‌چرخند. در R، `%/%` تقسیم صحیح را انجام می‌دهد و `%%` باقیمانده را محاسبه می‌کند:

```{r}
1:10 %/% 3
#>  [1] 0 0 1 1 1 2 2 2 3 3
1:10 %% 3
#>  [1] 1 2 0 1 2 0 1 2 0 1
```

حساب مدولار مفید است زیرا به شما اجازه می‌دهد اعداد صحیح را به قطعات تقسیم کنید. به عنوان مثال، در مجموعه داده پروازها، می‌توانید `sched_dep_time` را به `hour` و `minute` با حساب مدولار محاسبه کنید:

```{r}
flights |> 
  mutate(
    hour = sched_dep_time %/% 100,
    minute = sched_dep_time %% 100,
    .keep = "used"
  )
#> # A tibble: 336,776 × 3
#>   sched_dep_time  hour minute
#>            <int> <dbl>  <dbl>
#> 1            515     5     15
#> 2            529     5     29
#> 3            540     5     40
#> 4            545     5     45
#> 5            600     6      0
#> 6            558     5     58
#> # ℹ 336,770 more rows
```

### ۴.۴.۱۳ لگاریتم‌ها

لگاریتم‌ها تبدیل بسیار مفیدی هستند برای برخورد با داده‌هایی که در چند مرتبه بزرگی متغیر هستند و برای تبدیل روابط ضربی به روابط جمعی. همه چیزهای دیگر یکسان بودن، ما توصیه می‌کنیم از `log2()` یا `log10()` استفاده کنید. `log2()` تفسیر آسانی دارد: تفاوت ۱ در مقیاس لگ مطابق است با دوبرابر شدن در مقیاس اصلی و تفاوت -۱ مطابق است با نصف شدن؛ در حالی که `log10()` تفسیر آسانی دارد: تفاوت ۱ در مقیاس لگ مطابق است با ۱۰ برابر شدن و تفاوت -۱ مطابق است با ۱/۱۰ شدن.

`log()` لگاریتم طبیعی را محاسبه می‌کند، یعنی لگاریتم با پایه e. شما نباید از این تابع استفاده کنید مگر اینکه دلیل خاصی داشته باشید.

### ۵.۴.۱۳ گرد کردن

از `round(x)` برای گرد کردن یک عدد به نزدیک‌ترین عدد صحیح استفاده کنید:

```{r}
round(123.456)
#> [1] 123
```

می‌توانید تعداد رقم‌های اعشاری را با پارامتر دوم `digits` کنترل کنید. `round(x, digits)` به نزدیک‌ترین `10^-digits` گرد می‌کند، بنابراین `digits = 2` به نزدیک‌ترین ۰.۰۱ گرد می‌کند. این تعریف زمانی که `digits` منفی است مفید است، که به شما اجازه می‌دهد به نزدیک‌ترین ۱۰، ۱۰۰، ۱۰۰۰، و غیره گرد کنید:

```{r}
round(123.456, 2)  # دو رقم
#> [1] 123.46
round(123.456, 1)  # یک رقم
#> [1] 123.5
round(123.456, -1) # به نزدیک‌ترین ده
#> [1] 120
round(123.456, -2) # به نزدیک‌ترین صد
#> [1] 100
```

`round()` از چیزی به نام "گرد کردن به سمت جفت" یا "گرد کردن بانکی" استفاده می‌کند: اگر یک عدد در نیمه راه بین دو عدد صحیح باشد، به عدد صحیح **جفت** گرد خواهد شد. این یک استراتژی خوب است زیرا از سوگیری گرد کردن جلوگیری می‌کند: نیمی از همه ۰.۵ها به بالا گرد می‌شوند و نیمی به پایین:

```{r}
round(c(1.5, 2.5))
#> [1] 2 2
```

می‌توانید از `floor()` برای همیشه گرد کردن به سمت پایین یا `ceiling()` برای همیشه گرد کردن به سمت بالا استفاده کنید:

```{r}
x <- 123.456

floor(x)
#> [1] 123
ceiling(x)
#> [1] 124
```

این توابع نسخه‌هایی با پارامتر `digits` ندارند، بنابراین می‌توانید از این ترفند ساده استفاده کنید:

```{r}
# به سمت پایین به نزدیک‌ترین دو رقم اعشاری
floor(x * 100) / 100
#> [1] 123.45
# به سمت بالا به نزدیک‌ترین دو رقم اعشاری
ceiling(x * 100) / 100
#> [1] 123.46
```

می‌توانید از `round()` همراه با `mutate()` برای گرد کردن تمام ستون‌های عددی یک data frame استفاده کنید:

```{r}
# گرد کردن تمام ستون‌های عددی به نزدیک‌ترین عدد صحیح
flights |> 
  mutate(across(where(is.numeric), round))
```

### ۶.۴.۱۳ بریدن اعداد به محدوده‌ها

از `cut()` برای تقسیم (همچنین به نام bin) یک متغیر عددی به سطله‌های گسسته استفاده کنید:

```{r}
x <- c(1, 2, 5, 10, 15, 20)
cut(x, breaks = c(0, 5, 10, 15, 20))
#> [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] (15,20]
#> Levels: (0,5] (5,10] (10,15] (15,20]
```

نقاط شکست به طور پیش‌فرض چپ-باز و راست-بسته هستند. می‌توانید این را با آرگومان `right` تغییر دهید:

```{r}
cut(x, breaks = c(0, 5, 10, 100), right = FALSE)
#> [1] [0,5)   [0,5)   [5,10)  [10,100) [10,100) [10,100)
#> Levels: [0,5) [5,10) [10,100)
```

می‌توانید از `labels = FALSE` برای بازگرداندن یک عدد صحیح به جای یک factor استفاده کنید:

```{r}
cut(x, breaks = c(0, 5, 10, 15, 20), labels = FALSE)
#> [1] 1 1 1 2 3 4
```

### ۷.۴.۱۳ تجمع‌های تجمعی و لغزان

R پایه توابعی برای محاسبات دنباله‌ای (یا running) ارائه می‌دهد: `cumsum()`، `cumprod()`، `cummin()`، `cummax()` برای مجموع‌ها، حاصل‌ضرب‌ها، حداقل‌ها و حداکثر‌های تجمعی. dplyr کمک‌کننده‌های مفید `cummean()` برای میانگین‌های تجمعی ارائه می‌دهد. مجموع‌های تجمعی در برخورد با داده‌های زمانی رایج هستند:

```{r}
x <- 1:10
cumsum(x)
#>  [1]  1  3  6 10 15 21 28 36 45 55
```

### ۸.۴.۱۳ تمرینات

۱. توضیح دهید که `round()` چگونه کار می‌کند. خروجی `round(x)` در تعدادی از اعداد مثال بررسی کنید. بررسی کنید که آیا نتایج با آنچه انتظار دارید همخوانی دارد یا خیر.

۲. `floor()` چه کاری انجام می‌دهد؟ `ceiling()` چطور؟

۳. یک تابع بنویسید که از `cut()` برای سادهسازی یک بردار عددی به محدوده‌های متقاطع استفاده کند. به عنوان مثال، وقتی `breaks = 3` تنظیم شده باشد، باید محدوده‌های `[min, q1]`، `(q1, q2]`، `(q2, q3]`، `(q3, max]` را برگرداند جایی که q1، q2 و q3 چارک‌های یک چهارم، یک دوم و سه چهارم هستند.

## ۵.۱۳ تبدیلات عمومی

بخش‌های بعدی تبدیلاتی را معرفی می‌کنند که اغلب با بردارهای عددی استفاده می‌شوند اما می‌توانند به انواع دیگر نیز اعمال شوند.

### ۱.۵.۱۳ رتبه‌ها

dplyr توابعی برای رتبه‌بندی ارائه می‌دهد، اما باید با دقت انتخاب کنید. وارد شوید:

- `min_rank()` رایج‌ترین نوع رتبه‌بندی است (مثل در المپیک). این بزرگ‌ترین مقادیر را بزرگ‌ترین رتبه‌ها می‌دهد؛ از `desc(x)` برای دادن کوچک‌ترین مقادیر به بزرگ‌ترین رتبه‌ها استفاده کنید.

```{r}
x <- c(1, 2, 2, 3, 4, NA)
min_rank(x)
#> [1]  1  2  2  4  5 NA
min_rank(desc(x))
#> [1]  5  3  3  2  1 NA
```

- `row_number()` همیشه هر سطر یک رتبه منحصر به فرد می‌دهد. این همیشه تساوی‌ها را به روشی یکسان می‌شکند و ممکن است نتایج کمتر قابل تفسیری را بدهد.

```{r}
row_number(x)
#> [1]  1  2  3  4  5 NA
```

- `dense_rank()` مانند `min_rank()` کار می‌کند، اما رتبه‌ها را بدون شکاف حفظ می‌کند.

```{r}
dense_rank(x)
#> [1]  1  2  2  3  4 NA
```

- `percent_rank()` و `cume_dist()` رتبه را به یک عدد بین ۰ و ۱ نرمال می‌کنند. `percent_rank()` درصد از بزرگ‌ترین مقدار را می‌دهد و `cume_dist()` درصدی از مقادیر کمتر یا مساوی با مقدار فعلی را می‌دهد.

### ۲.۵.۱۳ افست‌ها

`dplyr::lag()` و `dplyr::lead()` به شما اجازه می‌دهند به مقادیر قبلی یا بعدی در یک بردار اشاره کنید، به شما اجازه می‌دهد تفاوت‌ها یا تغییرات در مقادیر را محاسبه کنید:

```{r}
x <- c(2, 5, 11, 11, 19, 35)
lag(x)
#> [1] NA  2  5 11 11 19
lead(x)
#> [1]  5 11 11 19 35 NA

x - lag(x)
#> [1] NA  3  6  0  8 16
x == lag(x)
#> [1]    NA FALSE FALSE  TRUE FALSE FALSE
```

### ۳.۵.۱۳ شناسه‌های متوالی

گاهی اوقات می‌خواهید یک شناسه جدید شروع کنید هر بار که برخی رویدادها رخ می‌دهند. به عنوان مثال، می‌خواهید بفهمید که در مجموعه داده `flights` چند زمان‌های مختلف پرواز وجود دارد؟

می‌توانید با استفاده از `lag()` == برای برابری با مقدار قبلی تست کنید. این یک حالت ویژه رایج است، بنابراین dplyr تابع کمکی `consecutive_id()` را ارائه می‌دهد:

```{r}
events <- tibble(
  time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30)
)

events <- events |> 
  mutate(
    diff = time - lag(time, default = first(time)),
    has_gap = diff >= 5
  )
events

events |> mutate(
  group = consecutive_id(has_gap)
)
```

### ۴.۵.۱۳ تمرینات

۱. نتیجه `min_rank(x)` را با `row_number(x)` مقایسه کنید. چه تفاوتی بین آن‌ها وجود دارد؟

۲. کدام هواپیما (`tailnum`) بدترین سابقه در زمان را دارد؟

۳. در چه ساعتی از روز باید پرواز کنید تا تأخیرها را تا حد امکان اجتناب کنید؟

۴. وقتی `n` مقادیر را با `min_rank(desc(x))` رتبه‌بندی می‌کنید، چگونه می‌توانید تمام سطرهایی با `rank == 1` را پیدا کنید؟

۵. با `flights` یک گروه بندی به نحوی انتخاب کنید که شناسه‌های متوالی را با `consecutive_id()` محاسبه کنید. چه مفیدی می‌بینید؟

## ۶.۱۳ خلاصه‌های عددی

فقط استفاده از توابع شمارش، مجموع و میانگین شما را خیلی دور می‌برد، بنابراین R مجموعه وسیعی از توابع خلاصه را ارائه می‌دهد. در اینجا یک انتخاب آورده شده که ممکن است مفید بیابید.

### ۱.۶.۱۳ مرکز

تاکنون بیشتر از `mean()` استفاده کرده‌ایم که مجموع را تقسیم بر تعداد می‌کند. میانگین مفید است زیرا تقسیم آن را به سطوح بالاتر "نرمال" می‌کند. یک جایگزین مفید `median()` است که مقدار وسط را پیدا می‌کند. `median()` مفید است زیرا نسبت به مقادیر پرت حساس نیست.

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    mean = mean(dep_delay, na.rm = TRUE),
    median = median(dep_delay, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  ) |> 
  ggplot(aes(x = mean, y = median)) + 
  geom_abline(slope = 1, intercept = 0, color = "white", linewidth = 2) +
  geom_point()
```

### ۲.۶.۱۳ حداقل، حداکثر و چارک‌ها

چه چیزی درباره توزیع می‌توانید بگویید؟ `min()` و `max()` کوچک‌ترین و بزرگ‌ترین مقادیر را می‌دهند. `quantile(x, 0.25)` مقداری را پیدا می‌کند که ۲۵٪ از `x` کمتر از آن است، `quantile(x, 0.5)` مقداری را پیدا می‌کند که ۵۰٪ کمتر از آن است (همان میانه)، و `quantile(x, 0.95)` مقداری را پیدا می‌کند که ۹۵٪ کمتر از آن است.

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    max = max(dep_delay, na.rm = TRUE),
    q95 = quantile(dep_delay, 0.95, na.rm = TRUE),
    .groups = "drop"
  )
#> # A tibble: 365 × 5
#>    year month   day   max   q95
#>   <int> <int> <int> <dbl> <dbl>
#> 1  2013     1     1   853  70.1
#> 2  2013     1     2   379  85  
#> 3  2013     1     3   291  68  
#> 4  2013     1     4   288  60  
#> 5  2013     1     5   327  41  
#> 6  2013     1     6   202  51  
#> # ℹ 359 more rows
```

### ۳.۶.۱۳ پراکندگی

گاهی اوقات نه به دنبال مرکز هستید، بلکه می‌خواهید بدانید داده‌ها چقدر پراکنده هستند. دو خلاصه رایج انحراف معیار `sd(x)` و واریانس `var(x)` هستند. انحراف معیار ریشه دوم واریانس است و واحد یکسانی با داده‌های اصلی دارد که تفسیر را آسان‌تر می‌کند.

```{r}
flights |> 
  group_by(origin) |> 
  summarize(distance_sd = sd(distance)) |> 
  arrange(desc(distance_sd))
#> # A tibble: 3 × 2
#>   origin distance_sd
#>   <chr>        <dbl>
#> 1 EWR           793.
#> 2 JFK           748.
#> 3 LGA           495.
```

### ۴.۶.۱۳ توزیع‌ها

بهتر است کل توزیع را در یک نگاه ببینید. یک راه خوب برای انجام این کار استفاده از `count()` با `cut_width()` است:

```{r}
flights |> 
  filter(dep_delay < 120) |> 
  ggplot(aes(x = dep_delay, group = origin, color = origin)) +
  geom_freqpoly(binwidth = 5)
```

### ۵.۶.۱۳ موقعیت‌ها

`first(x)`، `last(x)` و `nth(x, n)` به شما اجازه می‌دهند به موقعیت‌های خاص در یک بردار دسترسی پیدا کنید:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    first_dep = first(dep_time, na_rm = TRUE), 
    fifth_dep = nth(dep_time, 5, na_rm = TRUE),
    last_dep = last(dep_time, na_rm = TRUE),
    .groups = "drop"
  )
#> # A tibble: 365 × 6
#>    year month   day first_dep fifth_dep last_dep
#>   <int> <int> <int>     <int>     <int>    <int>
#> 1  2013     1     1       517       554     2356
#> 2  2013     1     2        42       535     2354
#> 3  2013     1     3        32       520     2349
#> 4  2013     1     4        25       531     2358
#> 5  2013     1     5        14       534     2357
#> 6  2013     1     6        16       555     2355
#> # ℹ 359 more rows
```

### ۶.۶.۱۳ با `mutate()`

همان‌طور که اشاره کردیم، همه توابع خلاصه را می‌توان با `mutate()` استفاده کرد. وقتی با `mutate()` ترکیب می‌شوند، خلاصه مجدداً بازیافت می‌شود تا طول مناسب را داشته باشد:

```{r}
x <- c(1:10, NA)
tibble(x) |> 
  mutate(
    mean = mean(x, na.rm = TRUE),
    median = median(x, na.rm = TRUE),
    count = n()
  )
#> # A tibble: 11 × 4
#>        x  mean median count
#>    <int> <dbl>  <dbl> <int>
#>  1     1   5.5    5.5    11
#>  2     2   5.5    5.5    11
#>  3     3   5.5    5.5    11
#>  4     4   5.5    5.5    11
#>  5     5   5.5    5.5    11
#>  6     6   5.5    5.5    11
#>  7     7   5.5    5.5    11
#>  8     8   5.5    5.5    11
#>  9     9   5.5    5.5    11
#> 10    10   5.5    5.5    11
#> 11    NA   5.5    5.5    11
```

### ۷.۶.۱۳ تمرینات

۱. با مشاهده نمودارهای میانگین تأخیر پرواز در مقابل میانه تأخیر پرواز، با توجه به مجموعه داده `flights` توزیع تأخیر پرواز را توصیف کنید.

۲. کدام مقصد بیشترین واریانس در سرعت هوا را دارد؟

۳. برای هر هواپیما، کارآمدترین (سریع‌ترین) و ناکارآمدترین (کندترین) پرواز را در سفری با فاصله یکسان محاسبه کنید.

## ۷.۱۳ خلاصه

شما حالا مهارت‌های اساسی برای دستکاری اعداد در R را دارید، که شامل ایجاد اعداد از رشته‌ها، شمارش، انجام عملیات حسابی پایه، گرد کردن، رتبه‌بندی و خلاصه‌سازی توزیع‌ها می‌شود. همچنین یاد گرفتید چگونه با تبدیلات شرطی کار کنید و در صورت نیاز از موقعیت‌ها استفاده کنید. در فصل بعد، به کار با رشته‌ها، یکی دیگر از انواع داده‌های رایج که در علم داده مواجه می‌شوید، خواهیم پرداخت.
