# ۱۷ تاریخ‌ها و زمان‌ها

## ۱.۱۷ مقدمه

این فصل نشان خواهد داد که چگونه با تاریخ‌ها و زمان‌ها در R کار کنید. در نگاه اول، تاریخ‌ها و زمان‌ها ساده به نظر می‌رسند. شما همیشه از آن‌ها در زندگی روزمره خود استفاده می‌کنید و به نظر نمی‌رسد که سردرگمی زیادی ایجاد کنند. با این حال، هرچه بیشتر در مورد تاریخ‌ها و زمان‌ها یاد بگیرید، پیچیده‌تر به نظر می‌رسند!

برای گرم شدن، فکر کنید که چند روز در یک سال وجود دارد و چند ساعت در یک روز وجود دارد. احتمالاً به یاد دارید که بیشتر سال‌ها 365 روز دارند، اما سال‌های کبیسه 366 روز دارند. آیا قانون کامل تعیین اینکه یک سال کبیسه است را می‌دانید؟ تعداد ساعت‌ها در یک روز کمی کمتر واضح است: بیشتر روزها 24 ساعت دارند، اما در مکان‌هایی که از زمان تابستانی (DST) استفاده می‌کنند، یک روز در سال 23 ساعت و روز دیگر 25 ساعت دارد.

یک سال کبیسه است اگر بر 4 بخش‌پذیر باشد، مگر اینکه بر 100 نیز بخش‌پذیر باشد، مگر اینکه بر 400 نیز بخش‌پذیر باشد. به عبارت دیگر، در هر مجموعه 400 ساله، 97 سال کبیسه وجود دارد.

تاریخ‌ها و زمان‌ها سخت هستند زیرا باید دو پدیده فیزیکی (چرخش زمین و مدار آن به دور خورشید) را با مجموعه‌ای کامل از پدیده‌های ژئوپلیتیکی شامل ماه‌ها، مناطق زمانی و DST هماهنگ کنند. این فصل همه جزئیات مربوط به تاریخ‌ها و زمان‌ها را به شما آموزش نخواهد داد، اما پایه محکمی از مهارت‌های عملی به شما خواهد داد که به شما در چالش‌های رایج تحلیل داده کمک می‌کند.

ما با نشان دادن نحوه ایجاد تاریخ-زمان از ورودی‌های مختلف شروع خواهیم کرد، و سپس پس از دریافت یک تاریخ-زمان، نحوه استخراج اجزایی مانند سال، ماه و روز را نشان خواهیم داد. سپس به موضوع پیچیده کار با بازه‌های زمانی خواهیم پرداخت که بسته به کاری که می‌خواهید انجام دهید، در انواع مختلفی ارائه می‌شوند. با بحث مختصری در مورد چالش‌های اضافی ناشی از مناطق زمانی به پایان خواهیم رسید.

### ۱.۱.۱۷ پیش‌نیازها

این فصل بر بسته **lubridate** تمرکز خواهد کرد که کار با تاریخ‌ها و زمان‌ها را در R آسان‌تر می‌کند. از آخرین نسخه tidyverse، lubridate بخشی از tidyverse اصلی است. همچنین به nycflights13 برای داده‌های تمرینی نیاز خواهیم داشت.

```{r}
#| message: false
library(tidyverse)
library(nycflights13)
```

## ۲.۱۷ ایجاد تاریخ/زمان

سه نوع داده تاریخ/زمان وجود دارد که به یک لحظه در زمان اشاره می‌کنند:

- **تاریخ** (date). Tibbleها این را به عنوان `<date>` چاپ می‌کنند.

- **زمان** (time) در طول روز. Tibbleها این را به عنوان `<time>` چاپ می‌کنند.

- **تاریخ-زمان** (date-time) یک تاریخ به اضافه یک زمان است: یک لحظه در زمان را به طور منحصر به فرد مشخص می‌کند (معمولاً تا نزدیک‌ترین ثانیه). Tibbleها این را به عنوان `<dttm>` چاپ می‌کنند. R پایه این‌ها را POSIXct می‌نامد، اما این نام چندان روان نیست.

در این فصل، ما بر تاریخ‌ها و تاریخ-زمان‌ها تمرکز خواهیم کرد زیرا R یک کلاس بومی برای ذخیره زمان‌ها ندارد. اگر به آن نیاز دارید، می‌توانید از بسته **hms** استفاده کنید.

همیشه باید از ساده‌ترین نوع داده ممکن که برای نیازهای شما کار می‌کند استفاده کنید. این بدان معناست که اگر می‌توانید از یک تاریخ به جای یک تاریخ-زمان استفاده کنید، باید این کار را انجام دهید. تاریخ-زمان‌ها به طور قابل توجهی پیچیده‌تر هستند زیرا نیاز به مدیریت مناطق زمانی دارند که در پایان فصل به آن باز خواهیم گشت.

برای دریافت تاریخ یا تاریخ-زمان فعلی می‌توانید از `today()` یا `now()` استفاده کنید:

```{r}
today()
now()
```

در غیر این صورت، بخش‌های زیر چهار روشی را که احتمالاً برای ایجاد یک تاریخ/زمان استفاده خواهید کرد، توضیح می‌دهند:

- هنگام خواندن یک فایل با readr.
- از یک رشته.
- از اجزای جداگانه تاریخ-زمان.
- از یک شیء تاریخ-زمان موجود.

### ۱.۲.۱۷ در طول وارد کردن

اگر CSV شما حاوی یک تاریخ یا تاریخ-زمان ISO8601 باشد، نیازی به انجام کار خاصی ندارید؛ readr به طور خودکار آن را تشخیص خواهد داد:

```{r}
#| message: false
csv <- "
  date,datetime
  2022-01-02,2022-01-02 05:12
"
read_csv(csv)
```

اگر قبلاً در مورد **ISO8601** چیزی نشنیده‌اید، این یک استاندارد بین‌المللی برای نوشتن تاریخ‌ها است که در آن اجزای یک تاریخ از بزرگترین به کوچکترین با جداکننده `-` سازماندهی می‌شوند. به عنوان مثال، در ISO8601 سوم مه 2022 به صورت `2022-05-03` نوشته می‌شود. تاریخ‌های ISO8601 می‌توانند شامل زمان‌ها نیز باشند، جایی که ساعت، دقیقه و ثانیه با `:` جدا می‌شوند و اجزای تاریخ و زمان با `T` یا فاصله جدا می‌شوند. به عنوان مثال، می‌توانید 4:26 بعدازظهر در سوم مه 2022 را به صورت `2022-05-03 16:26` یا `2022-05-03T16:26` بنویسید.

برای فرمت‌های دیگر تاریخ-زمان، باید از `col_types` به علاوه `col_date()` یا `col_datetime()` همراه با یک فرمت تاریخ-زمان استفاده کنید. فرمت تاریخ-زمان که توسط readr استفاده می‌شود یک استاندارد است که در بسیاری از زبان‌های برنامه‌نویسی استفاده می‌شود و یک جزء تاریخ را با یک `%` و به دنبال آن یک کاراکتر واحد توصیف می‌کند. به عنوان مثال، `%Y-%m-%d` یک تاریخ را مشخص می‌کند که یک سال، `-`، ماه (به عنوان عدد)، `-`، روز است. جدول @tbl-date-formats لیستی از تمام گزینه‌ها را خلاصه می‌کند.

| نوع | کد  | معنی                | مثال     |
|-----|-----|---------------------|----------|
| سال | `%Y` | سال 4 رقمی         | 2021     |
|     | `%y` | سال 2 رقمی         | 21       |
| ماه | `%m` | عدد 2 رقمی          | 2        |
|     | `%b` | نام مخفف شده        | Feb      |
|     | `%B` | نام کامل           | February |
| روز | `%d` | یک یا دو رقم        | 2        |
|     | `%e` | دو رقم             | 02       |
| زمان| `%H` | ساعت 24 ساعته       | 13       |
|     | `%I` | ساعت 12 ساعته       | 1        |
|     | `%p` | AM/PM              | pm       |
|     | `%M` | دقیقه              | 35       |
|     | `%S` | ثانیه              | 45       |
|     | `%OS`| ثانیه با اعشار     | 45.35    |
|     | `%Z` | منطقه زمانی (نام)  | America/Chicago |
|     | `%z` | منطقه زمانی (افست)| +0800    |
| دیگر| `%.` | رد کردن یک کاراکتر غیرعددی | .        |
|     | `%*` | رد کردن هر تعداد کاراکتر غیرعددی |  |

: همه مشخص‌کننده‌های فرمت تاریخ. {#tbl-date-formats}

و این کد نحوه استفاده از آن‌ها را در عمل نشان می‌دهد:

```{r}
#| message: false
csv <- "
  date
  01/02/15
"

read_csv(csv, col_types = cols(date = col_date("%m/%d/%y")))

read_csv(csv, col_types = cols(date = col_date("%d/%m/%y")))

read_csv(csv, col_types = cols(date = col_date("%y/%m/%d")))
```

توجه کنید که مهم نیست چگونه تاریخ را نمایش می‌دهید، همیشه مقادیر ساختار یافته مشابهی تولید می‌کند.

اگر از `%b` یا `%B` و با داده‌های غیرانگلیسی کار می‌کنید، باید `locale()` را به `read_csv()` ارائه دهید. برای جزئیات بیشتر به `?locale` مراجعه کنید.

### ۲.۲.۱۷ از رشته‌ها

داده‌های تاریخ/زمان اغلب به صورت رشته‌ها ارائه می‌شوند. ممکن است توابع ymd، ydm، mdy، myd، dmy و dym از lubridate را مفید بدانید. این توابع به طور خودکار یک بردار رشته را به تاریخ تبدیل می‌کنند:

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

این توابع همچنین اعداد کوتاهی را می‌گیرند. این احتمالاً سریع‌ترین راه برای ایجاد یک شیء تاریخ واحد است، و می‌توانید در سرتاسر این فصل از آن استفاده کنید:

```{r}
ymd(20170131)
```

`ymd()` و دوستانش یک تاریخ ایجاد می‌کنند. برای ایجاد یک تاریخ-زمان، یک پسوند (`_h`، `_hm`، یا `_hms`) را به نام تابع تجزیه‌کننده اضافه کنید:

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

همچنین می‌توانید یک تاریخ-زمان را با ارائه یک منطقه زمانی به عنوان آرگومان `tz` مجبور کنید:

```{r}
ymd("2017-01-31", tz = "UTC")
```

در اینجا، `tz` مخفف منطقه زمانی است. شما در @sec-time-zones بیشتر درباره آن یاد خواهید گرفت.

### ۳.۲.۱۷ از اجزای جداگانه

گاهی اوقات به جای یک رشته واحد، اجزای جداگانه یک تاریخ-زمان در چندین ستون گسترش یافته‌اند. این کاری است که با داده‌های پرواز در `nycflights13` انجام می‌شود:

```{r}
flights |> 
  select(year, month, day, hour, minute)
```

برای ایجاد یک تاریخ/زمان از این نوع ورودی، از `make_date()` برای تاریخ‌ها یا `make_datetime()` برای تاریخ-زمان‌ها استفاده کنید:

```{r}
flights |> 
  select(year, month, day, hour, minute) |> 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

بیایید همان کار را برای هر یک از چهار ستون زمانی در `flights` انجام دهیم. زمان‌ها به شکل کمی عجیب نمایش داده می‌شوند، بنابراین از حساب مدولار برای جدا کردن اجزای ساعت و دقیقه استفاده می‌کنیم. هنگامی که همه اطلاعات را ایجاد کردیم، بر متغیرهای ورودی تمرکز می‌کنیم که برای کاوش استفاده خواهیم کرد.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights |> 
  filter(!is.na(dep_time), !is.na(arr_time)) |> 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) |> 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

با این داده‌ها می‌توانیم توزیع زمان‌های پرواز را در طول سال تجسم کنیم:

```{r}
#| fig.alt: >
#|   یک چندضلعی فراوانی با زمان حرکت (ژانویه تا دسامبر 2013) روی محور x
#|   و تعداد پروازها روی محور y (0-1000). چندضلعی فراوانی
#|   به صورت روزانه گروه‌بندی شده است، بنابراین یک سری زمانی از پروازها را در هر روز مشاهده می‌کنید.
#|   الگو تحت سلطه الگوی هفتگی است؛ در تعطیلات آخر هفته پروازهای کمتری وجود دارد.
#|   چند روز وجود دارد که به عنوان روزهای با پروازهای تعجب‌آور کم در اوایل فوریه،
#|   اوایل ژوئیه، اواخر نوامبر و اواخر دسامبر برجسته هستند.

flights_dt |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 ثانیه = 1 روز
```

یا در یک روز واحد:

```{r}
#| fig.alt: >
#|   یک چندضلعی فراوانی با زمان حرکت (6 صبح - نیمه شب 1 ژانویه) روی
#|   محور x، تعداد پروازها روی محور y (0-17)، گروه‌بندی شده در افزایش 10 دقیقه‌ای.
#|   به دلیل تنوع بالا، دیدن الگوی زیادی سخت است، اما بیشتر بین‌ها 8-12 پرواز دارند،
#|   و پروازهای قابل توجهی کمتری قبل از 6 صبح و بعد از 8 شب وجود دارد.

flights_dt |> 
  filter(dep_time < ymd(20130102)) |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 ثانیه = 10 دقیقه
```

توجه کنید که وقتی از تاریخ-زمان‌ها در یک زمینه عددی استفاده می‌کنید (مانند یک هیستوگرام)، 1 به معنای 1 ثانیه است، بنابراین binwidth 86400 به معنای یک روز است. برای تاریخ‌ها، 1 به معنای 1 روز است.

### ۴.۲.۱۷ از انواع دیگر

ممکن است بخواهید بین یک تاریخ-زمان و یک تاریخ جابه‌جا شوید. این کار `as_datetime()` و `as_date()` است:

```{r}
as_datetime(today())
as_date(now())
```

گاهی اوقات تاریخ‌ها/زمان‌ها را به عنوان افست‌های عددی از "عصر یونیکس"، 1970-01-01 دریافت خواهید کرد. اگر افست بر حسب ثانیه باشد، از `as_datetime()` استفاده کنید؛ اگر در روزها باشد، از `as_date()` استفاده کنید.

```{r}
as_datetime(60 * 60 * 10)
as_date(365 * 10 + 2)
```

### ۵.۲.۱۷ تمرین‌ها

1. چه اتفاقی می‌افتد اگر یک رشته را تجزیه کنید که حاوی تاریخ‌های نامعتبر است؟

```{r}
#| eval: false
ymd(c("2010-10-10", "bananas"))
```

2. آرگومان `tzone` برای `today()` چه کاری انجام می‌دهد؟ چرا مهم است؟

3. برای هر تابع زیر از lubridate، توصیف کنید که چه چیزی را تجزیه می‌کند:

   a. `ymd_hms()`
   b. `mdy()`
   c. `dmy_hms()`

## ۳.۱۷ اجزای تاریخ-زمان

حالا که می‌دانید چگونه داده‌های تاریخ-زمان را در ساختارهای داده تاریخ-زمان R دریافت کنید، بیایید کاوش کنیم که با آن‌ها چه کاری می‌توانید انجام دهید. این بخش بر توابع دسترسی که به شما اجازه می‌دهند اجزای فردی را دریافت و تنظیم کنید، تمرکز خواهد کرد. بخش بعدی به نحوه کار محاسباتی با تاریخ-زمان‌ها نگاه خواهد کرد.

### ۱.۳.۱۷ دریافت اجزا

می‌توانید اجزای جداگانه یک تاریخ را با توابع دسترسی `year()`, `month()`, `mday()` (روز از ماه)، `yday()` (روز از سال)، `wday()` (روز از هفته)، `hour()`, `minute()`, و `second()` استخراج کنید. این‌ها بردار یک تاریخ-زمان را می‌گیرند و یک عدد بازمی‌گردانند.

```{r}
datetime <- ymd_hms("2026-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)

yday(datetime)
wday(datetime)
```

برای `month()` و `wday()` می‌توانید `label = TRUE` را تنظیم کنید تا نام مخفف شده ماه یا روز هفته را بازگردانید. `abbr = FALSE` را تنظیم کنید تا نام کامل را بازگرداند.

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

می‌توانیم از `wday()` برای دیدن اینکه در روزهای هفته، پروازهای بیشتری حرکت می‌کنند یا آخرهای هفته استفاده کنیم:

```{r}
flights_dt |> 
  mutate(wday = wday(dep_time, label = TRUE)) |> 
  ggplot(aes(x = wday)) +
  geom_bar()
```

یک الگوی جالب در نمودار وجود دارد: به نظر می‌رسد که در روز یکشنبه پروازهای بیشتری از روز شنبه وجود دارد! اگر به داده‌های خام نگاه کنیم، این منطقی به نظر می‌رسد:

```{r}
flights_dt |> 
  mutate(wday = wday(dep_time, label = TRUE)) |> 
  group_by(wday) |> 
  summarize(
    avg_dep_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  )
```

جالب است که اگر به تأخیر متوسط در طول ساعت روز نگاه کنیم، یک الگوی قوی قابل ملاحظه ببینیم. به نظر می‌رسد پروازهایی که در اوایل روز برنامه‌ریزی شده‌اند تمایل کمتری به تأخیر دارند.

```{r}
#| fig-alt: >
#|   نمودار خطی با ساعت حرکت برنامه‌ریزی شده روی محور x و میانگین تأخیر
#|   حرکت روی محور y. تأخیر متوسط در حدود 5 دقیقه در 6 صبح شروع می‌شود،
#|   به طور ثابت در طول روز افزایش می‌یابد تا در حدود 20 دقیقه در 7 بعدازظهر به اوج خود برسد،
#|   سپس به حدود 10 دقیقه سقوط می‌کند.

flights_dt |> 
  mutate(minute = minute(dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  ) |> 
  ggplot(aes(x = minute, y = avg_delay)) +
  geom_line()
```

جالب است، اگر به زمان _برنامه‌ریزی شده_ حرکت نگاه کنیم، یک الگوی قوی قابل مشاهده نمی‌بینیم:

```{r}
#| fig-alt: >
#|   نمودار خطی با ساعت حرکت برنامه‌ریزی شده روی محور x و میانگین تأخیر
#|   حرکت روی محور y. تأخیر متوسط در حدود 5 دقیقه در 6 صبح شروع می‌شود،
#|   به طور ثابت در طول روز افزایش می‌یابد تا در حدود 20 دقیقه در 7 بعدازظهر به اوج خود برسد،
#|   سپس به حدود 10 دقیقه سقوط می‌کند.

sched_dep <- flights_dt |> 
  mutate(minute = minute(sched_dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  )

ggplot(sched_dep, aes(x = minute, y = avg_delay)) +
  geom_line()
```

پس چرا در دقیقه واقعی یک الگوی قوی می‌بینیم اما نه در دقیقه برنامه‌ریزی شده؟ خوب، مانند بسیاری از داده‌های انسانی، تمایل زیادی به پروازهایی که در "خوب" زمان حرکت می‌کنند وجود دارد، همانطور که نمودار `n` نشان می‌دهد:

```{r}
ggplot(sched_dep, aes(x = minute, y = n)) +
  geom_line()
```

### ۲.۳.۱۷ گرد کردن

یک روش جایگزین برای ترسیم اجزای فردی این است که تاریخ را با `floor_date()`, `round_date()`, و `ceiling_date()` به یک واحد زمانی نزدیک گرد کنید. هر تابع یک بردار تاریخ برای تنظیم و سپس نام واحد را می‌گیرد تا به سمت پایین (floor)، بالا (ceiling)، یا نزدیکترین (round) گرد کند. این، به عنوان مثال، می‌توانیم تعداد پروازها را در هر هفته ترسیم کنیم:

```{r}
flights_dt |> 
  count(week = floor_date(dep_time, "week")) |> 
  ggplot(aes(x = week, y = n)) +
  geom_line() + 
  geom_point()
```

می‌توانید از گرد کردن برای نمایش توزیع پروازها در طول روز با محاسبه تفاوت بین `dep_time` و اولین لحظه آن روز استفاده کنید:

```{r}
flights_dt |> 
  mutate(dep_hour = dep_time - floor_date(dep_time, "day")) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

محاسبه تفاوت بین یک جفت تاریخ-زمان یک difftime (که در @sec-intervals بیشتر بحث می‌کنیم) به دست می‌دهد. می‌توانیم آن را به یک مقدار عددی با `as.numeric()` تبدیل کنیم:

```{r}
flights_dt |> 
  mutate(dep_hour = as.numeric(dep_time - floor_date(dep_time, "day"))) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

### ۳.۳.۱۷ تغییر اجزا

همچنین می‌توانید از هر تابع دسترسی برای تنظیم اجزای یک تاریخ/زمان استفاده کنید:

```{r}
(datetime <- ymd_hms("2026-07-08 12:34:56"))

year(datetime) <- 2030
datetime

month(datetime) <- 01
datetime

hour(datetime) <- hour(datetime) + 1
datetime
```

به جای تغییر در محل، می‌توانید یک تاریخ-زمان جدید با `update()` ایجاد کنید. این همچنین به شما اجازه می‌دهد چندین مقدار را به طور همزمان تنظیم کنید:

```{r}
update(datetime, year = 2030, month = 2, mday = 2, hour = 2)
```

اگر مقادیر بیش از حد بزرگ باشند، سرریز خواهند کرد:

```{r}
update(ymd("2023-02-01"), mday = 30)
```

می‌توانید از `update()` برای نشان دادن توزیع پروازها در طول روز برای هر روز از سال استفاده کنید:

```{r}
flights_dt |> 
  mutate(dep_hour = update(dep_time, yday = 1)) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

تنظیم اجزای بزرگتر یک تاریخ به یک مقدار ثابت یک روش قدرتمند است که به شما اجازه می‌دهد الگوهای موجود در اجزای کوچکتر را کاوش کنید.

### ۴.۳.۱۷ تمرین‌ها

1. چگونه توزیع زمان‌های پرواز در طول یک سال تغییر می‌کند؟

2. `dep_time`, `sched_dep_time` و `dep_delay` را مقایسه کنید. آیا سازگار هستند؟ انتظارات خود را توضیح دهید.

3. زمان حرکت واقعی با زمان حرکت برنامه‌ریزی شده مقایسه کنید. آیا فرودگاه‌هایی هستند که به طور مشخص بد هستند؟

4. متوسط تأخیر را برای هر مقصد بر اساس روز سال، سپس بر اساس روز هفته محاسبه کنید. کدام رویکرد اطلاعات بیشتری درباره تأخیرهای رخ داده می‌دهد؟

5. اگر می‌خواهید تأخیرها را در روز حرکت به حداقل برسانید، چه روزی از هفته باید پرواز کنید؟

6. چه چیزی نمودار `flights |> mutate(wday = wday(dep_time, label = TRUE)) |> group_by(wday) |> summarize(mean_dep_delay = mean(dep_delay, na.rm = TRUE))` را جالب می‌کند؟ چگونه می‌توان نمودار را بهبود بخشید؟

7. ایده پشت محاسبه `dep_hour = dep_time - floor_date(dep_time, "day")` چیست؟ چگونه الگوی را برای نمایش تأخیر متوسط به صورت دقیقه در ساعت استفاده خواهید کرد؟

## ۴.۱۷ بازه‌های زمانی

در ادامه یاد خواهید گرفت که چگونه محاسبات با تاریخ‌ها کار می‌کند، از جمله تفریق، جمع و تقسیم. در طول راه، سه کلاس مهم را یاد خواهید گرفت که بازه‌های زمانی را نمایش می‌دهند:

- **مدت‌ها** (durations)، که تعداد دقیق ثانیه‌ها را نمایش می‌دهند.
- **دوره‌ها** (periods)، که واحدهای انسانی مانند هفته‌ها و ماه‌ها را نمایش می‌دهند.
- **فواصل** (intervals)، که نقطه شروع و پایان را نمایش می‌دهند.

چگونه باید بین مدت، دوره و فاصل انتخاب کنید؟ همیشه ساده‌ترین ساختار داده‌ای که مشکل شما را حل می‌کند انتخاب کنید. اگر فقط به زمان فیزیکی اهمیت می‌دهید، از یک مدت استفاده کنید؛ اگر نیاز دارید واحدهای انسانی را اضافه کنید، از یک دوره استفاده کنید؛ اگر نیاز دارید بفهمید که یک بازه چقدر طولانی است به واحدهای انسانی، از یک فاصل استفاده کنید.

### ۱.۴.۱۷ مدت‌ها

در R، وقتی دو تاریخ را از هم کم می‌کنید، یک شیء difftime دریافت می‌کنید:

```{r}
# چند سالگی است Hadley؟
h_age <- today() - ymd("1979-10-14")
h_age
```

یک شیء کلاس difftime بازه زمانی را بر حسب ثانیه، دقیقه، ساعت، روز یا هفته ثبت می‌کند. این ابهام می‌تواند کار با difftimes را کمی دردسرساز کند، بنابراین lubridate یک جایگزین ارائه می‌دهد که همیشه از ثانیه استفاده می‌کند: **مدت**.

```{r}
as.duration(h_age)
```

مدت‌ها با تعدادی سازنده راحت ارائه می‌شوند:

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

مدت‌ها همیشه بازه زمانی را بر حسب ثانیه ثبت می‌کنند. مضرب‌های بزرگتر با تبدیل دقیقه، ساعت، روز، هفته و سال به ثانیه ایجاد می‌شوند: 60 ثانیه در یک دقیقه، 60 دقیقه در یک ساعت، 24 ساعت در یک روز، و 7 روز در یک هفته. مضرب‌های بزرگتر کمی بیشتر ابهام دارند، اما lubridate فرض می‌کند که یک سال استاندارد 365 روز دارد که پیرو استانداردهای بین‌المللی مانند SI است.

می‌توانید مدت‌ها را جمع و ضرب کنید:

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

می‌توانید مدت‌ها را به روزها و از روزها جمع و تفریق کنید:

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

با این حال، از آنجایی که مدت‌ها تعداد دقیق ثانیه‌ها را نمایش می‌دهند، گاهی اوقات نتیجه غیرمنتظره‌ای می‌گیرید:

```{r}
one_am <- ymd_hms("2026-03-08 01:00:00", tz = "America/New_York")

one_am
one_am + ddays(1)
```

چرا یک روز بعد از ساعت 1 صبح در 8 مارس، ساعت 2 صبح در 9 مارس است؟ اگر با دقت به تاریخ نگاه کنید، ممکن است متوجه شوید که مناطق زمانی نیز تغییر کرده‌اند. 8 مارس فقط 23 ساعت طول کشیده است زیرا زمان تابستانی شروع شده است، بنابراین اگر یک روز کامل ثانیه اضافه کنیم، یک ساعت متفاوت دریافت می‌کنیم.

### ۲.۴.۱۷ دوره‌ها

برای حل این مشکل، lubridate **دوره‌ها** را ارائه می‌دهد. دوره‌ها بازه‌های زمانی هستند اما واحدهای زمانی دقیق ندارند، که آن‌ها را قابل اعتمادتر برای کار می‌کند:

```{r}
one_am
one_am + days(1)
```

مانند مدت‌ها، دوره‌ها را می‌توان با تعدادی تابع سازنده راحت ایجاد کرد.

```{r}
hours(c(12, 24))
days(7)
months(1:6)
```

می‌توانید دوره‌ها را جمع و ضرب کنید:

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

و البته، آن‌ها را به تاریخ‌ها اضافه کنید. در مقایسه با مدت‌ها، دوره‌ها بیشتر احتمال دارد که کاری را انجام دهند که انتظار دارید:

```{r}
# یک سال کبیسه
ymd("2024-01-01") + dyears(1)
ymd("2024-01-01") + years(1)

# زمان تابستانی
one_am + ddays(1)
one_am + days(1)
```

بیایید از دوره‌ها استفاده کنیم تا یک ناهمگونی آشکار مربوط به پروازهای ما را اصلاح کنیم. برخی از هواپیماها به نظر می‌رسد قبل از رسیدن پرواز کرده‌اند!

```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

اینها پروازهای شبانه هستند. ما از همان اطلاعات تاریخ برای تاریخ حرکت و تاریخ رسیدن استفاده کردیم، اما این پروازها در روز بعد فرود آمده‌اند. می‌توانیم این را با اضافه کردن `days(1)` به زمان رسیدن هر پرواز شبانه اصلاح کنیم.

```{r}
flights_dt <- flights_dt |> 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight),
    sched_arr_time = sched_arr_time + days(overnight)
  )
```

حالا همه پروازهای ما در داده مان محدوده زمانی منطقی را دنبال می‌کنند.

```{r}
flights_dt |> 
  filter(overnight, arr_time < dep_time) 
```

### ۳.۴.۱۷ فواصل

واضح است که `dyears(1) / ddays(365)` باید یک را برگرداند، زیرا مدت‌ها همیشه به معنای تعداد ثانیه‌ها هستند، و یک سال مدت به عنوان 365 روز ثانیه تعریف می‌شود.

چه چیزی `years(1) / days(1)` باید برگرداند؟ خوب، اگر سال 2015 باشد باید 365 برگرداند، اما اگر سال 2016 باشد باید 366 برگرداند! استفاده از دوره به معنای آن نیست که شما سوال شفافی پرسیده‌اید، و این خوب نیست. به جای آن، ما نیاز داریم که یک **فاصل** استفاده کنیم. یک فاصل یک مدت با یک نقطه شروع است: که آن را دقیق می‌کند بنابراین می‌توانید تعیین کنید که دقیقاً چقدر طول دارد:

```{r}
y2023 <- ymd("2023-01-01") %--% ymd("2024-01-01")
y2024 <- ymd("2024-01-01") %--% ymd("2025-01-01")

y2023
y2024
```

سپس می‌توانید یک فاصل را با یک مدت تقسیم کنید تا ببینید چند روز تطابق دارد:

```{r}
y2023 / days(1)
y2024 / days(1)
```

### ۴.۴.۱۷ تمرین‌ها

1. چرا `months(1:12)` را نمی‌توان استفاده کرد؟

2. توضیح دهید که `days(!overnight)` به `flights_dt` چه چیزی را اضافه می‌کند.

3. یک بردار تاریخ ایجاد کنید که اولین روز هر ماه در 2015 را شامل شود. یک بردار تاریخ ایجاد کنید که اولین روز هر ماه در سال _فعلی_ را شامل شود.

4. یک تابع بنویسید که تولدی را دریافت کند (به عنوان یک تاریخ)، و سن کنونی فرد را بازگرداند.

5. چرا `(today() %--% (today() + years(1))) / months(1)` کار نمی‌کند؟

## ۵.۱۷ مناطق زمانی

مناطق زمانی یک موضوع فوق‌العاده پیچیده هستند به دلیل تعامل آن‌ها با موجودیت‌های ژئوپلیتیکی. خوشبختانه ما نیازی به حفاری در همه جزئیات نداریم زیرا همه آن‌ها برای تحلیل داده مهم نیستند، اما چند چالش وجود دارد که باید با آن‌ها رو در رو شویم.

اولین چالش این است که نام‌های روزمره مناطق زمانی تمایل دارند مبهم باشند. به عنوان مثال، اگر آمریکایی هستید، احتمالاً با EST یا Eastern Standard Time آشنا هستید. با این حال، استرالیا و کانادا هر دو EST دارند! برای جلوگیری از سردرگمی، R از استاندارد بین‌المللی IANA time zones استفاده می‌کند. این‌ها از یک طرح نام‌گذاری ثابت `{area}/{location}` استفاده می‌کنند، که معمولاً به شکل `{continent}/{city}` یا `{ocean}/{city}` است. به عنوان مثال، "America/New_York"، "Europe/Paris" و "Pacific/Auckland".

ممکن است تعجب کنید که چرا منطقه زمانی از یک شهر استفاده می‌کند، وقتی که معمولاً به مناطق زمانی مرتبط با یک کشور یا منطقه در یک کشور فکر می‌کنید. این به این دلیل است که پایگاه داده IANA باید تاریخچه دهه‌ها از قوانین منطقه زمانی را ثبت کند. در طول این سال‌ها، کشورها نه تنها تغییر نام داده‌اند (مثلاً چکسلواکی به جمهوری چک و اسلواکی تقسیم شد) بلکه قوانین منطقه زمانی در مرزهای منطقه همگن نیستند. پایگاه داده IANA باید رکوردی از تمام این تغییرات را نگه دارد و به دلیل اینکه شهرها به ندرت بدون تغییر نام باقی می‌مانند یا دولت‌های جدید تصرف نمی‌شوند، از آن‌ها استفاده می‌کند.

می‌توانید بفهمید R فکر می‌کند منطقه زمانی شما چیست با `Sys.timezone()`:

```{r}
Sys.timezone()
```

(اگر R نمی‌داند، یک `NA` دریافت خواهید کرد.)

و کل لیست همه نام‌های مناطق زمانی را با `OlsonNames()` مشاهده کنید:

```{r}
length(OlsonNames())
head(OlsonNames())
```

در R، منطقه زمانی یک ویژگی تاریخ-زمان است که فقط کنترل می‌کند چگونه چاپ می‌شود. به عنوان مثال، این سه شیء نمایش‌دهنده یک لحظه در زمان هستند:

```{r}
x1 <- ymd_hms("2024-06-01 12:00:00", tz = "America/New_York")
x1

x2 <- ymd_hms("2024-06-01 18:00:00", tz = "Europe/Copenhagen")
x2

x3 <- ymd_hms("2024-06-02 04:00:00", tz = "Pacific/Auckland")
x3
```

می‌توانید این را با تفریق آن‌ها تأیید کنید:

```{r}
x1 - x2
x1 - x3
```

مگر اینکه خلاف مشخص شود، lubridate همیشه از UTC استفاده می‌کند. UTC (Coordinated Universal Time) استاندارد جهانی علمی است و تقریباً معادل منطقه زمانی GMT (Greenwich Mean Time) آشناست. این منطقه زمانی DST ندارد، که آن را یک نمایش راحت برای محاسبه می‌کند. عملیاتی مانند `c()` اغلب منطقه زمانی را حذف خواهند کرد. در این مورد، تاریخ-زمان‌ها در منطقه زمانی اولین عنصر نمایش داده خواهند شد:

```{r}
x4 <- c(x1, x2, x3)
x4
```

می‌توانید منطقه زمانی را به دو روش تغییر دهید:

- مؤلفه‌های زمانی زیرین را حفظ کنید، و برچسب را تغییر دهید. از این استفاده کنید وقتی که یک لحظه دارید که به اشتباه برچسب گذاری شده است، و باید آن را اصلاح کنید.

```{r}
x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
x4a
x4a - x4
```

(این یک منطقه زمانی جالب استفاده می‌کند: Australia/Lord_Howe دارای یک افست 30 دقیقه‌ای است!)

- لحظه زمانی را تغییر دهید. از این استفاده کنید وقتی که یک لحظه فعلی دارید، و می‌خواهید ببینید وقت چه زمانی در یک منطقه زمانی دیگر خواهد بود.

```{r}
x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
x4b
x4b - x4
```

## ۶.۱۷ خلاصه

این فصل شما را با ابزارهایی که lubridate برای کمک به شما در کار با داده‌های تاریخ-زمان ارائه می‌دهد، آشنا کرده است. کار با تاریخ‌ها و زمان‌ها می‌تواند سخت‌تر از آنچه لازم است به نظر برسد، اما امیدواریم این فصل به شما کمک کرده باشد تا ببینید چرا — تاریخ-زمان‌ها پیچیده‌تر از آن چیزی هستند که در نگاه اول به نظر می‌رسند، و مدیریت هر موقعیت ممکن پیچیدگی اضافه می‌کند. حتی اگر داده‌های شما هرگز از مرز زمان تابستانی عبور نکنند یا شامل یک سال کبیسه نباشند، توابع باید قادر به مدیریت آن باشند.

فصل بعدی خلاصه‌ای از مقادیر گمشده را ارائه می‌دهد. شما آن‌ها را در چند مکان دیده‌اید و بی‌شک در تحلیل خود با آن‌ها مواجه شده‌اید، و حالا زمان آن است که مجموعه‌ای از تکنیک‌های مفید برای برخورد با آن‌ها ارائه دهیم.
